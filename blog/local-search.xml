<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>「硬核JS」深入了解异步解决方案</title>
    <link href="/blog/2020/02/14/javascript/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/blog/2020/02/14/javascript/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="「硬核-JS」深入了解异步解决方案"><a href="#「硬核-JS」深入了解异步解决方案" class="headerlink" title="「硬核 JS」深入了解异步解决方案"></a>「硬核 JS」深入了解异步解决方案</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Javascript 语言的执行环境是<code>单线程</code>(single thread，指一次只能完成一件任务，如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推)</p><p>这种模式的好处是实现起来比较简单，执行环境相对单纯，坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行，常见的浏览器无响应(假死)，往往就是因为某一段 Javascript 代码长时间运行(比如死循环)，导致整个页面卡在这个地方，其他任务无法执行</p><p>为了解决这个问题，Javascript 将任务的执行模式分成两种：同步(Synchronous)和异步(Asynchronous)</p><p><code>同步模式</code> 就是后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的</p><p><code>异步模式</code>则完全不同，每一个任务有一个或多个回调函数(callback)，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的，在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是 Ajax 操作。在服务器端，<code>异步模式</code>甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有 http 请求，服务器性能会急剧下降</p><p>前面都是些无用的话，因为大家都对此很清楚，那么，问题来了，你了解几种异步解决方案？</p><p>本文会由浅入深的叙述下面几种已知的异步解决方案，以及它们的区别</p><ul><li>回调函数(callback)</li><li>事件监听(发布/订阅)解析</li><li>Promise 解析及从 0 ～ 1 的源码体验</li><li>Generator 全面解析</li><li>Async/Await 解析</li></ul><p>赶上春节不出门为国家做贡献，写了这篇帖子，本文有点长，因为本来要写四篇文章分别叙述，但是我觉得还是在一块看比较容易对比理解，大概有两万字左右，如果你肯花 20 分钟的时间阅读本文，定会有所收获，我在耐心写，也希望大家可以耐心看完，基础不太好的同学可以分块看，已详细注明各级标题，希望通过本文可以让大家对大 JS 异步编程加深了解</p><p>哦对了，先赞在看，养成习惯，毕竟码字不易，大家的每一个赞和评论都将为我码下一篇文章添一些动力，多谢 😁</p><h2 id="回调函数-callback"><a href="#回调函数-callback" class="headerlink" title="回调函数(callback)"></a>回调函数(callback)</h2><h3 id="简述回调函数"><a href="#简述回调函数" class="headerlink" title="简述回调函数"></a>简述回调函数</h3><p>回调函数大家都应该清楚，简单理解就是一个函数被作为参数传递给另一个函数</p><p>回调并不一定就是异步，并没有直接关系，只不过回调函数是异步的一种解决方案</p><p>我们用例子来简单说明下</p><pre><code class="js">function fn1(callback) {  console.log(&quot;1&quot;)  callback &amp;&amp; callback()}function fn2() {  console.log(&quot;2&quot;)}fn1(fn2)</code></pre><p>如上代码所示，函数 fn1 参数为一个回调，调用 fn1 时传进入了函数 fn2，那么在函数 fn1 执行到 callback 函数调用时会调用 fn2 执行，这是一个典型的回调函数，不过是同步的，我们可以利用这点来解决异步，如下</p><pre><code class="js">fn1(callback){  setTimeout(() =&gt; {    callback &amp;&amp; callback()  }, 1000)}fn1(()=&gt;{  console.log(&quot;1&quot;)})</code></pre><p>如上所示，我们使用 setTimeout 在函数 fn1 中模拟了一个耗时 1s 的任务，耗时任务结束会抛出一个回调，那么我们在调用时就可以做到在函数 fn1 的耗时任务结束后执行回调函数了</p><p>采用这种方式，我们把同步操作变成了异步操作，fn1 不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行</p><h3 id="回调函数优-缺"><a href="#回调函数优-缺" class="headerlink" title="回调函数优/缺"></a>回调函数优/缺</h3><p><strong>优点</strong></p><p>一句话，回调函数是异步编程最基本的方法，其优点是简单、容易理解和部署</p><p><strong>缺点</strong></p><p>回调函数最大的缺点是不利于代码的阅读和维护，各个部分之间高度耦合(Coupling)</p><pre><code class="js">fun1(() =&gt; {  fun2(() =&gt; {    fun3(() =&gt; {      fun4(() =&gt; {        fun5(() =&gt; {          fun6()        })      })    })  })})</code></pre><p>上面这种代码在之前使用 AJAX 请求时很常见，因为业务上在一个请求结束后发起另一个请求的需求太多了，代码不优雅，不易阅读维护，高耦合，层层嵌套造成这种<strong>回调地狱</strong></p><p>异步回调中，回调函数的执行栈与原函数分离开，外部无法抓住异常，异常会变得不可控</p><p>虽然缺点多，但回调函数日常开发中也不可或缺，使用时注意就好了</p><p>回调函数比较简单常用，就先介绍到这里，接下来我们看事件监听</p><h2 id="事件监听-发布订阅模式"><a href="#事件监听-发布订阅模式" class="headerlink" title="事件监听(发布订阅模式)"></a>事件监听(发布订阅模式)</h2><p>解决异步，可以采用事件驱动，任务的执行不取决于代码的顺序，而取决于某个事件是否发生</p><p>在阮一峰老师早期发布的 <strong>Javascript 异步编程的 4 种方法(参考链接【1】)</strong> 一文中，把事件监听和发布订阅作为了不同的两种解决方案，但是我个人觉得这两种完全可以并为一种，都是利用了发布订阅模式的事件驱动，所以就放一块解释了</p><h3 id="JQuery-实现事件监听"><a href="#JQuery-实现事件监听" class="headerlink" title="JQuery 实现事件监听"></a>JQuery 实现事件监听</h3><p>jquery 实现比较简单，因为 jq 为我们封装好了方法，使用即可，只是 JQ 不常用了，简单了解下</p><p>我们可以使用 jquery 中的<code>on</code>来监听事件，使用<code>trigger</code>触发事件，如下</p><pre><code class="js">$(&quot;body&quot;).on(&quot;done&quot;, fn2)function fn1() {  setTimeout(function() {    $(&quot;body&quot;).trigger(&quot;done&quot;)  }, 2000)}function fn2() {  console.log(&quot;fn2执行了&quot;)}fn1()</code></pre><p>我们使用 jq 的<code>on</code>监听了一个自定义事件<code>done</code>，传入了 fn2 回调，表示事件触发后立即执行函数 fn2</p><p>在函数 fn1 中使用 setTimeout 模拟了耗时任务，setTimeout 回调中使用<code>trigger</code>触发了<code>done</code>事件</p><p>我们可以使用<code>on</code>来绑定多个事件，每个事件可以指定多个回调函数</p><h3 id="JavaScript-实现事件监听"><a href="#JavaScript-实现事件监听" class="headerlink" title="JavaScript 实现事件监听"></a>JavaScript 实现事件监听</h3><p>在 JS 中我们要自己实现类似 JQ 的<code>on</code>和<code>trigger</code>了</p><p>实现的过程中用到了一个设计模式，也就是发布订阅模式，所以简单提一下</p><h4 id="简述发布订阅模式-观察者模式"><a href="#简述发布订阅模式-观察者模式" class="headerlink" title="简述发布订阅模式(观察者模式)"></a>简述发布订阅模式(观察者模式)</h4><p>发布订阅模式(publish-subscribe pattern)，又叫观察者模式(observer pattern)，定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知</p><p>来看一个比较挫的例子</p><pre><code class="js">小李辛辛苦苦做了两年程序猿，攒了些钱，内心激动，要去售楼部买一个心仪已久的房型到售楼部问了下，售楼部说暂时没有这种房型的房源了，怎么办呢，下次再来吧但是小李不知道这种房型什么时候有房源，总不能每天打电话到售楼部问吧，小李就把电话和房型信息留到售楼部了，什么时候有这种房源了，售楼部会短信通知要知道，售楼部不会只通知小李一个人，售楼部会把预留信息所有房型信息一致的人都通知一遍在这个比较挫的例子中，小李包括每个买房的人都是订阅者，而售楼部就是发布者</code></pre><p>其实我们都用过发布订阅模式，比如我们在 DOM 节点上绑定一个事件函数，就已经使用了</p><pre><code class="js">document.body.addEventListener(&quot;click&quot;, function() {  console.log(1)})</code></pre><p>但是这只是对发布订阅模式最简单的使用，在很多场景下我们经常会实现一些自定义事件来满足我们的需求</p><p>比如我们下面要防照 JQ 那种来写一个自定义事件监听器，需要监听一个事件，在该事件触发时执行其监听回调</p><h4 id="发布订阅模式实现事件监听器"><a href="#发布订阅模式实现事件监听器" class="headerlink" title="发布订阅模式实现事件监听器"></a>发布订阅模式实现事件监听器</h4><p>发布订阅模式有很多种实现方式，下面我们用<code>class</code>来简单实现下</p><pre><code class="js">class Emitter {  constructor() {    // _listener数组，key为自定义事件名，value为执行回调数组-因为可能有多个    this._listener = []  }  // 订阅 监听事件  on(type, fn) {    // 判断_listener数组中是否存在该事件命    // 存在将回调push到事件名对应的value数组中，不存在直接新增    this._listener[type]      ? this._listener[type].push(fn)      : (this._listener[type] = [fn])  }  // 发布 触发事件  trigger(type, ...rest) {    // 判断该触发事件是否存在    if (!this._listener[type]) return    // 遍历执行该事件回调数组并传递参数    this._listener[type].forEach(callback =&gt; callback(...rest))  }}</code></pre><p>如上所示，我们创建了一个<code>Emitter</code>类，并且添加了两个原型方法<code>on</code>和<code>trigger</code>，上面代码中均有注释，所以不过多解释了，基础不好的同学多看几遍自己敲一下，比较简单</p><p>使用时</p><pre><code class="js">// 创建一个emitter实例const emitter = new Emitter()emitter.on(&quot;done&quot;, function(arg1, arg2) {  console.log(arg1, arg2)})emitter.on(&quot;done&quot;, function(arg1, arg2) {  console.log(arg2, arg1)})function fn1() {  console.log(&quot;我是主程序&quot;)  setTimeout(() =&gt; {    emitter.trigger(&quot;done&quot;, &quot;异步参数一&quot;, &quot;异步参数二&quot;)  }, 1000)}fn1()</code></pre><p>如上所示，我们先创建一个 emitter 实例，接着注册事件，再触发事件，用法和上面 JQ 雷同，均解决了异步问题</p><p>Vue 的实现就是一个比较复杂的发布订阅模式，使用 Vue 的同学，上面的这个事件监听器，把<code>trigger</code>名字改成<code>emit</code>是不是就眼熟多了，当然我们这个比较简单，毕竟代码就那么六七行，不过理是这么个理</p><h3 id="事件监听优-缺"><a href="#事件监听优-缺" class="headerlink" title="事件监听优/缺"></a>事件监听优/缺</h3><p><strong>优点</strong></p><p>发布订阅模式实现的事件监听，我们可以绑定多个事件，每个事件也可以指定多个回调函数，还是比较符合模块化思想的，我们自写监听器时可以做很多优化从而更好的监控程序运行</p><p><strong>缺点</strong></p><p>整个程序变成了事件驱动，流程上来说或多或少都会有点影响，每次使用还得注册事件监听再进行触发挺麻烦的，代码也不太优雅，并不是事件驱动不好，毕竟需求只是 <strong>解决异步问题</strong> 而已，何况有更优解</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="Promise-简述"><a href="#Promise-简述" class="headerlink" title="Promise 简述"></a>Promise 简述</h3><p>ES2015 (ES6)标准化和引入了 Promise 对象，它是异步编程的一种解决方案</p><p>简单来说就是用同步的方式写异步的代码，可用来解决回调问题</p><h3 id="Promise-特点"><a href="#Promise-特点" class="headerlink" title="Promise 特点"></a>Promise 特点</h3><h4 id="特点一"><a href="#特点一" class="headerlink" title="特点一"></a>特点一</h4><p>Promise，承诺执行，Promise 对象的状态是不受外界影响的</p><p>Promise 对象代表一个异步操作，它有三种状态</p><ul><li><p>进行中 (Pending)</p></li><li><p>已完成 (Resolved/Fulfilled)</p></li><li><p>已失败 (Rejected)</p></li></ul><p>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态</p><p>这就是 Promise 这个名字的由来，它的英语意思就是<code>承诺</code>，表示其他手段无法改变</p><h4 id="特点二"><a href="#特点二" class="headerlink" title="特点二"></a>特点二</h4><p>Promise 对象状态一旦改变，就不会再变</p><p>Promise 对象的状态改变，只有两种可能</p><ul><li><p>从 Pending 变为 Resolved</p></li><li><p>从 Pending 变为 Rejected</p></li></ul><p>只要这两种情况发生，状态就凝固，不会再变了，会一直保持这个结果</p><h3 id="Promise-使用"><a href="#Promise-使用" class="headerlink" title="Promise 使用"></a>Promise 使用</h3><p>Promise 是一个构造函数，我们可以通过<code>new</code>关键字来创建一个 Promise 实例，也可以直接使用 Promise 的一些静态方法</p><h4 id="new-一个-Promise-实例"><a href="#new-一个-Promise-实例" class="headerlink" title="new 一个 Promise 实例"></a>new 一个 Promise 实例</h4><p><strong>语法</strong></p><pre><code class="js">new Promise( function(resolve, reject) {...});</code></pre><p><strong>示例</strong></p><pre><code class="js">function fn1() {  return new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {      let num = Math.ceil(Math.random() * 10)      if (num &lt; 5) {        resolve(num)      } else {        reject(&quot;数字太大&quot;)      }    }, 2000)  })}</code></pre><p>如上所示，我们使用<code>new</code>关键字创建了一个 promise 实例，并在函数 fn1 中<code>return</code>了出来</p><p><code>new Promise</code>创建了一个 promise 实例，Promise 构造函数会把一个叫做处理器函数(executor function)的函数作为它的参数</p><p>处理器函数接收两个参数分别是<code>resolve</code>和<code>reject</code>，这两个参数也是两个回调函数</p><p><code>resolve</code> 函数在异步操作成功时调用，并将异步操作的结果，作为参数传递出去</p><p><code>reject</code> 函数在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去</p><p>简单理解就是一个是成功回调，一个是失败回调</p><h4 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h4><p>Promise 对象有一个原型方法<code>then</code></p><p>Promise 实例生成以后，可以用<code>then</code>方法指定<code>resolved</code>状态和<code>reject</code>状态的回调函数</p><pre><code class="js">Promise.prototype.then(onFulfilled[, onRejected])</code></pre><p><code>then</code>方法接收两个回调 onFulfilled 和 onRejected</p><ul><li><p>onFulfilled-可选</p><ul><li>当 Promise 变成已完成状态(fulfilled)时调用的回调函数</li><li>该函数有一个参数，即接受的最终结果(the fulfillment value)</li><li>如果该参数不是函数，则会在内部被替换为 <code>(x) =&gt; x</code>，即原样返回 promise 最终结果的函数</li></ul></li><li><p>onRejected-可选</p><ul><li>当 Promise 变成接受状态或拒绝状态(rejected)时调用的回调函数</li><li>该函数有一个参数，即拒绝的原因(rejection reason)</li><li>如果该参数不是函数，则会在内部被替换为一个 <code>Thrower</code> 函数(it throws an error it received as argument)</li></ul></li></ul><p><code>then</code>方法在接收一个 promise 实例后会返回一个新的 Promise 实例(并不是原来那个 Promise 实例)，且原来的 promise 实例的返回值将作为参数传入这个新 Promise 的<code>resolve</code>函数</p><p>那么既然<code>then</code>方法返回一个新的 promise 实例，所以我们可以接着使用<code>then</code>方法，即链式调用，也被称为 <strong>复合(composition)</strong>操作</p><p>接上面的示例，函数 fn1 会返回一个 promise 实例</p><pre><code class="js">fn1().then(  data =&gt; {    console.log(data)  },  err =&gt; {    console.log(err)  })</code></pre><p>如上所示，我们使用了<code>then</code>方法的两个参数</p><p>第一个参数回调我们很常用，其实就是 Promise 变成已完成状态且拿到传递的值</p><p>第二个参数回调就是 Promise 变成接受状态或拒绝状态且拿到错误参数，我们可能用的少，一般都是用<code>catch</code>方法，<code>then</code>方法的第二个参数 onRejected 和<code>catch</code>还是有一些细微区别的，下面会提到</p><p>根据 Promises/A+中对<code>then</code>方法的定义，我们来看<code>then</code>方法的特点</p><p><strong>首先<code>then</code> 方法必须返回一个 <code>promise</code> 对象(划重点)</strong></p><p>链式调用的原理，不论是何种情况 then 方法都会返回一个新的 Promise 对象，这样才会有下个 then 方法</p><p><strong>如果<code>then</code>方法中返回的是一个普通值(如 Number、String 等)就使用此值包装成一个新的 Promise 对象返回</strong></p><p>就像下面这个例子，<code>then</code>方法接收 Promise 对象，<code>then</code>方法中返回一个普通值时，下一个<code>then</code>中是可以接到的</p><pre><code class="js">let p = new Promise((resolve, reject) =&gt; {  resolve(1)})p.then(data =&gt; {  return 2 // 返回了一个普通值}).then(data =&gt; {  console.log(data) // 2})</code></pre><p><strong>如果<code>then</code>方法中没有<code>return</code>语句，就返回一个用 Undefined 包装的 Promise 对象</strong></p><p>如下面例子的输出结果</p><pre><code class="js">let p = new Promise((resolve, reject) =&gt; {  resolve(1)})p.then(data =&gt; {  // 无return语句}).then(data =&gt; {  console.log(data) // undefined})</code></pre><p><strong>如果<code>then</code>方法中出现异常，则调用失败态方法(reject)跳转到下一个<code>then</code>的 onRejected</strong></p><p><code>then</code>方法的第二个参数 onRejected 是监测不到当前<code>then</code>方法回调异常的，规范中定义当前<code>then</code>方法出现异常则调用失败态方法(reject)流转到下一个<code>then</code>的 onRejected</p><pre><code class="js">let p = new Promise((resolve, reject) =&gt; {  resolve(1)})p.then(data =&gt; 2)  .then(    data =&gt; {      throw &quot;this is err&quot;    },    err =&gt; {      console.log(&quot;err1:&quot; + err)    }  )  .then(    data =&gt; {      console.log(data)    },    err =&gt; {      console.log(&quot;err2:&quot; + err) // err2:this is err    }  )</code></pre><p><strong>如果<code>then</code>方法没有传入任何回调，则继续向下传递(即所谓的值穿透)</strong></p><p>下面示例，在第一个<code>then</code>方法之后连续调用了两个空的<code>then</code>方法 ，没有传入任何回调函数，也没有返回值，此时 Promise 会将值一直向下传递，直到接收处理，这就是所谓的值穿透</p><pre><code class="js">let p = new Promise((resolve, reject) =&gt; {  resolve(1)})p.then(data =&gt; 2)  .then()  .then()  .then(data =&gt; {    console.log(data) // 2  })</code></pre><p><strong>如果<code>then</code>方法中返回了一个 Promise 对象，那就以这个对象为准，返回它的结果</strong></p><p>话不多说，来看示例</p><pre><code class="js">let p = new Promise((resolve, reject) =&gt; {  resolve(1)})p.then(data =&gt; {  return new Promise((resolve, reject) =&gt; {    resolve(2)  })}).then(data =&gt; {  console.log(data) // 2})</code></pre><h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h4><p>除了原型方法<code>then</code>之外，Promise 对象还有一个<code>catch</code>的原型方法</p><p><code>catch</code>方法可以用于 promise 组合中的错误处理，此方法返回一个 Promise，并且处理拒绝的情况</p><pre><code class="js">p.catch(onRejected)p.catch(function(reason) {  // 拒绝})</code></pre><ul><li>onRejected<ul><li>当 Promise 被 rejected 时，被调用的一个回调函数，该函数拥有一个参数为失败原因或错误信息</li></ul></li></ul><p>简单理解就是捕获异常，promise 组合中抛出了错误或 promise 组合中出现 rejected 会被捕获</p><p>同样接最上面的示例，还使用 fn1 函数</p><pre><code class="js">fn1()  .then(data =&gt; {    console.log(data)  })  .catch(err =&gt; {    console.log(err)  })</code></pre><p>使用这种方式捕获错误或失败是不是比<code>then</code>方法的第二个参数看着舒服了点呢，毕竟 Promise 就是链式到底</p><p>同样也需要注意一点，<code>catch</code>方法也返回一个新的 promise 实例，如果 <code>onRejected</code>回调抛出一个错误或返回一个本身失败的 Promise ，通过 <code>catch</code> 返回的 Promise 会被 rejected，否则，它就是一个成功的(resolved)promise 实例</p><p>和上面的<code>then</code>方法中的第二个参数几乎是一致的，我们看例子</p><pre><code class="js">fn1()  .catch(err =&gt; {    console.log(err)    return err  })  .then(data =&gt; {    console.log(data)  })  .catch(err =&gt; {    console.log(err)  })</code></pre><p>上面的 fn1 函数有一半的几率返回一个 rejected，当返回一个 rejected 时下面的<code>then</code>方法回调中同样会输出，因为我们在第一个<code>catch</code>中只 return 了错误信息，并没有抛出错误或者返回一个失败 promise，所以第一个<code>catch</code>执行返回的 promise 对象是 resolveing</p><h4 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h4><p>finally，英文是<code>最后</code>的意思，此方法是<code>ES2018</code>的标准</p><p>原型方法<code>finally</code>，我们使用的可能不多，语法如下</p><pre><code class="js">p.finally(onFinally)p.finally(function() {  // 返回状态为(resolved 或 rejected)})</code></pre><p>一句话即可解释<code>finally</code>，在 promise 结束时，不管成功还是失败都将执行其<code>onFinally</code>回调，该回调无参数</p><p>适用于同样的语句需要在<code>then()</code>和<code>catch()</code>中各写一次的情况</p><h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h4><p>一句话概括 Promise.resolve()方法，接收一个值，将现有对象转为 Promise 对象</p><pre><code class="js">Promise.resolve(value)</code></pre><p>如下所示，该值可为任意类型，也可是一个 Promise 对象</p><pre><code class="js">const p = Promise.resolve(123)Promise.resolve(p).then(value =&gt; {  console.log(value) // 123})</code></pre><h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h4><p><code>Promise.reject()</code>方法同上面<code>Promise.resolve()</code>一样，只不过是返回一个带有拒绝原因的<code>Promise</code>对象</p><pre><code class="js">Promise.reject(123)  .then(data =&gt; {    console.log(data)  })  .catch(err =&gt; {    console.log(&quot;err:&quot; + err)  })// err:123</code></pre><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h4><p><code>Promise.all(iterable)</code>用于将多个 Promise 实例包装成一个新的 Promise 实例，参数为一组 Promise 实例组成的数组</p><p>iterable 类型为 ES6 标准引入，代表可迭代对象，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型 ，iterable 下面我们会讲到，这里我们就先把这个参数理解成数组就可以，稍后配合下面的 iterable 来理解</p><pre><code class="js">let p1 = Promise.resolve(1)let p2 = Promise.resolve(2)let p3 = Promise.resolve(3)let p = Promise.all([p1, p2, p3])p.then(data =&gt; {  console.log(data) // [1,2,3]})</code></pre><p>如上所示，当 p1, p2, p3 状态都 Resolved 的时候，p 的状态才会 Resolved</p><p>只要有一个实例 Rejected ，此时第一个被 Rejected 的实例返回值就会传递给 P 的回调函数</p><pre><code class="js">let p1 = Promise.resolve(1)let p2 = Promise.resolve(2)let p3 = Promise.reject(3)let p = Promise.all([p1, p2, p3])p.then(data =&gt; {  console.log(data)}).catch(err =&gt; {  console.log(&quot;err:&quot; + err) // 3})</code></pre><p>应用场景在我们有一个接口，需要其他两个或多个接口返回的数据作为参数时会多一些</p><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h4><p><code>Promise.race(iterable)</code>和上面<code>Promise.all(iterable)</code>类似</p><p><code>all</code>方法是迭代对象中状态全部改变才会执行</p><p><code>race</code>方法正好相反，只要迭代对象中有一个状态改变了，它的状态就跟着改变，并将那个改变状态实例的返回值传递给回调函数</p><pre><code class="js">const p1 = new Promise((resolve, reject) =&gt; {  setTimeout(resolve, 1000, &quot;1&quot;)})const p2 = new Promise((resolve, reject) =&gt; {  setTimeout(resolve, 500, &quot;2&quot;)})Promise.race([p1, p2]).then(value =&gt; {  console.log(value) // 2})</code></pre><h4 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h4><p>开发中，经常遇到一种情况：不知道或不想区分，函数 fn 是同步函数还是异步函数，但想用 Promise 来处理它</p><p>因为这样就可以不管 fn 是不是异步操作，都用 then 方法指定下一步流程，用 catch 方法处理 fn 抛出的错误</p><p>我们可能会使用<code>Promise.resolve</code>把它转换成 Promise 对象</p><pre><code class="js">let fn = () =&gt; console.log(&quot;fn&quot;)Promise.resolve(fn).then(cb =&gt; cb())console.log(&quot;hahaha&quot;)// hahaha// fn</code></pre><p>但是这样有一个问题，如果函数 fn 是同步的，那么这波操作会把它转成异步，如上输出</p><p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？当然可以</p><p>我们可以这样</p><pre><code class="js">const fn = () =&gt; console.log(&quot;fn&quot;);(() =&gt; new Promise(resolve =&gt; resolve(fn())))()  .then(() =&gt; {    console.log(222)  })  .catch(err =&gt; {    console.log(err)  })console.log(&quot;111&quot;)// fn// 111// 222</code></pre><p>也可以这样</p><pre><code class="js">const fn = () =&gt; console.log(&quot;fn&quot;);(async () =&gt; fn())()  .then(() =&gt; {    console.log(222)  })  .catch(err =&gt; {    console.log(err)  })console.log(&quot;111&quot;)// fn// 111// 222</code></pre><p>但是，代码有点诡异，不优雅</p><p>来看使用<code>try</code>方法</p><pre><code class="js">const fn = () =&gt; console.log(&quot;fn&quot;)Promise.try(fn)  .then(() =&gt; {    console.log(222)  })  .catch(err =&gt; {    console.log(err)  })console.log(&quot;111&quot;)// fn// 111// 222</code></pre><p>如上所示，简洁明了，还是很实用的</p><p>其实，<code>Promise.try</code>就是模拟 try 代码块，就像<code>promise.catch</code>模拟的是 catch 代码块</p><p>最后 <code>Promise.try</code> 并不是 Javascript 的一部分</p><p>早在 16 年有过这个提案，有兴趣的同学可以了解下，现在也没下文了，并没有被纳入标准</p><p>如果想要使用的话，需要使用 Promise 库 Bluebird、Q 等，或引入 Polyfill</p><p>虽然没有被纳入标准，但并不代表它不好用，大家自行体验</p><p>想要了解更多此方法推荐大家看参考链接【4】【5】</p><h4 id="onRejected-和-catch-区别"><a href="#onRejected-和-catch-区别" class="headerlink" title="onRejected 和 catch 区别"></a>onRejected 和 catch 区别</h4><p>上面提到了<code>promise.then(onFulfilled, onRejected)</code>中的第二个参数 onRejected 和<code>catch</code></p><p>看到这大家可能会问，同样都是捕获异常它们的区别在哪</p><p>其实<code>promise.then(onFulfilled, onRejected)</code> 在 <code>onFulfilled</code>回调中发生异常的话，在<code>onRejected</code>中是捕获不到这个异常的，使用<code>catch</code>可以捕获到前面的 onFulfilled 的异常</p><p>其实这不算个缺点，我们完全可以在末尾多加一个<code>then</code>从而达到和<code>catch</code>相同的作用，如下</p><pre><code class="js">Promise.reject(1)  .then(() =&gt; {    console.log(&quot;我是对的&quot;)  })  .then(null, err =&gt; {    console.log(&quot;err:&quot; + err) // err:1  })// 等价于Promise.reject(1)  .then(() =&gt; {    console.log(&quot;我是对的&quot;)  })  .catch(err =&gt; {    console.log(&quot;err:&quot; + err) // err:1  })</code></pre><p>就这么点区别，不过大部分人都喜欢直接使用<code>catch</code>罢了</p><h4 id="then-中抛错未处理"><a href="#then-中抛错未处理" class="headerlink" title="then 中抛错未处理"></a>then 中抛错未处理</h4><p>如果在 then 中抛错，而没有对错误进行处理(catch)，那么会一直保持 reject 状态，直到 catch 了错误</p><p>我们来看一段代码</p><pre><code class="js">Promise.resolve()  .then(() =&gt; {    console.log(a)    console.log(&quot;Task 1&quot;)  })  .then(() =&gt; {    console.log(&quot;Task 2&quot;)  })  .catch(err =&gt; {    console.log(&quot;err:&quot; + err)  })  .then(() =&gt; {    console.log(&quot;finaltask&quot;)  })// err:ReferenceError: a is not defined// finaltask</code></pre><p>我们看上面代码，我们在第一个<code>then</code>中输出了一个未声明的变量</p><p>输出结果先走了<code>catch</code>然后走了最后一个<code>then</code>，第一个<code>then</code>中抛出错误并跳过了第二个<code>then</code></p><p>也就是说如果我们没有处理这个错误(无 catch)的话，就不会往下执行了</p><p>可参考下图</p><p><img src="/img/blog/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.assets/image-20200201231714043.png" srcset="/img/loading.gif" alt="image-20200201231714043"></p><p>promise 的缺点之一就是无法让 promise 中断，利用这个特性可以让 Promise 中断执行，也算一种办法吧</p><h4 id="异步回调中抛错-catch-捕捉不到"><a href="#异步回调中抛错-catch-捕捉不到" class="headerlink" title="异步回调中抛错 catch 捕捉不到"></a>异步回调中抛错 catch 捕捉不到</h4><p>首先我们看在 Promise 对象的处理器函数中直接抛出错误</p><pre><code class="js">const p = new Promise((resolve, reject) =&gt; {  throw new Error(&quot;这是一个错误&quot;)})p.catch(error =&gt; {  console.log(error)})</code></pre><p>按照上述内容来看，在 Promise 对象的处理器函数中直接抛出错误，<code>catch</code>是可以捕捉到的</p><p>在下面代码，在 Promise 对象的处理器函数中模拟一个异步抛错</p><pre><code class="js">const p = new Promise((resolve, reject) =&gt; {  setTimeout(() =&gt; {    throw new Error(&quot;这是一个错误&quot;)  }, 0)})p.catch(error =&gt; {  console.log(error)})</code></pre><p>这种情况<code>catch</code>是捕捉不到的，这是为什么呢？先想后看，再做不难</p><p><strong>原因</strong></p><p>JS 事件循环列表有宏任务与微任务之分，setTimeOut 是宏任务， promise 是微任务，执行顺序不同</p><p>那么这段代码的执行顺序是：</p><ol><li>代码执行栈进入 promise 触发 setTimeOut，setTimeOut 回调函数入宏任务队列</li><li>代码执行 promise 的 catch 方法，入微任务队列，此时 setTimeOut 回调还没有执行</li><li>执行栈检查发现当前微任务队列执行完毕，开始执行宏任务队列</li><li>执行<code>throw new Error(&#39;这是一个错误&#39;)</code> 此时这个异常其实是在 promise 外部抛出的</li></ol><p><strong>解决</strong></p><p>使用<code>try catch</code>捕获异常主动触发<code>reject</code></p><pre><code class="js">const p = new Promise((resolve, reject) =&gt; {  setTimeout(() =&gt; {    try {      throw new Error(&quot;这是一个错误&quot;)    } catch (e) {      reject(e)    }  }, 0)})p.catch(error =&gt; {  console.log(error)})</code></pre><h3 id="手写-Promise—符合-Promises-A-规范"><a href="#手写-Promise—符合-Promises-A-规范" class="headerlink" title="手写 Promise—符合 Promises/A+规范"></a>手写 Promise—符合 Promises/A+规范</h3><h4 id="为什么要手写-Promise"><a href="#为什么要手写-Promise" class="headerlink" title="为什么要手写 Promise"></a>为什么要手写 Promise</h4><p>Promise 源码逻辑相对来说不算简单，可能我们只会使用，并不清楚其原理</p><p>自己实现一遍会加深我们对 Promise 的理解，也可以加强我们 JS 的功底</p><p>更何况手写实现 Promise 是一道前端经典的面试题，此处必然不用多说</p><h4 id="Promises-A"><a href="#Promises-A" class="headerlink" title="Promises/A+"></a>Promises/A+</h4><p>了解了 Promise 的基础用法后，我们来一步步倒推实现 Promise</p><p>Promises/A+标准是一个开放、健全且通用的 JavaScript Promise 标准，由开发者制定，供开发者参考</p><p>很多 Promise 三方库都是按照 Promises/A+标准实现的</p><p>so，此次实现我们严格 Promises/A+标准，包括完成后我们会使用开源社区提供的测试包来测试</p><p>简单来说，测试通过的话，足以证明代码符合 Promises/A+标准，是合法的、完全可以上线提供给他人使用的</p><p>更多 Promises/A+标准请看参考链接【6】【7】</p><h4 id="构造方法核心基础搭建"><a href="#构造方法核心基础搭建" class="headerlink" title="构造方法核心基础搭建"></a>构造方法核心基础搭建</h4><p>Promise 的用法上面已经详细讲了，如果阅读仔细的话，我们会知道</p><ul><li>Promise 有三种状态进行中 (Pending)、已完成 (Resolved/Fulfilled)和已失败 (Rejected)</li><li>Promise 是一个构造方法，实例化 Promise 时传入一个函数作为处理器<ul><li>处理器函数有两个参数(resolve 和 reject)分别将结果变为成功态和失败态</li><li>Promise 对象执行成功了要有一个结果，通过 resolve 传递出去，失败的话失败原因通过 reject 传递出入</li></ul></li><li>Promise 的原型上定义着 then 方法</li></ul><p>那么根据我们上面的这些已知需求我们可以写出一个基础的结构(写法千千万，喜欢 class 也可以用 class)</p><pre><code class="js">function Promise(executor) {  // 状态描述 pending resolved rejected  this.state = &quot;pending&quot;  // 成功结果  this.value = undefined  // 失败原因  this.reason = undefined  function resolve(value) {}  function reject(reason) {}}Promise.prototype.then = function(onFulfilled, onRejected) {}</code></pre><p>如上所示，我们创建了一个 Promise 构造方法，<code>state</code>属性保存了 Promise 对象的状态，使用<code>value</code>属性保存 Promise 对象执行成功的结果，失败原因使用<code>reason</code>属性保存，这些命名完全贴合 Promises/A+标准</p><p>接着我们在构造函数中创建了<code>resolve</code>和<code>reject</code>两个方法，然后在构造函数的原型上创建了一个<code>then</code>方法，以备待用</p><h4 id="初始化实例-executor-立即执行"><a href="#初始化实例-executor-立即执行" class="headerlink" title="初始化实例 executor 立即执行"></a>初始化实例 executor 立即执行</h4><p>我们知道，在创建一个 Promise 实例时，处理器函数(executor)是会立即执行的，所以我们更改代码</p><pre><code class="js">function Promise(executor) {  this.state = &quot;pending&quot;  this.value = undefined  this.reason = undefined  // 让其处理器函数立即执行  try {    executor(resolve, reject)  } catch (err) {    reject(err)  }  function resolve(value) {}  function reject(reason) {}}</code></pre><h4 id="resolve-amp-reject-回调实现"><a href="#resolve-amp-reject-回调实现" class="headerlink" title="resolve&amp;reject 回调实现"></a>resolve&amp;reject 回调实现</h4><p>Promises/A+规范中规定，当 Promise 对象已经由 pending 状态改变为成功态(resolved)或失败态(rejected)后不可再次更改状态，也就是说成功或失败后状态不可更新已经凝固</p><p>因此我们更新状态时要判断，如果当前状态是 pending(等待态)才可更新，由此我们来完善<code>resolve</code>和<code>reject</code>方法</p><pre><code class="js">let _this = thisfunction resolve(value) {  if (_this.state === &quot;pending&quot;) {    _this.value = value    _this.state = &quot;resolved&quot;  }}function reject(reason) {  if (_this.state === &quot;pending&quot;) {    _this.reason = reason    _this.state = &quot;rejected&quot;  }}</code></pre><p>如上所示，首先我们在 Promise 构造函数内部用变量<code>_this</code>托管构造函数的<code>this</code></p><p>接着我们在<code>resolve</code>和<code>reject</code>函数中分别加入了判断，因为只有当前态是 pending 才可进行状态更改操作</p><p>同时将成功结果和失败原因都保存到对应的属性上</p><p>然后将 state 属性置为更新后的状态</p><h4 id="then-方法基础实现"><a href="#then-方法基础实现" class="headerlink" title="then 方法基础实现"></a>then 方法基础实现</h4><p>接着我们来简单实现<code>then</code>方法</p><p>首先<code>then</code>方法有两个回调，当 Promise 的状态发生改变，成功或失败会分别调用<code>then</code>方法的两个回调</p><p>所以，then 方法的实现看起来挺简单，根据 state 状态来调用不同的回调函数即可</p><pre><code class="js">Promise.prototype.then = function(onFulfilled, onRejected) {  if (this.state === &quot;resolved&quot;) {    if (typeof onFulfilled === &quot;function&quot;) {      onFulfilled(this.value)    }  }  if (this.state === &quot;rejected&quot;) {    if (typeof onRejected === &quot;function&quot;) {      onRejected(this.reason)    }  }}</code></pre><p>如上所示，由于<code>onFulfilled &amp; onRejected</code>两个参数都不是必选参，所以我们在判断状态后又判断了参数类型，当参数不为函数类型，就不执行，因为在 Promises/A+规范中定义非函数类型可忽略</p><h4 id="让-Promise-支持异步"><a href="#让-Promise-支持异步" class="headerlink" title="让 Promise 支持异步"></a>让 Promise 支持异步</h4><p>写到这里，我们可能会觉得，咦？Promise 实现起来也不难嘛，这么快就有模有样了，我们来简单测试下</p><pre><code class="js">let p = new Promise((resolve, reject) =&gt; {  resolve(1)})p.then(data =&gt; console.log(data)) // 1</code></pre><p>嗯，符合预期，再来试下异步代码</p><pre><code class="js">let p = new Promise((resolve, reject) =&gt; {  setTimeout(() =&gt; {    resolve(1);  }，1000);})p.then(data =&gt; console.log(data)) // 无输出</code></pre><p>问题来了，Promise 一个异步解决方案被我们写的不支持异步。。。</p><p>我们来分析下，本来是等 1000ms 后执行<code>then</code>方法，运行上面代码发现没有结果，哪里有问题呢？</p><p>setTimeout 函数让<code>resolve</code>变成了异步执行，有延迟，调用<code>then</code>方法的时候，此刻状态还是等待态(pending)，<code>then</code>方法即没有调用<code>onFulfilled</code>也没有调用<code>onRejected</code></p><p>嗯，清楚原因我们开始改造，如果是你，你会如何解决呢，此处可思考 40 秒，想一个可实施的大致思路</p><p><strong>小提示：</strong> 可以参考上文的发布订阅模式，如果 40 秒还没有思路，嗯，有待提高</p><p>|</p><p>|</p><p>–&gt;为了让您小小活动一下左脑并活跃下气氛，我也是煞费苦心(<strong>ps:</strong>都看到这了，不点个赞鼓励下就太没劲了噻 😄)</p><p>|</p><p>|</p><p>回归正题，我们来解决这个问题</p><p>我们可以参照发布订阅模式，在执行<code>then</code>方法时如果还在等待态(pending)，就把回调函数临时寄存到队列(就是一个数组)里，当状态发生改变时依次从数组中取出执行就好了</p><p>思路有了，我们来实现下</p><p>首先，我们要在构造方法中新增两个 Array 类型的数组，用于存放成功和失败的回调函数</p><pre><code class="js">function Promise(executor) {  let _this = this  this.state = &quot;pending&quot;  this.value = undefined  this.reason = undefined  // 保存成功回调  this.onResolvedCallbacks = []  // 保存失败回调  this.onRejectedCallbacks = []  // ...}</code></pre><p>我们还需要改善<code>then</code>方法，在<code>then</code>方法执行时如果状态是等待态，就将其回调函数存入对应数组</p><pre><code class="js">Promise.prototype.then = function(onFulfilled, onRejected) {  // 新增等待态判断，此时异步代码还未走完，回调入数组队列  if (this.state === &quot;pending&quot;) {    if (typeof onFulfilled === &quot;function&quot;) {      this.onResolvedCallbacks.push(onFulfilled)    }    if (typeof onRejected === &quot;function&quot;) {      this.onRejectedCallbacks.push(onRejected)    }  }  // 以下为之前代码块  if (this.state === &quot;resolved&quot;) {    if (typeof onFulfilled === &quot;function&quot;) {      onFulfilled(this.value)    }  }  if (this.state === &quot;rejected&quot;) {    if (typeof onRejected === &quot;function&quot;) {      onRejected(this.reason)    }  }}</code></pre><p>如上所示，我们改写<code>then</code>方法，除了判断成功态(resolved)、失败态(rejected)，我们又加了一个等待态(pending)判断，当状态为等待态时，异步代码还没有走完，那么我们把对应的回调先存入准备好的数组中即可</p><p>最那么，就差最后一步执行了，我们在<code>resolve</code>和<code>reject</code>方法中调用即可</p><pre><code class="js">function resolve(value) {  if (_this.state === &quot;pending&quot;) {    _this.value = value    // 遍历执行成功回调    _this.onResolvedCallbacks.forEach(cb =&gt; cb(value))    _this.state = &quot;resolved&quot;  }}function reject(reason) {  if (_this.state === &quot;pending&quot;) {    _this.reason = reason    // 遍历执行失败回调    _this.onRejectedCallbacks.forEach(cb =&gt; cb(reason))    _this.state = &quot;rejected&quot;  }}</code></pre><p>到了这里，我们已经实现了 Promise 的异步解决，赶快测试下</p><h4 id="实现-Promise-经典的链式调用"><a href="#实现-Promise-经典的链式调用" class="headerlink" title="实现 Promise 经典的链式调用"></a>实现 Promise 经典的链式调用</h4><p>Promise 的<code>then</code>方法可以链式调用，这也是 Promise 的精华之一，在实现起来也算是比较复杂的地方了</p><p>首先我们要理清楚<code>then</code>的需求是什么，这需要仔细看 Promises/A+规范中对<code>then</code>方法的返回值定义及 Promise 解决过程，当然你如果仔细阅读了上文<code>then</code>方法的使用大概也清楚了，我们在这里再次总结下</p><ul><li><p><strong>首先<code>then</code> 方法必须返回一个 <code>promise</code> 对象(划重点)</strong></p></li><li><p><strong>如果<code>then</code>方法中返回的是一个普通值(如 Number、String 等)就使用此值包装成一个新的 Promise 对象返回</strong></p></li><li><p><strong>如果<code>then</code>方法中没有<code>return</code>语句，就返回一个用 Undefined 包装的 Promise 对象</strong></p></li><li><p><strong>如果<code>then</code>方法中出现异常，则调用失败态方法(reject)跳转到下一个<code>then</code>的 onRejected</strong></p></li><li><p><strong>如果<code>then</code>方法没有传入任何回调，则继续向下传递(值穿透)</strong></p></li><li><p><strong>如果<code>then</code>方法中返回了一个 Promise 对象，那就以这个对象为准，返回它的结果</strong></p></li></ul><p>嗯，到此我们需求已经明确，开始代码实现</p><p>需求中说如果<code>then</code>方法没有传入任何回调，则继续向下传递，但是每个<code>then</code>中又返回一个新的 Promise，也就是说当<code>then</code>方法中没有回调时，我们需要把接收到的值继续向下传递，这个其实好办，只需要在判断回调参数不为函数时我们把他变成回调函数返回普通值即可</p><pre><code class="js">Promise.prototype.then = function(onFulfilled, onRejected) {  onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : value =&gt; value  onRejected =    typeof onRejected === &quot;function&quot;      ? onRejected      : err =&gt; {          throw err        }  // ...}</code></pre><p>我们上面<code>then</code>实现中，在每个可执行处都加了参数是否为函数的类型校验，但是我们这里在<code>then</code>方法开头统一做了校验，就不需要参数校验了</p><p>现在的<code>then</code>方法变成了</p><pre><code class="js">Promise.prototype.then = function(onFulfilled, onRejected) {  onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : value =&gt; value  onRejected =    typeof onRejected === &quot;function&quot;      ? onRejected      : err =&gt; {          throw err        }  if (this.state === &quot;pending&quot;) {    this.onResolvedCallbacks.push(onFulfilled)    this.onRejectedCallbacks.push(onRejected)  }  if (this.state === &quot;resolved&quot;) {    onFulfilled(this.value)  }  if (this.state === &quot;rejected&quot;) {    onRejected(this.reason)  }}</code></pre><p>接着来</p><p>既然每个<code>thne</code>都反回一个新的 Promise，那么我们就先在<code>then</code>中创建一个 Promise 实例返回，开始改造</p><pre><code class="js">Promise.prototype.then = function(onFulfilled, onRejected) {  onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : value =&gt; value  onRejected =    typeof onRejected === &quot;function&quot;      ? onRejected      : err =&gt; {          throw err        }  let promise2 = new Promise((resolve, reject) =&gt; {    if (this.state === &quot;pending&quot;) {      this.onResolvedCallbacks.push(onFulfilled)      this.onRejectedCallbacks.push(onRejected)    }    if (this.state === &quot;resolved&quot;) {      onFulfilled(this.value)    }    if (this.state === &quot;rejected&quot;) {      onRejected(this.reason)    }  })  return promise2}</code></pre><p>我们在<code>then</code>方法中先实例化了一个 Promise 对象并返回，我们把原来写的代码放到该实例的处理器函数中</p><p>我们把原来写的代码放到该实例的处理器函数中</p><p>接着在每个执行函数处使用<code>try..catch</code>语法，try 中<code>resolve</code>执行结果，catch 中<code>reject</code>异常，原来的<code>then</code>方法中有 resolved、rejected 和 pending 三种逻辑判断，如下</p><p>在 resolved 状态判断时，rejected 和 resolved 逻辑一致</p><pre><code class="js">if (this.state === &quot;resolved&quot;) {  try {    // 拿到返回值resolve出去    let x = onFulfilled(this.value)    resolve(x)  } catch (e) {    // catch捕获异常reject抛出    reject(e)  }}</code></pre><p>pending 状态判断，逻辑也和 resolved 相似，但是由于此处为了处理异步，我们在这里做了 push 操作，所以我们 push 时在 onFulfilled 和 onRejected 回调外面再套一个回调做操作即可，都是 JS 惯用小套路，不过分解释</p><pre><code class="js">if (this.state === &quot;pending&quot;) {  // push(onFulfilled)  // push(()=&gt;{ onFulfilled() })  // 上面两种执行效果一致，后者可在回调中加一些其他功能，如下  this.onResolvedCallbacks.push(() =&gt; {    try {      let x = onFulfilled(this.value)      resolve(x)    } catch (e) {      reject(e)    }  })  this.onRejectedCallbacks.push(() =&gt; {    try {      let x = onRejected(this.value)      resolve(x)    } catch (e) {      reject(e)    }  })}</code></pre><p>再接下来我们开始处理根据上一个<code>then</code>方法的返回值来生成新 Promise 对象，这块逻辑复杂些，规范中可以抽离出一个方法来做这件事，我们来照做</p><pre><code class="js">/** * 解析then返回值与新Promise对象 * @param {Object} 新的Promise对象，就是我们创建的promise2实例 * @param {*} x 上一个then的返回值 * @param {Function} resolve promise2处理器函数的resolve * @param {Function} reject promise2处理器函数的reject */function resolvePromise(promise2, x, resolve, reject) {  // ...}</code></pre><p>我们来一步步分析完善 resolvePromise 函数</p><p><strong>避免循环引用，当 then 的返回值与新生成的 Promise 对象为同一个(引用地址相同)，则抛出 TypeError 错误</strong></p><p>例：</p><pre><code class="js">let promise2 = p.then(data =&gt; {  return promise2})// TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</code></pre><p>如果返回了自己的 Promise 对象，状态永远为等待态(pending)，再也无法成为 resolved 或是 rejected，程序就死掉了，因此要先处理它</p><pre><code class="js">function resolvePromise(promise2, x, resolve, reject) {  if (promise2 === x) {    reject(new TypeError(&quot;请避免Promise循环引用&quot;))  }}</code></pre><p><strong>判断 x 类型，分情况处理</strong></p><p>当 x 是一个 Promise，就执行它，成功即成功，失败即失败，如果<code>x</code>是一个对象或是函数，再进一步处理它，否则就是一个普通值</p><pre><code class="js">function resolvePromise(promise2, x, resolve, reject) {  if (promise2 === x) {    reject(new TypeError(&quot;请避免Promise循环引用&quot;))  }  if (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;)) {    // 可能是个对象或是函数  } else {    // 是个普通值    resolve(x)  }}</code></pre><p>如果 x 是个对象，尝试将对象上的 then 方法取出来，此时如果报错，那就将 promise2 转为失败态</p><p>在这里 catch 防止报错是因为 Promise 有很多实现，假设另一个人实现的 Promise 对象使用<code>Object.defineProperty()</code>在取值时抛错，我们可以防止代码出现 bug</p><pre><code class="js">// resolvePromise方法内部片段if (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;)) {  // 可能是个对象或是函数  try {    // 尝试取出then方法引用    let then = x.then  } catch (e) {    reject(e)  }} else {  // 是个普通值  resolve(x)}</code></pre><p>如果对象中有<code>then</code>，且<code>then</code>是函数类型，就可以认为是一个 Promise 对象，之后，使用<code>x</code>作为其 this 来调用执行<code>then</code>方法</p><pre><code class="js">// resolvePromise方法内部片段if (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;)) {  // 可能是个对象或是函数  try {    // 尝试取出then方法引用    let then = x.then    if (typeof then === &quot;function&quot;) {      // then是function，那么执行Promise      then.call(        x,        y =&gt; {          resolve(y)        },        r =&gt; {          reject(r)        }      )    } else {      resolve(x)    }  } catch (e) {    reject(e)  }} else {  // 是个普通值  resolve(x)}</code></pre><p>此时，我们还要考虑到一种情况，如果 Promise 对象转为成功态或是失败时传入的还是一个 Promise 对象，此时应该继续执行，直到最后的 Promise 执行完，例如下面这种</p><pre><code class="js">Promise.resolve(1).then(data =&gt; {  return new Promise((resolve, reject) =&gt; {    // resolve传入的还是Promise    resolve(      new Promise((resolve, reject) =&gt; {        resolve(2)      })    )  })})</code></pre><p>解决这种情况，我们可以采用递归，把调用 resolve 改写成递归执行 resolvePromise，这样直到解析 Promise 成一个普通值才会终止</p><pre><code class="js">// resolvePromise方法内部片段if (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;)) {  // 可能是个对象或是函数  try {    let then = x.then    if (typeof then === &quot;function&quot;) {      then.call(        x,        y =&gt; {          // 递归调用，传入y若是Promise对象，继续循环          resolvePromise(promise2, y, resolve, reject)        },        r =&gt; {          reject(r)        }      )    } else {      resolve(x)    }  } catch (e) {    reject(e)  }} else {  // 普通值结束递归  resolve(x)}</code></pre><p>规范中定义，如果 resolvePromise 和 rejectPromise 都被调用，或者多次调用同一个参数，第一个调用优先，任何进一步的调用都将被忽略，为了让成功和失败只能调用一个，我们接着完善，设定一个 called 来防止多次调用</p><pre><code class="js">// resolvePromise方法内部片段let calledif (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;)) {  // 可能是个对象或是函数  try {    let then = x.then    if (typeof then === &quot;function&quot;) {      then.call(        x,        y =&gt; {          if (called) return          called = true          // 递归调用，传入y若是Promise对象，继续循环          resolvePromise(promise2, y, resolve, reject)        },        r =&gt; {          if (called) return          called = true          reject(r)        }      )    } else {      resolve(x)    }  } catch (e) {    if (called) return    called = true    reject(e)  }} else {  // 普通值结束递归  resolve(x)}</code></pre><p>到此，我们算是实现好了<code>resolvePromise</code>方法，我们来调用它实现完整的<code>then</code>方法，在原来的原型方法<code>then</code>中我们<code>return</code>了一个 promise2，这个实例处理器函数的三种状态判断中把<code>resolve</code>处替换成<code>resolvePromise</code>方法即可</p><p>那么，此时<code>then</code>方法实现完成了吗？</p><p>当然还没有，我们都知道，Promise 中处理器函数是同步执行，而<code>then</code>方法是异步，但是我们完成这个还是同步</p><p>解决这个问题其实也很简单，仿照市面上大多数 Promise 库的做法，使用 setTimeout 模拟，我们在<code>then</code>方法内执行处的所有地方使用 setTimeout 变为异步即可(只是这样做和浏览器自带的 Promises 唯一的区别就是浏览器的 Promise..then 是微任务，我们用 setTimeout 实现是宏任务)，不过这也是大多数 Promise 库的做法，如下</p><pre><code class="js">setTimeout(() =&gt; {  try {    let x = onFulfilled(value)    resolvePromise(promise2, x, resolve, reject)  } catch (e) {    reject(e)  }}, 0)</code></pre><p>现在我们的终极版<code>then</code>方法就大功告成了</p><pre><code class="js">Promise.prototype.then = function(onFulfilled, onRejected) {  onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : value =&gt; value  onRejected =    typeof onRejected === &quot;function&quot;      ? onRejected      : err =&gt; {          throw err        }  let promise2 = new Promise((resolve, reject) =&gt; {    // 等待态判断，此时异步代码还未走完，回调入数组队列    if (this.state === &quot;pending&quot;) {      this.onResolvedCallbacks.push(() =&gt; {        setTimeout(() =&gt; {          try {            let x = onFulfilled(this.value)            resolvePromise(promise2, x, resolve, reject)          } catch (e) {            reject(e)          }        }, 0)      })      this.onRejectedCallbacks.push(() =&gt; {        setTimeout(() =&gt; {          try {            let x = onRejected(this.value)            resolvePromise(promise2, x, resolve, reject)          } catch (e) {            reject(e)          }        }, 0)      })    }    if (this.state === &quot;resolved&quot;) {      setTimeout(() =&gt; {        try {          let x = onFulfilled(this.value)          resolvePromise(promise2, x, resolve, reject)        } catch (e) {          reject(e)        }      }, 0)    }    if (this.state === &quot;rejected&quot;) {      setTimeout(() =&gt; {        try {          let x = onRejected(this.reason)          resolvePromise(promise2, x, resolve, reject)        } catch (e) {          reject(e)        }      }, 0)    }  })  return promise2}</code></pre><h4 id="catch-实现"><a href="#catch-实现" class="headerlink" title="catch 实现"></a>catch 实现</h4><p>实现了最复杂的<code>then</code>方法后，<code>catch</code>实现非常简单，一看就懂了</p><pre><code class="js">Promise.prototype.catch = function(onRejected) {  return this.then(null, onRejected)}</code></pre><h4 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h4><p>开源社区提供了一个包用于测试我们的代码是否符合 Promises/A+规范：<code>promises-aplus-tests</code></p><p>首先我们要为该测试包提供一个<code>deferred</code>钩子，用于测试</p><p>如下，将下面代码防止我们的<code>Promise.js</code>文件末尾即可</p><pre><code class="js">// promises-aplus-tests测试Promise.defer = Promise.deferred = function() {  let defer = {}  defer.promise = new Promise((resolve, reject) =&gt; {    defer.resolve = resolve    defer.reject = reject  })  return defer}try {  module.exports = Promise} catch (e) {}</code></pre><p>接着，安装这个包</p><pre><code class="js">npm install promises-aplus-tests -D</code></pre><p>执行测试</p><pre><code class="js">npx promises-aplus-tests Promise.js</code></pre><p>静等片刻，如果控制台没有爆红就是成功了，符合规范，如图所示</p><p><img src="../../../../../Documents/image-20200206222942803.png" srcset="/img/loading.gif" alt="image-20200206222942803"></p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p>篇幅已经很长了，后续还有其他内容，所以就实现了比较核心的 Promise 及 then 和 catch 方法</p><p>其他的 resolve/reject/race/all 等比较简单，不在这里描述了</p><p>给大家贴个我这边 Promise 多个方法实现的地址，大家有兴趣自行看代码吧，注释写的很详细了，也就大概 200 多行代码</p><ul><li>Github：<a href="https://github.com/isboyjc/promise" target="_blank" rel="noopener">https://github.com/isboyjc/promise</a></li></ul><h3 id="Promise-优-缺"><a href="#Promise-优-缺" class="headerlink" title="Promise 优/缺"></a>Promise 优/缺</h3><p><strong>优点</strong></p><p>Promise 用同步的方式写异步的代码，避免了层层嵌套的回调函数</p><p>Promise 对象提供了统一的接口，使得控制异步操作更加容易</p><p>链式操作，可以在 then 中继续写 Promise 对象并返回，然后继续调用 then 来进行回调操作</p><p><strong>缺点</strong></p><p>Promise 对象一旦新建就会立即执行，无法中途取消</p><p>若不设置回调函数，Promise 内部会抛出错误，不会流到外部</p><p>当处于 pending 状态时，无法得知当前处于哪一阶段</p><p>用多了 Promise 后代码一眼看上去都是 promise 的 API，而且链式语法总觉得不好看，不优雅</p><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>Generator 是协程在 ES6 的实现，最大的特点就是可以交出函数的执行权</p><p>我们可以通过 yield 关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案</p><p>Generator 的英文是生成器</p><p>想要了解生成器(Generator)，还是绕不过迭代器(Iterator)这个概念，我们先来简单介绍下</p><h3 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器(Iterator)"></a>迭代器(Iterator)</h3><h4 id="Iterator-简介"><a href="#Iterator-简介" class="headerlink" title="Iterator 简介"></a>Iterator 简介</h4><p>迭代器是一种接口，也可以说是一种规范</p><p>js 中不同的数据类型如(Array/Object/Set)等等遍历方式都各有不同，比如对象遍历我们会使用<code>for..in..</code>，数组可以使用<code>for循环/for..in../forEach</code>等等</p><p>那么有没有统一的方式遍历这些数据呢？这就是迭代器存在的意义，它可以提供统一的遍历数据的方式，只要在想要遍历的数据结构中添加一个支持迭代器的属性即可</p><h4 id="Iterator-语法"><a href="#Iterator-语法" class="headerlink" title="Iterator 语法"></a>Iterator 语法</h4><pre><code class="js">const obj = {  [Symbol.iterator]: function() {}}</code></pre><p><code>[Symbol.iterator]</code> 属性名是固定的写法，只要拥有了该属性的对象，就能够用迭代器的方式进行遍历</p><p>迭代器的遍历方法是首先获得一个迭代器的指针，初始时该指针指向第一条数据之前</p><p>接着通过调用 <code>next</code> 方法，改变指针的指向，让其指向下一条数据</p><p>每一次的 <code>next</code> 都会返回一个对象，该对象有两个属性</p><ul><li><p>value 代表想要获取的数据</p></li><li><p>done 布尔值，false 表示当前指针指向的数据有值，true 表示遍历已经结束</p></li></ul><h4 id="Iterator-详解"><a href="#Iterator-详解" class="headerlink" title="Iterator 详解"></a>Iterator 详解</h4><p>在 JS 中，<code>Array/Set/Map/String</code>都默认支持迭代器</p><p>由于数组和集合都支持迭代器，所以它们都可以用同一种方式来遍历</p><p>es6 中提供了一种新的循环方法叫做<code>for-of</code>，它实际上就是使用迭代器来进行遍历</p><p>换句话说只有支持了迭代器的数据结构才能使用<code>for-of</code>循环</p><p><strong>数组中使用迭代器遍历</strong></p><pre><code class="js">let arr = [{ num: 1 }, 2, 3]let it = arr[Symbol.iterator]() // 获取数组中的迭代器console.log(it.next()) // { value: Object { num: 1 }, done: false }console.log(it.next()) // { value: 2, done: false }console.log(it.next()) // { value: 3, done: false }console.log(it.next()) // { value: undefined, done: true }</code></pre><p>数组是支持迭代器遍历的，所以可以直接获取其迭代器，集合也是一样</p><p><strong>集合中使用迭代器遍历</strong></p><pre><code class="js">let list = new Set([1, 3, 2, 3])let it = list.entries() // 获取set集合中自带的的迭代器console.log(it.next()) // { value: [ 1, 1 ], done: false }console.log(it.next()) // { value: [ 3, 3 ], done: false }console.log(it.next()) // { value: [ 2, 2 ], done: false }console.log(it.next()) // { value: undefined, done: true }</code></pre><p>集合与数组不同的是，我们可以使用 Set 中的<code>entries</code>方法获取迭代器</p><p>Set 集合中每次遍历出来的值是一个数组，里面的第一和第二个元素都是一样的</p><p><strong>自定义对象中使用迭代器遍历</strong></p><p>首先自定义的对象没有迭代器属性，所以不支持迭代器迭代，我们也都知道<code>for..of</code>是无法遍历对象的，原因就在这里，因为<code>for..of</code>是使用迭代器迭代，所以对象不能用<code>for..of</code></p><p>既然知道是因为自定义对象无迭代器属性，那么我们可以为它加上<code>Symbol.iterator</code>这样一个属性，并为它实现一个迭代器方法，如下</p><pre><code class="js">let obj = {  name: &quot;tom&quot;,  age: 18,  gender: &quot;男&quot;,  intro: function() {    console.log(&quot;my name is &quot; + this.name)  },  [Symbol.iterator]: function() {    let i = 0    // 获取当前对象的所有属性并形成一个数组    let keys = Object.keys(this)    return {      next: function() {        return {          // 外部每次执行next都能得到数组中的第i个元素          value: keys[i++],          // 如果数组的数据已经遍历完则返回true          done: i &gt; keys.length        }      }    }  }}for (let attr of obj) {  console.log(attr)}</code></pre><p>如上所示，加上<code>[Symbol.iterator]</code>这个迭代器属性我们自定义了一个迭代器方法，就可以使用<code>for..of</code>方法了</p><h4 id="Iterator-作用"><a href="#Iterator-作用" class="headerlink" title="Iterator 作用"></a>Iterator 作用</h4><p>Iterator 的作用有三个：</p><ul><li>为各种数据结构，提供一个统一的、简便的访问接口</li><li>使得数据结构的成员能够按某种次序排列</li><li>ES6 创造了一种新的遍历命令<code>for..of</code>循环，Iterator 接口主要供<code>for..of</code>消费</li></ul><p>Iterator 我们就介绍到这里，到这就理解上文 Iterator 参数是什么了吧，就是代表一个有迭代器属性的参数</p><h3 id="初识-Generator"><a href="#初识-Generator" class="headerlink" title="初识 Generator"></a>初识 Generator</h3><p>Generator 其实也是一个函数，只不过是一个特殊的函数</p><p>普通函数，你运行了这个函数，函数内部不会停，直到这个函数结束</p><p>Generator 这个函数特殊之处就是，中间可以停</p><h4 id="Generator-函数特点"><a href="#Generator-函数特点" class="headerlink" title="Generator 函数特点"></a>Generator 函数特点</h4><pre><code class="js">function* generatorFn() {  console.log(&quot;a&quot;)  yield &quot;1&quot;  console.log(&quot;b&quot;)  yield &quot;2&quot;  console.log(&quot;c&quot;)  return &quot;3&quot;}let it = generatorFn()it.next()it.next()it.next()it.next()</code></pre><p>上面这个示例就是一个 Generator 函数，首先我们观察它的特点，一个一个进行分析</p><ul><li>不同于普通函数，Generator 函数在<code>function</code>后面，函数名之前有个<code>*</code><ul><li><code>*</code>用来表示函数为 Generator 函数</li><li>写法很多，<code>function* fn()</code>、<code>function*fn()</code>和<code>function *fn()</code>都可以</li></ul></li><li>函数内部有<code>yield</code>字段<ul><li><code>yield</code>用来定义函数内部的状态，并让出执行权</li><li>这个关键字只能出现在生成器函数体内，但是生成器中也可以没有 yield 关键字，函数遇到 yield 的时候会暂停，并把 yield 后面的表达式结果抛出去</li></ul></li><li>调用后其函数返回值使用了<code>next</code>方法<ul><li>调用 Generator 函数和调用普通函数一样，在函数名后面加上()即可</li><li>Generator 函数不会像普通函数一样立即执行，而是返回一个指向内部状态对象的指针</li><li>所以要调用迭代器对象 Iterator 的 <code>next</code> 方法，指针就会从函数头部或者上一次停下来的地方开始执行</li><li><code>next</code> 方法其实就是将代码的控制权交还给生成器函数</li></ul></li></ul><h4 id="分析执行过程"><a href="#分析执行过程" class="headerlink" title="分析执行过程"></a>分析执行过程</h4><p>接着我们来分析它的执行过程，线来看它的打印结果，还是上面那个例子</p><pre><code class="js">let it = generatorFn()it.next()// a// {value: &quot;1&quot;, done: false}it.next()// b// {value: &quot;1&quot;, done: false}it.next()// c// {value: &quot;1&quot;, done: true}it.next()// {value: undefined, done: true}</code></pre><p>首先，Generator 函数执行，返回了一个指向内部状态对象的指针，此时没有任何输出</p><p>第一次调用<code>next</code>方法，从 Generator 函数的头部开始执行，先是打印了 a ，执行到<code>yield</code>就停下来，并将<code>yield</code>后边表达式的值 ‘1’，作为返回对象的 value 属性值，此时函数还没有执行完， 返回对象的 done 属性值是 false</p><p>第二次调用<code>next</code>方法时，同上步</p><p>第三次调用<code>next</code>方法时，先是打印了 c ，然后执行了函数的返回操作，并将 return 后面的表达式的值，作为返回对象的 value 属性值，此时函数已经结束，所以 done 属性值为 true</p><p>第四次调用<code>next</code>方法时， 此时函数已经执行完了，所以返回 value 属性值是 undefined，done 属性值是 true ，如果执行第三步时，没有 return 语句的话，就直接返回 <code>{value: undefined, done: true}</code></p><p>简单的理解，Generator 函数<code>yield</code>放到哪里它就停到哪里，调用时使用<code>next</code>方法踹一步就走一步</p><h4 id="next-参数传递"><a href="#next-参数传递" class="headerlink" title="next 参数传递"></a>next 参数传递</h4><p><code>yield</code>是有返回值的，<code>next</code>方法直接调用不传入参数的时候，<code>yield</code> 表达式的返回值是 undefined</p><p>当 next 传入参数的时候，该参数会作为<strong>上一步</strong><code>yield</code>的返回值</p><p>我们通过示例来理解</p><pre><code class="js">function* geFn() {  cosnole.log(&quot;start&quot;)  let a = yield &quot;1&quot;  console.log(a)  let b = yield &quot;2&quot;  console.log(b)  let c = yield &quot;3&quot;  console.log(c)  return 4}let it = geFn()it.next()// start// { value:1, done: false }it1.next()// undefined           未传值，所以a=undefined// { value:2, done: false }it.next(&quot;hahaha&quot;)// hahaha                 传值，所以b=hahaha// { value:3, done: false }it.next(&quot;omg&quot;)// omg                         传值，所以c=omg// {value: 4, done: true}</code></pre><p>由于 <code>next</code> 方法的参数表示上一个 <code>yield</code> 语句的返回值，所以第一次使用 <code>next</code> 方法时，不能带有参数</p><p>V8 引擎会直接忽略第一次使用 <code>next</code> 方法时的参数，只有从第二次使用 <code>next</code> 方法开始，参数才是有效的</p><p>没有接到传值时，<code>yield</code>语句的返回值就是 undefined，正如上面示例输出那样</p><p>通过 <code>next</code> 方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值，这代表了我们可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为</p><h4 id="再次理解-yield"><a href="#再次理解-yield" class="headerlink" title="再次理解 yield"></a>再次理解 yield</h4><p>我们再来看一段代码，帮助我们理解<code>yield</code></p><pre><code class="js">function* geFn() {  console.log(&quot;start&quot;)  let a = yield console.log(&quot;1&quot;)  console.log(a)  let b = yield console.log(&quot;2&quot;)  console.log(b)  return console.log(&quot;3&quot;)}let it = geFn()it.next()// start// 1// {value: 1, done: false}it.next(&quot;我是a&quot;)// 我是a// 2// {value: 2, done: false}it.next(&quot;我是b&quot;)// 我是b// 3// {value: 3, done: true}</code></pre><p>通过<code>next</code>调用我们可以看到，第一次调用就输出了<code>start &amp; 1</code> ，意味着<code>yield</code>停止时，后面代码是执行了的</p><p><img src="/img/blog/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.assets/image-20200207234938429.png" srcset="/img/loading.gif" alt="image-20200207234938429"></p><p>如上图所示，如果将说<code>yield</code>比做一道墙，那么墙右边和上面是一块，墙左边和下面是一块，这样说应该够直白了吧</p><h4 id="for-of-遍历-Generator"><a href="#for-of-遍历-Generator" class="headerlink" title="for..of 遍历 Generator"></a>for..of 遍历 Generator</h4><p>上文我们就知道了<code>for...of</code>内部实现就是在使用迭代器迭代，那么<code>for...of</code>循环直接用在 Generator 遍历器上岂不是完美</p><p>是的，它可以自动遍历 Generator 函数，而且此时不再需要调用 next 方法，一旦 next 方法的返回对象的 done 属性为 true，<code>for...of</code>循环就会中止，且不包含该返回对象</p><pre><code class="js">function* foo() {  yield 1  yield 2  yield 3  yield 4  yield 5  return 6}for (let v of foo()) {  console.log(v)}// 1 2 3 4 5</code></pre><h4 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h4><p>在<code>yield</code>命令后面加上星号，表明它返回的是一个遍历器，这被称为<code>yield*</code>表达式</p><pre><code class="js">function* foo() {  yield &quot;foo1&quot;  yield &quot;foo2&quot;}function* bar() {  yield &quot;bar1&quot;  yield* foo()  yield &quot;bar2&quot;}for (let val of bar()) {  console.log(val)}// bar1 foo1 foo2 bar2</code></pre><p><code>yield</code>命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器</p><pre><code class="js">function* gen1() {  yield [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]}for (let val of gen1()) {  console.log(a)}// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]// ------------------- 上下分割function* gen2() {  yield* [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]}for (let val of gen2()) {  console.log(a)}// a b c</code></pre><h4 id="Generator-中的-return"><a href="#Generator-中的-return" class="headerlink" title="Generator 中的 return"></a>Generator 中的 return</h4><p>return 方法返回给定值，并结束遍历 Generator 函数</p><p>当 return 无值时，就返回 undefined，来看例子</p><pre><code class="js">function* foo() {  yield 1  yield 2  yield 3}var f = foo()f.next()// {value: 1, done: false}f.return(&quot;hahaha&quot;)// 由于调用了return方法，所以遍历已结束，done变true// {value: &quot;hahaha&quot;, done: true}f.next()// {value: undefined, done: true}</code></pre><h4 id="Generator-错误处理-throw"><a href="#Generator-错误处理-throw" class="headerlink" title="Generator 错误处理 throw"></a>Generator 错误处理 throw</h4><p><code>throw</code>方法可以再 Generator 函数体外面抛出异常，再函数体内部捕获，听着是很好理解</p><p>这里一不小心还是挺容易入坑的，我们来看几个例子吧</p><pre><code class="js">function* foo() {  try {    yield &quot;hahaha&quot;  } catch (err) {    console.log(&quot;inside error: &quot; + err)  }}var f = foo()try {  it.throw(&quot;this is err&quot;)} catch (err) {  console.log(&quot;out error: &quot; + err)}</code></pre><p>上面代码会输出哪个错误呢？</p><p>其实答案很简单，上述代码会输出<code>out error：this is err</code></p><p>因为调用<code>throw</code>的时候，我们并没有执行<code>next</code>方法，这个时候内部的<code>try{}catch{}</code>代码都还没执行，因此只会被外面捕捉</p><p>所以说，我们只需要在调用<code>throw</code>之前，先调用一遍<code>next</code>，这个时候函数体内部已经执行了<code>try{}catch{}</code>，那么执行到<code>throw</code>时，内外都有错误捕捉，<strong><code>throw</code>方法会先被内部捕捉</strong>，从而打印<code>inside error：this is err</code></p><p>除此，<strong><code>throw</code>方法会附带执行下一个<code>yield</code></strong>，我们来看示例</p><pre><code class="js">var foo = function* foo() {  try {    yield console.log(&quot;1&quot;)    yield console.log(&quot;2&quot;)  } catch (e) {    console.log(&quot;inside err&quot;)  }  yield console.log(&quot;3&quot;)  yield console.log(&quot;4&quot;)}var g = foo()g.next()g.throw()g.next()</code></pre><p>我们来看上述代码的执行过程</p><p>首先执行第一个<code>next</code>方法，进入<code>try()catch()</code>，输出 1</p><p>接着，执行<code>throw</code>方法，内部捕捉到，输出<code>inside err</code>，此时<code>try()catch()</code>代码块已经执行了<code>catch</code>，<code>try()catch()</code>代码块已经结束了，所以附带执行一个<code>yield</code>会继续向下找，所以再输出 3</p><p>最后执行<code>next</code>方法，输出 4</p><p>最终输出结果为<code>1 3 4</code></p><h3 id="Generator-扩充"><a href="#Generator-扩充" class="headerlink" title="Generator 扩充"></a>Generator 扩充</h3><p>在 Generator 开头有一句话，不知道大家理解没有</p><ul><li>Generator 是协程在 ES6 的实现，最大的特点就是可以交出函数的执行权</li></ul><h4 id="什么是协程？"><a href="#什么是协程？" class="headerlink" title="什么是协程？"></a>什么是协程？</h4><p>这里使用阮一峰老师的文章参考链接【8】中对协程的解释并略带修改及补充</p><p>进程和线程大家应该都清楚，那么协程是什么呢</p><p>不知道大家知不知道用户空间线程，其实就是一种由程序员自己写程序来管理他的调度的线程，对内核来说不可见</p><p>协程(coroutine)，可以理解就是一种“用户空间线程”，也可理解为多个“线程”相互协作，完成异步任务</p><p>由于线程是操作系统的最小执行单元，因此也可以得出，协程是基于线程实现的，不过它要比线程要轻很多</p><p>协程，有几个特点：</p><ul><li>协同，因为是由程序员自己写的调度策略，其通过协作而不是抢占来进行切换</li><li>在用户态完成创建，切换和销毁</li><li>编程角度上看，协程的思想本质上就是控制流的主动让出(yield)和恢复(resume)机制</li></ul><p>它的运行流程如下</p><ul><li>协程 A 开始执行</li><li>协程 A 执行到一半，暂停执行，执行的权利转交给协程 B。</li><li>一段时间后 B 交还执行权</li><li>协程 A 重得执行权，继续执行</li></ul><p>上面的协程 A 就是一个异步任务，因为在执行过程中执行权被 B 抢了，被迫分成两步完成</p><p>举例来说，读取文件的协程写法如下</p><pre><code class="javascript">function asnycJob() {  // ...其他代码  var f = yield readFile(fileA);  // ...其他代码}</code></pre><p>上面代码的函数 asyncJob 是一个协程，其中的 <code>yield</code> 命令，它表示执行到此处，执行权将交给其他协程，也就是说，<code>yield</code>命令是异步两个阶段的分界线</p><p>协程遇到 <code>yield</code> 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行，它的最大优点，就是代码的写法非常像同步操作，只多了一个<code>yield</code>命令</p><h4 id="Generator-与协程"><a href="#Generator-与协程" class="headerlink" title="Generator 与协程"></a>Generator 与协程</h4><p>JS 是单线程的，ES6 中的 Generator 的实现，类似于开了多线程，但是依然同时只能进行一个线程，不过可以切换</p><p>就像汽车在公路上行驶，js 公路只是单行道(主线程)，但是有很多车道(辅助线程)都可以汇入车流(异步任务完成后回调进入主线程的任务队列)</p><p>而 Generator 把 js 公路变成了多车道(协程实现)，但是同一时间只有一个车道上的车能开(所以依然是单线程)，不过可以自由变道(移交控制权)</p><h4 id="Generator-之-Thunk-函数"><a href="#Generator-之-Thunk-函数" class="headerlink" title="Generator 之 Thunk 函数"></a>Generator 之 Thunk 函数</h4><p>thunk 函数的诞生源于一个编译器设计的问题：<code>求值策略</code>，即函数的参数到底应该何时求值</p><pre><code class="js">var x = 1function fn(n) {  return n * 10}fn(x + 5)</code></pre><p>如上所示，其中 fn 方法调用时<code>x+5</code>这个表达式应该什么时候求值，有两种思路</p><ul><li><strong>传值调用(call by value)</strong>，先计算<code>x+5</code>的值，再将这个值 <code>6</code> 传入函数 fn，例如 c 语言，这种做法的好处是实现比较简单，但是有可能会造成性能损失(例如一个函数传入了两个参数，第二个参数是一个表达式，但是函数体内没有用到这个参数，那么先计算出值就会损耗性能且无意义)</li><li><strong>传名调用(call by name)</strong>，即直接将表达式<code>x+5</code>传入函数体，只在用到它的时候求值</li></ul><p>Thunk 函数的定义，就是传名调用的一种实现策略，用来替换某个表达式，实现思路其实也很简单</p><p>先将参数放到一个临时函数之中，再将这个临时函数传入函数体，就像下面这样</p><pre><code class="js">function fn(m) {  return m * 2}fn(x + 5)// thunk实现思路var thunk = function() {  return x + 5}function fn(thunk) {  return thunk() * 2}</code></pre><p>JS 是传值调用，它的 Thunck 函数含义有所不同</p><p>在 JS 中，Thunk 函数替换的不是表达式，是对函数珂里化的一种运用，简单来说，就是把是多参数函数替换成一个只接受回调函数作为参数的单参数函数，我们来看下它的简单实现</p><pre><code class="js">fs.readFile(fileName, callback)const Thunk = function(fn) {  return function(...args) {    return function(callback) {      return fn.call(this, ...args, callback)    }  }}// 使用上面的Thunk转化器，生成fs.readFile的Thunk函数var readFileThunk = Thunk(fs.readFile)readFileThunk(fileName)(callback)</code></pre><p>如果在生产环境要使用 Thunk 函数的话，使用 Thunkify 模块就可以，其实它核心源码就是上面我们写的 Thunk，Thunkify 里多了一个检查机制而已，比较简单，可自行百度 Thunkify 模块了解</p><p>Thunk 这东西在 ES6 前其实没有太大用处，但是在 Generator 函数出来后，Thunk 函数就可以派上用场了，它可以用于 Generator 函数的自动流程管理，接收和交换程序的执行权</p><p>我们来实现一个基于 Thunk 函数的 Generator 自动执行器</p><pre><code class="js">// 基于Thunk函数的Genertor函数自动执行器function run(fn) {  let gen = fn()  function next(err, data) {    // 将指针移动到Generator函数的下一步    let result = gen.next(data)    // 判断是否结束    if (result.done) return    // 递归,把next放进.value中    result.value(next)  }  next()}// 模拟异步方法let sleep = function(n, callback) {  setTimeout(() =&gt; {    console.log(n)    callback &amp;&amp; callback(n)  }, n)}// 模拟异步方法进行Thunk转换let sleepThunk = Thunk(sleep)// Generator函数let gen = function*() {  let f1 = yield sleepThunk(1000)  let f2 = yield sleepThunk(1500)  // ...  let fn = yield sleepThunk(2000)}// 调用Genertor函数自动执行器run(gen)</code></pre><p>上面代码的 run 函数，就是一个 Generator 函数的自动执行器，内部的 next 函数就是 Thunk 的回调函数</p><p>next 函数先将指针移到 Generator 函数的下一步(gen.next 方法)</p><p>然后判断 Generator 函数是否结束(result.done 属性)</p><p>如果没结束，就将 next 函数再传入 Thunk 函数(result.value 属性)，否则就直接退出</p><p>代码中模拟了一个异步操作<code>sleep</code>方法，并将其转化为了 Thunk 方法(使用上文我们实现的那个简易版 Thunk)</p><p>函数 gen 封装了 n 个异步操作，只要执行 run 函数，这些操作就会自动完成</p><p>这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行，极其方便</p><p>不过相信大家也看到了，这种自动执行器传入的 Generator 函数，<strong>yield 方法后面必须是一个 Thunk 函数</strong></p><p>——–👇——–</p><p>Thunk 就简单介绍到这里了，更多 Thunk 相关推荐看阮一峰文参考链接【9】</p><p>我们只需要明白 Thunk 是什么，它和 Generator 有什么关系就可以</p><h4 id="Generator-之-co-函数库"><a href="#Generator-之-co-函数库" class="headerlink" title="Generator 之 co 函数库"></a>Generator 之 co 函数库</h4><p>co 函数库是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于 Generator 函数的自动执行</p><p><a href="https://github.com/tj/co" target="_blank" rel="noopener">co 函数库传送门</a></p><p>co 函数库其实就是将两种自动执行器(Thunk 函数和 Promise 对象)，包装成一个库，所以说使用 co 的前提条件是，Generator 函数的 yield 命令后面，只能是 Thunk 函数或 Promise 对象</p><p>co 函数会返回一个 Promise，所以我们可以后接<code>then</code>等方法</p><p>基于 Thunk 函数的自动执行器上面介绍了下，那么基于 Promise 的其实也差不多，我们简单实现下</p><pre><code class="js">// 基于Promise函数的Genertor函数自动执行器function run(gen) {  let g = gen()  function next(data) {    // 将指针移动到Generator函数的下一步    let result = g.next(data)    // 判断是否结束，结束返回value，value是一个Promise    if (result.done) return result.value    // 递归    result.value.then(data =&gt; {      next(data)    })  }  next()}// 模拟异步方法进行Promise转换let sleepPromise = function(n) {  return new Promise(function(resolve, reject) {    setTimeout(() =&gt; {      console.log(n)      resolve(n)    }, n)  })}// Generator函数let gen = function*() {  let f1 = yield sleepPromise(1000)  let f2 = yield sleepPromise(1500)  // ...  let fn = yield sleepPromise(2000)}// 调用Genertor函数自动执行器run(gen)</code></pre><p>如上代码，和 Thunk 函数那里区别就是 yield 后面一个跟 Thunk 函数，一个跟 Promise 对象</p><p>如果 Thunk 自执行器你理解了，Promise 使用也 ok 的话，这块代码看看就懂了，也没啥解释的</p><p>接下来我们来看看 co 库的源码</p><p>co 函数库的源码也很简单，只有几十行代码</p><p>首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象</p><pre><code class="js">function co(gen) {  var ctx = this  return new Promise(function(resolve, reject) {})}</code></pre><p>在返回的 Promise 对象里面，co 先检查参数 gen 是否为 Generator 函数</p><p>如果是，就执行该函数，得到一个内部指针对象</p><p>如果不是就返回，并将 Promise 对象的状态改为 resolved</p><pre><code class="js">function co(gen) {  var ctx = this  return new Promise(function(resolve, reject) {    if (typeof gen === &quot;function&quot;) gen = gen.call(ctx)    if (!gen || typeof gen.next !== &quot;function&quot;) return resolve(gen)  })}</code></pre><p>接着，co 将 Generator 函数的内部指针对象的 next 方法，包装成 onFulefilled 函数</p><p>主要是为了能够捕捉抛出的错误</p><pre><code class="js">function co(gen) {  var ctx = this  return new Promise(function(resolve, reject) {    if (typeof gen === &quot;function&quot;) gen = gen.call(ctx)    if (!gen || typeof gen.next !== &quot;function&quot;) return resolve(gen)    onFulfilled()    function onFulfilled(res) {      var ret      try {        ret = gen.next(res)      } catch (e) {        return reject(e)      }      next(ret)    }  })}</code></pre><p>最后，就是关键的 next 函数，它会反复调用自身</p><pre><code class="js">function next(ret) {  if (ret.done) return resolve(ret.value)  var value = toPromise.call(ctx, ret.value)  if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected)  return onRejected(new TypeError(&#39;You may only yield a function, promise, generator, array, or object, but the following object was passed: &quot;&#39; + String(ret.value) + &#39;&quot;&#39;))    }})</code></pre><p><code>next</code>方法中，第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回</p><p>第二行，确保每一步的返回值，是 Promise 对象</p><p>第三行，使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数</p><p>第四行，在参数不符合要求的情况下(参数非 Thunk 函数和 Promise 对象)，将 Promise 对象的状态改为 rejected，从而终止执行</p><p>co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步，我们可以并发的操作放在数组或对象里面，如下</p><pre><code class="js">// 数组的写法co(function*() {  var res = yield [Promise.resolve(1), Promise.resolve(2)]  console.log(res)}).catch(onerror)// 对象的写法co(function*() {  var res = yield {    1: Promise.resolve(1),    2: Promise.resolve(2)  }  console.log(res)}).catch(onerror)</code></pre><p>——-👇——-</p><p>以上就是 co 的内容了，这里提及只是为了让大家了解 co 这种函数库，虽然目前用的不多，但是对我们理解 Generator 有帮助，即使这里有些迷糊，也无伤大雅，知道 co 是什么，co 的自动执行原理大概是怎么实现的就行</p><p>这块和 Thunk 一样，也是参考阮一峰老师的文章，所以有兴趣的话可以看下参考链接【10】</p><h3 id="Generator-优-缺"><a href="#Generator-优-缺" class="headerlink" title="Generator 优/缺"></a>Generator 优/缺</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>优雅的流程控制方式，可以让函数可中断执行，在某些特殊需求里还是很实用的</p><p>使用过 React-dva 的同学可能会更有感触一些</p><p>之前 Node 的 koa 框架也用 Generator，不过后来被 async/await 替代了</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>Generator 函数的执行必须靠执行器，所以才有了 co 函数库，但 co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，只针对异步处理来说，还是不太方便</p><h2 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h2><h3 id="Async-和-Await-简介"><a href="#Async-和-Await-简介" class="headerlink" title="Async 和 Await 简介"></a>Async 和 Await 简介</h3><p>ES2017 标准引入了 <code>async</code> 函数，使得异步操作变得更加方便</p><p>JS 异步编程解决方案的历程，从经典的回调函数到事件监听，再到 <code>Promise</code> ，再到 <code>Generator</code> ，再到我们要说的 <code>Async/Await</code> ，可谓艰辛</p><p><code>Async/Await</code> 的出现，被很多人认为是 JS 异步操作的最终且最优雅的解决方案</p><p><code>Async/Await</code> 大家都经常使用，也都知道它是 <code>Generator</code> 的语法糖</p><p>其实我觉得 <code>Async/Await = Generator + Promise</code> 这个解释更适合</p><p><code>async</code> 是异步的意思，而 <code>await</code> 是 <code>async wait</code> 的简写，即异步等待</p><p>所以从语义上就很好理解 <code>async</code> 用于声明一个 <code>function</code> 是异步的，<code>await</code> 用于等待一个异步方法执行完成</p><p>另外 <code>await</code> 只能出现在 <code>async</code> 函数中</p><p>闲聊至此，接下来还是简单介绍下使用</p><h3 id="Async-在做什么"><a href="#Async-在做什么" class="headerlink" title="Async 在做什么"></a>Async 在做什么</h3><p>我们来看一个例子理解</p><pre><code class="js">async function test() {  return &quot;this is async&quot;}const res = test()console.log(res)// Promise {&lt;resolved&gt;: &quot;this is async&quot;}</code></pre><p>可以看到，输出的是一个 Promise 对象</p><p>所以，<code>async</code> 函数返回的是一个 Promise 对象，如果在 <code>async</code> 函数中直接 return 一个直接量，<code>async</code> 会把这个直接量通过 <code>PromIse.resolve()</code> 封装成 Promise 对象返回</p><p>既然 <code>async</code> 返回一个 Promise，那么我们也可以用 <code>then</code> 链来处理这个 Promise 对象，如下</p><pre><code class="js">test().then(res =&gt; {  console.log(res)})</code></pre><h3 id="Await-在等待什么"><a href="#Await-在等待什么" class="headerlink" title="Await 在等待什么"></a>Await 在等待什么</h3><p>我们常说<code>await</code> 是在等待一个异步完成， 其实按照语法说明， <code>await</code> 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值(换句话说，就是没有特殊限定，啥都行)</p><ul><li><code>await</code> 后面不是 Promise 对象，直接执行</li><li><code>await</code> 后面是 Promise 对象会阻塞后面的代码，Promise 对象 <code>resolve</code>，然后得到 <code>resolve</code> 的值，作为 <code>await</code> 表达式的运算结果</li><li><code>await</code> 只能在 <code>async</code> 函数中使用</li></ul><p>使用比较简单，大家也经常用就不多说了</p><p>简单说一下为什 <code>await</code> 必须要在 <code>async</code> 函数中使用</p><p>其实很简单， <code>await</code> 会阻塞后面代码，如果允许我们直接使用 <code>await</code> 的话，假如我们使用<code>await</code>等待一个消耗时间比较长的异步请求，那代码直接就阻塞不往下执行了，只能等待 <code>await</code> 拿到结果才会执行下面的代码，那不乱套了</p><p>而 <code>async</code> 函数调用不会造成阻塞，因为它内部所有的阻塞都被封装在一个 Promise 对象中异步执行，所以才规定 <code>await</code> 必须在 <code>async</code> 函数中</p><h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><p>promise 正常 resolve，那么 await 会返回这个结果，但是在 reject 的情况下会抛出一个错误</p><p>所以我们直接把 <code>await</code> 代码块写到 <code>try()catch()</code> 中捕获错误即可</p><pre><code class="js">async function fn() {  try {    let res = await ajax()    console.log(res)  } catch (err) {    console.log(err)  }}</code></pre><h3 id="没有对比没有伤害"><a href="#没有对比没有伤害" class="headerlink" title="没有对比没有伤害"></a>没有对比没有伤害</h3><p>我们经常会遇到这种业务，多个请求，每个请求依赖于上一个请求的结果</p><p>我们用 setTimeout 模拟异步操作，用 Promise 和 Async/Await 分别来实现下</p><pre><code class="js">function analogAsync(n) {  return new Promise(resolve =&gt; {    setTimeout(() =&gt; resolve(n + 500), n)  })}function fn1(n) {  console.log(`step1 with ${n}`)  return analogAsync(n)}function fn2(n) {  console.log(`step2 with ${n}`)  return analogAsync(n)}function fn3(n) {  console.log(`step3 with ${n}`)  return analogAsync(n)}</code></pre><p>使用 Promise</p><pre><code class="js">function fn() {  let time1 = 0  fn1(time1)    .then(time2 =&gt; fn2(time2))    .then(time3 =&gt; fn3(time3))    .then(res =&gt; {      console.log(`result is ${res}`)    })}fn()</code></pre><p>使用 Async/Await</p><pre><code class="js">async function fn() {  let time1 = 0  let time2 = await fn1(time1)  let time3 = await fn2(time2)  let res = await fn3(time3)  console.log(`result is ${res}`)}fn()</code></pre><p>输出结果和上面用 Promise 实现是一样的，但这个 <code>aaync/await</code> 代码结构看起来清晰得多，几乎跟同步写法一样，十分优雅</p><p>我们再来看下面这个小例子</p><pre><code class="js">// Generatorfunction* gen() {  let f1 = yield ajax()  let f2 = yield ajax()}gen()// async/awaitasync function asyncAjax() {  let f1 = await ajax()  let f2 = await ajax()}asyncAjax()</code></pre><p>这两块代码看着是不是几乎一样</p><p>上面函数为 Generator 函数执行两个 ajax，下面函数为 async/await 执行</p><p>比较可发现，两个函数其实是一样的，<code>async</code> 不过是把 Generator 函数的 <code>*</code> 号换成 <code>async</code>，<code>yield</code> 换成 <code>await</code></p><p>那么这两个函数在调用时，Generator 函数需要手动调用 <code>next</code> 方法或者使用 co 函数库才可执行，而下面的<code>async</code> 函数直接就按顺序执行完成了，使用非常方便</p><p>异步编程追求的是，让它更像同步编程， <code>Async/Await</code> 完美诠释了这一点</p><p>到这里我们其实就不难看出 <code>Async/Await</code> 已经完虐了 <code>Generator</code> 和 <code>Promise</code></p><p>对比来看我们发现，Async 函数自带执行器</p><h3 id="Async-Await-优-缺"><a href="#Async-Await-优-缺" class="headerlink" title="Async/Await 优/缺"></a>Async/Await 优/缺</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>内置执行器， Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 <code>async</code> 函数自带执行器，也就是说，<code>async</code> 函数的执行，与普通函数一模一样，只要一行</p><p>更好的语义，<code>async</code> 和 <code>await</code>，比起 <code>*</code> 和 <code>yield</code>，语义更清楚了，<code>async</code> 表示函数里有异步操作，<code>await</code> 表示紧跟在后面的表达式需要等待结果</p><p>更广的适用性，co 函数库约定，<code>yield</code> 命令后面只能是 Thunk 函数或 Promise 对象，而 <code>async</code> 函数的 <code>await</code> 命令后面，可以跟 Promise 对象和原始类型的值(数值、字符串和布尔值，但这时等同于同步操作)</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>滥用 <code>await</code> 可能会导致性能问题，因为 <code>await</code> 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性</p><h2 id="异步解决方案对比"><a href="#异步解决方案对比" class="headerlink" title="异步解决方案对比"></a>异步解决方案对比</h2><p>别看了，我没有总结对比</p><p>其实相对来说已经写的很详细了，能讲出来的才算是自己的，大家可根据每种方案列出的优缺点加上自己的理解做个对比或着说总结，毕竟你都看到这了，也不妄花费这么长时间来阅读这两万字的干帖子，总归要有些收获的</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>水平有限，欢迎指错</p><p>码字不易，大家有收获别忘了点个赞鼓励下</p><p>搜索【不正经的前端】或直接扫码可以关注公众号看到更多的精彩文章，也有一些群友提供的学习视频、资源干货什么的免费拿</p><p>也可以直接加我微信，进交流群学习交流</p><p><img src="/img/blog/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.assets/%E7%A8%BF%E5%AE%9A%E8%AE%BE%E8%AE%A1%E5%AF%BC%E5%87%BA-20200111-143924.png" srcset="/img/loading.gif" alt="稿定设计导出-20200111-143924"></p><blockquote><p>参考</p><ol><li><a href="[http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html](http://www.ruanyifeng.com/blog/2012/12/asynchronous＿javascript.html)">Javascript 异步编程的 4 种方法-阮一峰</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise-MDN</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023024358748480" target="_blank" rel="noopener">iterable-廖雪峰</a></li><li><a href="http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/" target="_blank" rel="noopener">What is Promise.try, and why does it matter?</a></li><li><a href="https://segmentfault.com/a/1190000018586947" target="_blank" rel="noopener">什么是 Promise.try，为什么它这么重要？-参考 4 译</a></li><li><a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise/A+规范-英原文</a></li><li><a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">Promise/A+规范-中文译</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/04/generator.html" target="_blank" rel="noopener">Generator 函数的含义与用法-阮一峰</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/05/thunk.html" target="_blank" rel="noopener">Thunk 函数的含义和用法-阮一峰</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/05/co.html" target="_blank" rel="noopener">co 函数库的含义和用法-阮一峰</a></li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>硬核JS系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「硬核 JS」一次搞懂 JS 运行机制</title>
    <link href="/blog/2020/01/18/javascript/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E4%B8%80%E6%AC%A1%E6%90%9E%E6%87%82JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <url>/blog/2020/01/18/javascript/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E4%B8%80%E6%AC%A1%E6%90%9E%E6%87%82JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="「硬核-JS」一次搞懂-JS-运行机制"><a href="#「硬核-JS」一次搞懂-JS-运行机制" class="headerlink" title="「硬核 JS」一次搞懂 JS 运行机制"></a>「硬核 JS」一次搞懂 JS 运行机制</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从开始做前端到目前为止，陆续看了很多帖子讲 JS 运行机制，看过不久就忘了，还是自己理一遍好些</p><p>通过码字使自己对 JS 运行机制相关内容更加深刻(自己用心写过的贴子，内容也会牢记于心)</p><p>顺道给大家看看(我太难了，深夜码字，反复修改，说这么多就是想请你点个赞在看)</p><p>参考了很多资料(帖子)，取其精华，去其糟糠，都在文末，可自行了解</p><p>是时候搞一波我大 js 了</p><p>从零到一百再到一，从多方面了解 JS 的运行机制，体会更深刻，请认真读下去</p><p>本文大致分为以下这样的步骤来帮助我们由广入深更加清晰的了解 JS 运行机制</p><ul><li>首先我们要了解进程和线程的概念</li><li>其次我们要知道浏览器的进程线程常识</li><li>再然后通过 Event Loop、宏任务(macrotask)微任务(microtask)来看浏览器的几个线程间是怎样配合的</li><li>再然后通过例子来印证我们的猜想</li><li>最后提下 NodeJS 的运行机制</li></ul><h2 id="灵魂一问"><a href="#灵魂一问" class="headerlink" title="灵魂一问"></a>灵魂一问</h2><p>JS 运行机制在平常前端面试时不管是笔试题还是面试题命中率都极高</p><p>说到 JS 运行机制，你知道多少</p><p>看到这大家可能会说：JS 运行机制嘛，很简单，事件循环、宏微任务那点东西</p><p>是的，作为一名前端我们都了解，但是如果这真的面试问到了这个地方，你真的可以答好吗(灵魂一问 🤔️)</p><p><strong>不管你对 JS 了解多少，到这里大家不防先停止一下阅读，假设你目前在面试，面试官让你阐述下 JS 运行机制，思考下你的答案，用 20 秒的时间(面试时 20s 已经很长了)，然后带着答案再接着往下看，有人曾经说过：<code>没有思考的阅读纯粹是消磨时间罢了</code>，这话很好(因为是我说的，皮一下 😄)</strong></p><p>也有很多刚开始接触 JS 的同学会被<code>任务队列 执行栈 微任务 宏任务</code>这些高大上点的名字搞的很懵</p><p>接下来，我们来细致的梳理一遍你就可以清晰的了解它们了</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><p>我们都知道，<code>CPU</code>是计算机的核心，承担所有的计算任务</p><p>官网说法，<code>进程</code>是<code>CPU</code>资源分配的最小单位</p><p>字面意思就是进行中的程序，我将它理解为一个可以独立运行且拥有自己的资源空间的任务程序</p><p><code>进程</code>包括运行中的程序和程序所使用到的内存和系统资源</p><p><code>CPU</code>可以有很多进程，我们的电脑每打开一个软件就会产生一个或多个<code>进程</code>，为什么电脑运行的软件多就会卡，是因为<code>CPU</code>给每个<code>进程</code>分配资源空间，但是一个<code>CPU</code>一共就那么多资源，分出去越多，越卡，每个<code>进程</code>之间是相互独立的，<code>CPU</code>在运行一个<code>进程</code>时，其他的进程处于非运行状态，<code>CPU</code>使用 <a href="[https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6](https://baike.baidu.com/item/时间片轮转调度)">时间片轮转调度算法</a> 来实现同时运行多个<code>进程</code></p><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p><code>线程</code>是<code>CPU</code>调度的最小单位</p><p><code>线程</code>是建立在<code>进程</code>的基础上的一次程序运行单位，通俗点解释<code>线程</code>就是程序中的一个执行流，一个<code>进程</code>可以有多个<code>线程</code></p><p>一个<code>进程</code>中只有一个执行流称作<code>单线程</code>，即程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行</p><p>一个<code>进程</code>中有多个执行流称作<code>多线程</code>，即在一个程序中可以同时运行多个不同的<code>线程</code>来执行不同的任务，<br>也就是说允许单个程序创建多个并行执行的<code>线程</code>来完成各自的任务</p><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p>进程是操作系统分配资源的最小单位，线程是程序执行的最小单位</p><p>一个进程由一个或多个线程组成，线程可以理解为是一个进程中代码的不同执行路线</p><p>进程之间相互独立，但同一进程下的各个线程间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)</p><p>调度和切换：线程上下文切换比进程上下文切换要快得多</p><h3 id="多进程和多线程"><a href="#多进程和多线程" class="headerlink" title="多进程和多线程"></a>多进程和多线程</h3><p><strong>多进程：</strong>多进程指的是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如大家可以在网易云听歌的同时打开编辑器敲代码，编辑器和网易云的进程之间不会相互干扰</p><p><strong>多线程：</strong>多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务</p><h2 id="JS-为什么是单线程"><a href="#JS-为什么是单线程" class="headerlink" title="JS 为什么是单线程"></a>JS 为什么是单线程</h2><p>JS 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>还有人说 js 还有 Worker 线程，对的，为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程是完 全受主线程控制的，而且不得操作 DOM</p><p>所以，这个标准并没有改变 JavaScript 是单线程的本质</p><p>了解了进程和线程之后，接下来看看浏览器解析，浏览器之间也是有些许差距的，不过大致是差不多的，下文我们皆用市场占有比例最大的 Chrome 为例</p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h3><p>作为前端，免不了和浏览器打交道，浏览器是多进程的，拿 Chrome 来说，我们每打开一个 Tab 页就会产生一个进程，我们使用 Chrome 打开很多标签页不关，电脑会越来越卡，不说其他，首先就很耗 CPU</p><h3 id="浏览器包含哪些进程"><a href="#浏览器包含哪些进程" class="headerlink" title="浏览器包含哪些进程"></a>浏览器包含哪些进程</h3><ul><li><p>Browser 进程</p><ul><li>浏览器的主进程(负责协调、主控)，该进程只有一个</li><li>负责浏览器界面显示，与用户交互。如前进，后退等</li><li>负责各个页面的管理，创建和销毁其他进程</li><li>将渲染(Renderer)进程得到的内存中的 Bitmap(位图)，绘制到用户界面上</li><li>网络资源的管理，下载等</li></ul></li><li><p>第三方插件进程</p><ul><li>每种类型的插件对应一个进程，当使用该插件时才创建</li></ul></li><li><p>GPU 进程</p><ul><li>该进程也只有一个，用于 3D 绘制等等</li></ul></li><li><p>渲染进程(重)</p><ul><li>即通常所说的浏览器内核(Renderer 进程，内部是多线程)</li><li>每个 Tab 页面都有一个渲染进程，互不影响</li><li>主要作用为页面渲染，脚本执行，事件处理等</li></ul></li></ul><h3 id="为什么浏览器要多进程"><a href="#为什么浏览器要多进程" class="headerlink" title="为什么浏览器要多进程"></a>为什么浏览器要多进程</h3><p>我们假设浏览器是单进程，那么某个 Tab 页崩溃了，就影响了整个浏览器，体验有多差</p><p>同理如果插件崩溃了也会影响整个浏览器</p><p>当然多进程还有其它的诸多优势，不过多阐述</p><p>浏览器进程有很多，每个进程又有很多线程，都会占用内存</p><p>这也意味着内存等资源消耗会很大，有点拿空间换时间的意思</p><p>到此可不只是为了让我们理解为何 Chrome 运行时间长了电脑会卡，哈哈，第一个重点来了</p><h3 id="简述渲染进程-Renderer-重"><a href="#简述渲染进程-Renderer-重" class="headerlink" title="简述渲染进程 Renderer(重)"></a>简述渲染进程 Renderer(重)</h3><p>页面的渲染，JS 的执行，事件的循环，都在渲染进程内执行，所以我们要重点了解渲染进程</p><p>渲染进程是多线程的，我们来看渲染进程的一些常用较为主要的线程</p><h3 id="渲染进程-Renderer-的主要线程"><a href="#渲染进程-Renderer-的主要线程" class="headerlink" title="渲染进程 Renderer 的主要线程"></a>渲染进程 Renderer 的主要线程</h3><h4 id="GUI-渲染线程"><a href="#GUI-渲染线程" class="headerlink" title="GUI 渲染线程"></a>GUI 渲染线程</h4><ul><li>负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等<ul><li>解析 html 代码(HTML 代码本质是字符串)转化为浏览器认识的节点，生成 DOM 树，也就是 DOM Tree</li><li>解析 css，生成 CSSOM(CSS 规则树)</li><li>把 DOM Tree 和 CSSOM 结合，生成 Rendering Tree(渲染树)</li></ul></li><li>当我们修改了一些元素的颜色或者背景色，页面就会重绘(Repaint)</li><li>当我们修改元素的尺寸，页面就会回流(Reflow)</li><li>当页面需要 Repaing 和 Reflow 时 GUI 线程执行，绘制页面</li><li>回流(Reflow)比重绘(Repaint)的成本要高，我们要尽量避免 Reflow 和 Repaint</li><li>GUI 渲染线程与 JS 引擎线程是互斥的<ul><li>当 JS 引擎执行时 GUI 线程会被挂起(相当于被冻结了)</li><li>GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行</li></ul></li></ul><h4 id="JS-引擎线程"><a href="#JS-引擎线程" class="headerlink" title="JS 引擎线程"></a>JS 引擎线程</h4><ul><li>JS 引擎线程就是 JS 内核，负责处理 Javascript 脚本程序(例如 V8 引擎)</li><li>JS 引擎线程负责解析 Javascript 脚本，运行代码</li><li>JS 引擎一直等待着任务队列中任务的到来，然后加以处理<ul><li>浏览器同时只能有一个 JS 引擎线程在运行 JS 程序，所以 js 是单线程运行的</li><li>一个 Tab 页(renderer 进程)中无论什么时候都只有一个 JS 线程在运行 JS 程序</li></ul></li><li>GUI 渲染线程与 JS 引擎线程是互斥的，js 引擎线程会阻塞 GUI 渲染线程<ul><li>就是我们常遇到的 JS 执行时间过长，造成页面的渲染不连贯，导致页面渲染加载阻塞(就是加载慢)</li><li>例如浏览器渲染的时候遇到<code>&lt;script&gt;</code>标签，就会停止 GUI 的渲染，然后 js 引擎线程开始工作，执行里面的 js 代码，等 js 执行完毕，js 引擎线程停止工作，GUI 继续渲染下面的内容。所以如果 js 执行时间太长就会造成页面卡顿的情况</li></ul></li></ul><h4 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h4><ul><li>属于浏览器而不是 JS 引擎，用来控制事件循环，并且管理着一个事件队列(task queue)</li><li>当 js 执行碰到事件绑定和一些异步操作(如 setTimeOut，也可来自浏览器内核的其他线程，如鼠标点击、AJAX 异步请求等)，会走事件触发线程将对应的事件添加到对应的线程中(比如定时器操作，便把定时器事件添加到定时器线程)，等异步事件有了结果，便把他们的回调操作添加到事件队列，等待 js 引擎线程空闲时来处理。</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理</li><li>因为 JS 是单线程，所以这些待处理队列中的事件都得排队等待 JS 引擎处理</li></ul><h4 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h4><ul><li><code>setInterval</code>与<code>setTimeout</code>所在线程</li><li>浏览器定时计数器并不是由 JavaScript 引擎计数的(因为 JavaScript 引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确)</li><li>通过单独线程来计时并触发定时(计时完毕后，添加到事件触发线程的事件队列中，等待 JS 引擎空闲后执行)，这个线程就是定时触发器线程，也叫定时器线程</li><li>W3C 在 HTML 标准中规定，规定要求<code>setTimeout</code>中低于 4ms 的时间间隔算为 4ms</li></ul><h4 id="异步-http-请求线程"><a href="#异步-http-请求线程" class="headerlink" title="异步 http 请求线程"></a>异步 http 请求线程</h4><ul><li>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中再由 JavaScript 引擎执行</li><li>简单说就是当执行到一个 http 异步请求时，就把异步请求事件添加到异步请求线程，等收到响应(准确来说应该是 http 状态变化)，再把回调函数添加到事件队列，等待 js 引擎线程来执行</li></ul><p>了解了上面这些基础后，接下来我们开始进入今天的正题</p><h2 id="事件循环-Event-Loop-初探"><a href="#事件循环-Event-Loop-初探" class="headerlink" title="事件循环(Event Loop)初探"></a>事件循环(Event Loop)初探</h2><p>首先要知道，JS 分为同步任务和异步任务</p><p>同步任务都在主线程(这里的主线程就是 JS 引擎线程)上执行，会形成一个<code>执行栈</code></p><p>主线程之外，事件触发线程管理着一个<code>任务队列</code>，只要异步任务有了运行结果，就在<code>任务队列</code>之中放一个事件回调</p><p>一旦<code>执行栈</code>中的所有同步任务执行完毕(也就是 JS 引擎线程空闲了)，系统就会读取<code>任务队列</code>，将可运行的异步任务(任务队列中的事件回调，只要任务队列中有事件回调，就说明可以执行)添加到执行栈中，开始执行</p><p>我们来看一段简单的代码</p><pre><code class="js">let setTimeoutCallBack = function() {  console.log(&quot;我是定时器回调&quot;)}let httpCallback = function() {  console.log(&quot;我是http请求回调&quot;)}// 同步任务console.log(&quot;我是同步任务1&quot;)// 异步定时任务setTimeout(setTimeoutCallBack, 1000)// 异步http请求任务ajax.get(&quot;/info&quot;, httpCallback)// 同步任务console.log(&quot;我是同步任务2&quot;)</code></pre><p>上述代码执行过程</p><p>JS 是按照顺序从上往下依次执行的，可以先理解为这段代码时的执行环境就是主线程，也就是也就是当前执行栈</p><p>首先，执行<code>console.log(&#39;我是同步任务1&#39;)</code></p><p>接着，执行到<code>setTimeout</code>时，会移交给<code>定时器线程</code>，通知<code>定时器线程</code> 1s 后将 <code>setTimeoutCallBack</code> 这个回调交给<code>事件触发线程</code>处理，在 1s 后<code>事件触发线程</code>会收到 <code>setTimeoutCallBack</code> 这个回调并把它加入到<code>事件触发线程</code>所管理的事件队列中等待执行</p><p>接着，执行 http 请求，会移交给<code>异步http请求线程</code>发送网络请求，请求成功后将 <code>httpCallback</code> 这个回调交由事件触发线程处理，<code>事件触发线程</code>收到 <code>httpCallback</code> 这个回调后把它加入到<code>事件触发线程</code>所管理的事件队列中等待执行</p><p>再接着执行<code>console.log(&#39;我是同步任务2&#39;)</code>1</p><p>至此主线程执行栈中执行完毕，<code>JS引擎线程</code>已经空闲，开始向<code>事件触发线程</code>发起询问，询问<code>事件触发线程</code>的事件队列中是否有需要执行的回调函数，如果有将事件队列中的回调事件加入执行栈中，开始执行回调，如果事件队列中没有回调，<code>JS引擎线程</code>会一直发起询问，直到有为止</p><p>到了这里我们发现，浏览器上的所有线程的工作都很单一且独立，非常符合单一原则</p><p>定时触发线程只管理定时器且只关注定时不关心结果，定时结束就把回调扔给事件触发线程</p><p>异步 http 请求线程只管理 http 请求同样不关心结果，请求结束把回调扔给事件触发线程</p><p>事件触发线程只关心异步回调入事件队列</p><p>而我们 JS 引擎线程只会执行执行栈中的事件，执行栈中的代码执行完毕，就会读取事件队列中的事件并添加到执行栈中继续执行，这样反反复复就是我们所谓的<strong>事件循环(Event Loop)</strong></p><p><strong>图解</strong></p><p><img src="/img/blog/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E4%B8%80%E6%AC%A1%E6%90%9E%E6%87%82JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.assets/Xnip2020-01-14_09-51-28.jpg" srcset="/img/loading.gif" alt="Xnip2020-01-14_09-51-28"></p><p>首先，执行栈开始顺序执行</p><p>判断是否为同步，异步则进入异步线程，最终事件回调给事件触发线程的任务队列等待执行，同步继续执行</p><p>执行栈空，询问任务队列中是否有事件回调</p><p>任务队列中有事件回调则把回调加入执行栈末尾继续从第一步开始执行</p><p>任务队列中没有事件回调则不停发起询问</p><h2 id="宏任务-macrotask-amp-微任务-microtask"><a href="#宏任务-macrotask-amp-微任务-microtask" class="headerlink" title="宏任务(macrotask) &amp; 微任务(microtask)"></a>宏任务(macrotask) &amp; 微任务(microtask)</h2><h3 id="宏任务-macrotask"><a href="#宏任务-macrotask" class="headerlink" title="宏任务(macrotask)"></a>宏任务(macrotask)</h3><p>在 ECMAScript 中，<code>macrotask</code>也被称为<code>task</code></p><p>我们可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)， 每一个宏任务会从头到尾执行完毕，不会执行其他</p><p>由于<code>JS引擎线程</code>和<code>GUI渲染线程</code>是互斥的关系，浏览器为了能够使<code>宏任务</code>和<code>DOM任务</code>有序的进行，会在一个<code>宏任务</code>执行结果后，在下一个<code>宏任务</code>执行前，<code>GUI渲染线程</code>开始工作，对页面进行渲染</p><pre><code class="js">宏任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ...</code></pre><p>常见的宏任务</p><ul><li>主代码块</li><li>setTimeout</li><li>setInterval</li><li>setImmediate ()-Node</li><li>requestAnimationFrame ()-浏览器</li></ul><h3 id="微任务-microtask"><a href="#微任务-microtask" class="headerlink" title="微任务(microtask)"></a>微任务(microtask)</h3><p>ES6 新引入了 Promise 标准，同时浏览器实现上多了一个<code>microtask</code>微任务概念，在 ECMAScript 中，<code>microtask</code>也被称为<code>jobs</code></p><p>我们已经知道<code>宏任务</code>结束后，会执行渲染，然后执行下一个<code>宏任务</code>， 而微任务可以理解成在当前<code>宏任务</code>执行后立即执行的任务</p><p>当一个<code>宏任务</code>执行完，会在渲染前，将执行期间所产生的所有<code>微任务</code>都执行完</p><pre><code class="js">宏任务 -&gt; 微任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ...</code></pre><p>常见微任务</p><ul><li>process.nextTick ()-Node</li><li>Promise.then()</li><li>catch</li><li>finally</li><li>Object.observe</li><li>MutationObserver</li></ul><h3 id="简单区分宏任务与微任务"><a href="#简单区分宏任务与微任务" class="headerlink" title="简单区分宏任务与微任务"></a>简单区分宏任务与微任务</h3><p>看了上述宏任务微任务的解释你可能还不太清楚，没关系，往下看，先记住那些常见的宏微任务即可</p><p>我们通过几个例子来看，这几个例子思路来自掘金<code>云中君</code>的文章参考链接【14】，通过渲染背景颜色来区分宏任务和微任务，很直观，我觉得很有意思，所以这里也用这种例子</p><p>找一个空白的页面，在 console 中输入以下代码</p><pre><code class="js">document.body.style = &quot;background:black&quot;document.body.style = &quot;background:red&quot;document.body.style = &quot;background:blue&quot;document.body.style = &quot;background:pink&quot;</code></pre><p>![Jan-12-2020 01-05-49](「硬核 JS」一次搞懂 JS 运行机制.assets/Jan-12-2020 01-05-49.gif)</p><p>我们看到上面动图背景直接渲染了粉红色，根据上文里讲浏览器会先执行完一个宏任务，再执行当前执行栈的所有微任务，然后移交 GUI 渲染，上面四行代码均属于同一次宏任务，全部执行完才会执行渲染，渲染时<code>GUI线程</code>会将所有 UI 改动优化合并，所以视觉上，只会看到页面变成粉红色</p><p>再接着看</p><pre><code class="js">document.body.style = &quot;background:blue&quot;setTimeout(() =&gt; {  document.body.style = &quot;background:black&quot;}, 200)</code></pre><p>![Jan-12-2020 01-28-41](「硬核 JS」一次搞懂 JS 运行机制.assets/Jan-12-2020 01-28-41.gif)</p><p>上述代码中，页面会先卡一下蓝色，再变成黑色背景，页面上写的是 200 毫秒，大家可以把它当成 0 毫秒，因为 0 毫秒的话由于浏览器渲染太快，录屏不好捕捉，我又没啥录屏慢放的工具，大家可以自行测试的，结果也是一样，最安全的方法是写一个<code>index.html</code>文件，在这个文件中插入上面的 js 脚本，然后浏览器打开，谷歌下使用控制台中<code>performance</code>功能查看一帧一帧的加载最为恰当，不过这样录屏不好录所以。。。</p><p>回归正题，之所以会卡一下蓝色，是因为以上代码属于两次<code>宏任务</code>，第一次<code>宏任务</code>执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次宏任务将背景变成黑色</p><p>再来看</p><pre><code class="js">document.body.style = &quot;background:blue&quot;console.log(1)Promise.resolve().then(() =&gt; {  console.log(2)  document.body.style = &quot;background:pink&quot;})console.log(3)</code></pre><p>![Jan-12-2020 01-31-42](「硬核 JS」一次搞懂 JS 运行机制.assets/Jan-12-2020 01-31-42.gif)</p><p>控制台输出 1 3 2 , 是因为 promise 对象的 then 方法的回调函数是异步执行，所以 2 最后输出</p><p>页面的背景色直接变成粉色，没有经过蓝色的阶段，是因为，我们在宏任务中将背景设置为蓝色，但在进行渲染前执行了微任务， 在微任务中将背景变成了粉色，然后才执行的渲染</p><h3 id="微任务宏任务注意点"><a href="#微任务宏任务注意点" class="headerlink" title="微任务宏任务注意点"></a>微任务宏任务注意点</h3><ul><li><p>浏览器会先执行一个宏任务，紧接着执行当前执行栈产生的微任务，再进行渲染，然后再执行下一个宏任务</p><p>微任务和宏任务不在一个任务队列，不在一个任务队列</p><ul><li>例如<code>setTimeout</code>是一个宏任务，它的事件回调在宏任务队列，<code>Promise.then()</code>是一个微任务，它的事件回调在微任务队列，二者并不是一个任务队列</li><li>以 Chrome 为例，有关渲染的都是在渲染进程中执行，渲染进程中的任务（DOM 树构建，js 解析…等等）需要主线程执行的任务都会在主线程中执行，而浏览器维护了一套事件循环机制，主线程上的任务都会放到消息队列中执行，主线程会循环消息队列，并从头部取出任务进行执行，如果执行过程中产生其他任务需要主线程执行的，渲染进程中的其他线程会把该任务塞入到消息队列的尾部，消息队列中的任务都是宏任务</li><li>微任务是如何产生的呢？当执行到 script 脚本的时候，js 引擎会为全局创建一个执行上下文，在该执行上下文中维护了一个微任务队列，当遇到微任务，就会把微任务回调放在微队列中，当所有的 js 代码执行完毕，在退出全局上下文之前引擎会去检查该队列，有回调就执行，没有就退出执行上下文，这也就是为什么微任务要早于宏任务，也是大家常说的，每个宏任务都有一个微任务队列（由于定时器是浏览器的 API，所以定时器是宏任务，在 js 中遇到定时器会也是放入到浏览器的队列中）</li></ul></li></ul><p>此时，你可能还很迷惑，没关系，请接着往下看</p><h3 id="图解宏任务和微任务"><a href="#图解宏任务和微任务" class="headerlink" title="图解宏任务和微任务"></a>图解宏任务和微任务</h3><p><img src="/img/blog/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E4%B8%80%E6%AC%A1%E6%90%9E%E6%87%82JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.assets/Xnip2020-01-14_00-58-17.jpg" srcset="/img/loading.gif" alt="Xnip2020-01-14_00-58-17"></p><p>首先执行一个宏任务，执行结束后判断是否存在微任务</p><p>有微任务先执行所有的微任务，再渲染，没有微任务则直接渲染</p><p>然后再接着执行下一个宏任务</p><h2 id="图解完整的-Event-Loop"><a href="#图解完整的-Event-Loop" class="headerlink" title="图解完整的 Event Loop"></a>图解完整的 Event Loop</h2><p><img src="/img/blog/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E4%B8%80%E6%AC%A1%E6%90%9E%E6%87%82JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.assets/Xnip2020-01-14_17-20-44.jpg" srcset="/img/loading.gif" alt="Xnip2020-01-14_17-20-44"></p><p>首先，整体的 script(作为第一个宏任务)开始执行的时候，会把所有代码分为<code>同步任务</code>、<code>异步任务</code>两部分</p><p>同步任务会直接进入主线程依次执行</p><p>异步任务会再分为宏任务和微任务</p><p>宏任务进入到 Event Table 中，并在里面注册回调函数，每当指定的事件完成时，Event Table 会将这个函数移到 Event Queue 中</p><p>微任务也会进入到另一个 Event Table 中，并在里面注册回调函数，每当指定的事件完成时，Event Table 会将这个函数移到 Event Queue 中</p><p>当主线程内的任务执行完毕，主线程为空时，会检查微任务的 Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务</p><p>上述过程会不断重复，这就是 Event Loop，比较完整的事件循环</p><h2 id="关于-Promise"><a href="#关于-Promise" class="headerlink" title="关于 Promise"></a>关于 Promise</h2><p><code>new Promise(() =&gt; {}).then()</code> ，我们来看这样一个 Promise 代码</p><p>前面的 <code>new Promise()</code> 这一部分是一个构造函数，这是一个同步任务</p><p>后面的 <code>.then()</code> 才是一个异步微任务，这一点是非常重要的</p><pre><code class="js">new Promise(resolve =&gt; {  console.log(1)  resolve()}).then(() =&gt; {  console.log(2)})console.log(3)</code></pre><p>上面代码输出<code>1 3 2</code></p><h2 id="关于-async-await-函数"><a href="#关于-async-await-函数" class="headerlink" title="关于 async/await 函数"></a>关于 async/await 函数</h2><p>async/await 本质上还是基于 Promise 的一些封装，而 Promise 是属于微任务的一种</p><p>所以在使用 await 关键字与 Promise.then 效果类似</p><pre><code class="js">setTimeout(() =&gt; console.log(4))async function test() {  console.log(1)  await Promise.resolve()  console.log(3)}test()console.log(2)</code></pre><p>上述代码输出<code>1 2 3 4</code></p><p>可以理解为，<code>await</code> 以前的代码，相当于与 <code>new Promise</code> 的同步代码，<code>await</code> 以后的代码相当于 <code>Promise.then</code>的异步</p><h2 id="举栗印证"><a href="#举栗印证" class="headerlink" title="举栗印证"></a>举栗印证</h2><p>首先给大家来一个比较直观的动图</p><p>![Jan-14-2020 00-03-22](「硬核 JS」一次搞懂 JS 运行机制.assets/Jan-14-2020 00-03-22.gif)</p><p>之所以放这个动图，就是为了向大家推荐这篇好文，动图录屏自参考链接【1】</p><p>极力推荐大家看看这篇帖子，非常 nice，分步动画生动且直观，有时间的话可以自己去体验下</p><p>不过在看这个帖子之前你要先了解下运行机制会更好读懂些</p><p>接下来这个来自网上随意找的一个比较简单的面试题，求输出结果</p><pre><code class="js">function test() {  console.log(1)  setTimeout(function() {    // timer1    console.log(2)  }, 1000)}test()setTimeout(function() {  // timer2  console.log(3)})new Promise(function(resolve) {  console.log(4)  setTimeout(function() {    // timer3    console.log(5)  }, 100)  resolve()}).then(function() {  setTimeout(function() {    // timer4    console.log(6)  }, 0)  console.log(7)})console.log(8)</code></pre><p>结合我们上述的 JS 运行机制再来看这道题就简单明了的多了</p><p>JS 是顺序从上而下执行</p><p>执行到 test()，test 方法为同步，直接执行，<code>console.log(1)</code>打印 1</p><p>test 方法中 setTimeout 为异步宏任务，回调我们把它记做 timer1 放入宏任务队列</p><p>接着执行，test 方法下面有一个 setTimeout 为异步宏任务，回调我们把它记做 timer2 放入宏任务队列</p><p>接着执行 promise，new Promise 是同步任务，直接执行，打印 4</p><p>new Promise 里面的 setTimeout 是异步宏任务，回调我们记做 timer3 放到宏任务队列</p><p>Promise.then 是微任务，放到微任务队列</p><p>console.log(8)是同步任务，直接执行，打印 8</p><p>主线程任务执行完毕，检查微任务队列中有 Promise.then</p><p>开始执行微任务，发现有 setTimeout 是异步宏任务，记做 timer4 放到宏任务队列</p><p>微任务队列中的 console.log(7)是同步任务，直接执行，打印 7</p><p>微任务执行完毕，第一次循环结束</p><p>检查宏任务队列，里面有 timer1、timer2、timer3、timer4，四个定时器宏任务，按照定时器延迟时间得到可以执行的顺序，即 Event Queue：timer2、timer4、timer3、timer1，依次拿出放入执行栈末尾执行<strong>(插播一条：浏览器 event loop 的 Macrotask queue，就是宏任务队列在每次循环中只会读取一个任务)</strong></p><p>执行 timer2，console.log(3)为同步任务，直接执行，打印 3</p><p>检查没有微任务，第二次 Event Loop 结束</p><p>执行 timer4，console.log(6)为同步任务，直接执行，打印 6</p><p>检查没有微任务，第三次 Event Loop 结束</p><p>执行 timer3，console.log(5)同步任务，直接执行，打印 5</p><p>检查没有微任务，第四次 Event Loop 结束</p><p>执行 timer1，console.log(2)同步任务，直接执行，打印 2</p><p>检查没有微任务，也没有宏任务，第五次 Event Loop 结束</p><p>结果：1，4，8，7，3，6，5，2</p><h2 id="提一下-NodeJS-中的运行机制"><a href="#提一下-NodeJS-中的运行机制" class="headerlink" title="提一下 NodeJS 中的运行机制"></a>提一下 NodeJS 中的运行机制</h2><p>上面的一切都是针对于浏览器的 EventLoop</p><p>虽然 NodeJS 中的 JavaScript 运行环境也是 V8，也是单线程，但是，还是有一些与浏览器中的表现是不一样的</p><p>其实 nodejs 与浏览器的区别，就是 nodejs 的宏任务分好几种类型，而这好几种又有不同的任务队列，而不同的任务队列又有顺序区别，而微任务是穿插在每一种宏任务之间的</p><p>在 node 环境下，process.nextTick 的优先级高于 Promise，可以简单理解为在宏任务结束后会先执行微任务队列中的 nextTickQueue 部分，然后才会执行微任务中的 Promise 部分</p><p><img src="/img/blog/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E4%B8%80%E6%AC%A1%E6%90%9E%E6%87%82JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.assets/Xnip2020-01-18_14-50-01.jpg" srcset="/img/loading.gif" alt="Xnip2020-01-18_14-50-01"></p><p>上图来自 NodeJS 官网</p><p>如上图所示，nodejs 的宏任务分好几种类型，我们只简单介绍大体内容了解，不详细解释，不然又是啰哩啰嗦一大篇</p><p>NodeJS 的 Event Loop 相对比较麻烦</p><pre><code class="js">Node会先执行所有类型为 timers 的 MacroTask，然后执行所有的 MicroTask(NextTick例外)进入 poll 阶段，执行几乎所有 MacroTask，然后执行所有的 MicroTask再执行所有类型为 check 的 MacroTask，然后执行所有的 MicroTask再执行所有类型为 close callbacks 的 MacroTask，然后执行所有的 MicroTask至此，完成一个 Tick，回到 timers 阶段……如此反复，无穷无尽……</code></pre><p>反观浏览器中 Event Loop 就比较容易理解</p><pre><code class="js">先执行一个 MacroTask，然后执行所有的 MicroTask再执行一个 MacroTask，然后执行所有的 MicroTask……如此反复，无穷无尽……</code></pre><p>好了，关于 Node 中各个类型阶段的解析，这里就不过多说明了，自己查阅资料吧，这里就是简单提一下，NodeJS 的 Event Loop 解释起来比浏览器这繁杂，这里就只做个对比</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>上面的流程图都是自己画的，所以有点 low，见谅</p><p>水平有限，欢迎指错</p><p>码字不易，看完对你有帮助请点赞，有疑问请评论提出</p><p>最近拾起了一个被冻结的公众号，又重新搞了下</p><p>欢迎大家关注【不正经的前端】，加我，加群，或者拿一些资料都可以的，时不时发一些优质原创</p><p><img src="/img/blog/%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E4%B8%80%E6%AC%A1%E6%90%9E%E6%87%82JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.assets/%E7%A8%BF%E5%AE%9A%E8%AE%BE%E8%AE%A1%E5%AF%BC%E5%87%BA-20200111-143924.png" srcset="/img/loading.gif" alt="稿定设计导出-20200111-143924"></p><blockquote><p>参考</p><ol><li><p><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules - 重点推荐阅读</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/32751855" target="_blank" rel="noopener">聊聊 JavaScript 与浏览器的那些事 - 引擎与线程</a></p></li><li><p><a href="https://www.cnblogs.com/lhb25/p/how-browsers-work.html" target="_blank" rel="noopener">前端文摘：深入解析浏览器的幕后工作原理</a></p></li><li><p><a href="https://www.imweb.io/topic/58e3bfa845e5c13468f567d5" target="_blank" rel="noopener">浏览器进程？线程？傻傻分不清楚！</a></p></li><li><p><a href="https://www.cnblogs.com/iovec/p/7904416.html" target="_blank" rel="noopener">从输入 cnblogs.com 到博客园首页完全展示发生了什么</a></p></li><li><p><a href="https://www.cnblogs.com/wyaocn/p/5761163.html" target="_blank" rel="noopener">前端必读：浏览器内部工作原理</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2013/10/event_loop.html" target="_blank" rel="noopener">什么是 Event Loop？</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈 Event Loop</a></p></li><li><p><a href="https://blog.csdn.net/u012134199/article/details/46290465" target="_blank" rel="noopener">单线程与多线程的区别</a></p></li><li><p><a href="https://blog.csdn.net/qiuchangjun/article/details/79761242" target="_blank" rel="noopener">浏览器进程/线程模型及 JS 运行机制</a></p></li><li><p><a href="https://www.jianshu.com/p/1e455a9226ce" target="_blank" rel="noopener">浏览器的运行机制—2.浏览器都包含哪些进程？</a></p></li><li><p><a href="https://segmentfault.com/a/1190000004292479" target="_blank" rel="noopener">JS 一定要放在 Body 的最底部么？聊聊浏览器的渲染机制</a></p></li><li><p><a href="https://juejin.im/post/5a6547d0f265da3e283a1df7#heading-25" target="_blank" rel="noopener">从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理</a></p></li><li><p><a href="https://juejin.im/post/5d5b4c2df265da03dd3d73e5#heading-4" target="_blank" rel="noopener">「前端进阶」从多线程到 Event Loop 全面梳理</a></p></li><li><p><a href="https://segmentfault.com/a/1190000013119813" target="_blank" rel="noopener">Js 基础知识（四） - js 运行原理与机制</a></p></li><li><p><a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">这一次，彻底弄懂 JavaScript 执行机制</a></p></li><li><p><a href="https://juejin.im/post/5b543e26e51d4518f54404e4" target="_blank" rel="noopener">前端性能优化：细说浏览器渲染的重排与重绘</a></p></li><li><p><a href="https://juejin.im/post/5d136700f265da1b7c6128db" target="_blank" rel="noopener">10 分钟看懂浏览器的渲染过程及优化</a></p></li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>硬核JS系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个前端的安利</title>
    <link href="/blog/2019/12/23/else/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9/"/>
    <url>/blog/2019/12/23/else/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="一个前端的安利"><a href="#一个前端的安利" class="headerlink" title="一个前端的安利"></a>一个前端的安利</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此文安利内容皆是我在使用的，我之所用，皆为精品，哈哈，并不是胡乱分享，觉得十分好用，就分享下，所以虽有花哨，却也实用</p><h2 id="Chrome-插件"><a href="#Chrome-插件" class="headerlink" title="Chrome 插件"></a>Chrome 插件</h2><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>作为一个正八经的前端，与 chrome 打交道必不可少，chrome 扩展程序有很多，实用且好玩，之前有段不务正业的时光，每天闲下来就喜欢找各种扩展，看着好玩就安装使用，不好用就卸载，后来还去看了看 chrome 扩展开发，还写了几个小扩展 demo，学习技术的动力是升职加薪，是不被淘汰，并不是不喜欢，只是技术是饭碗，所以久而久之，学习技术变成了理所当然，但是插件脚本这些花里胡哨的则是兴趣，接下来为大家安利我目前觉得很 nice 的几款 chrome 扩展</p><h3 id="No-1-GoogleHelper"><a href="#No-1-GoogleHelper" class="headerlink" title="No.1 GoogleHelper"></a>No.1 GoogleHelper</h3><p>谷歌上网助手，我就以 Helper 简称了，Helper 是专门为科研、外贸、跨境电商、海淘人员、开发人员服务的上网加速工具，chrome 内核浏览器专用!可以解决 chrome 扩展无法自动更新的问题，同时可&gt;以访问谷歌 google 搜索，gmail 邮箱，google+等谷歌产品</p><p>上面是官方解释，通俗来说，我们是不能访问谷歌的，需要翻墙，我们访问外网大多数其实只是使用谷歌搜索，或者是看国外的一些网站，翻墙好麻烦，作为 21 世纪有志青年，我们响应祖国的号召，科学文明上网，我们不翻墙，通过 helper 这个浏览器插件就可以让我们访问谷歌，查看外网的一些资源，这就足够了</p><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><p>安装谷歌插件没有翻墙的情况下我们我们进不去谷歌商店</p><p>所以可以直接搜索这个插件的官网下载 <a href="http://googlehelper.net/" target="_blank" rel="noopener">GoogleHelper 传送门</a></p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191221105008522.png" srcset="/img/loading.gif" alt="image-20191221105008522"></p><p>如上所示，直接下载即可</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>2018 年 6 月 13 日起,谷歌最新的 Chrome 7 不再支持 CRX 手动安装方法，这样导致国内用户无法顺利安装 Chrome 扩展，大陆用户又无法访问 Chrome 应用商店，Helper 提供了源码安装方式</p><p>这样导致国内用户无法顺利安装 Chrome 扩展</p><p>大陆用户又无法访问 Chrome 应用商店</p><p>它提供了源码安装方式</p><p><strong>1.</strong> 打开你的 Chrome 浏览器的 更多工具&gt;扩展程序页面 ， 或者直接在网址输入: chrome://extensions/</p><p>*<em>2. *</em>在扩展程序右上角打开开发者选项，然后在此页面左上角点击 “添加已解压的扩展程序”</p><p>*<em>3. *</em>选择刚下载包里的 <code>ghelper_source</code> 目录</p><p>*<em>4. *</em>确认后就行了，装上源码包方式后，先登录，没有账号就注册下，免费的</p><p><strong>5.</strong> 最后回到第一步，进扩展程序页面，找到 helper 插件，点击插件详情，找到 <code>允许访问文件网址</code> 选项勾选同意</p><p><strong>6.</strong> 然后就能愉快访问谷歌了</p><h5 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h5><p>我也用过其他的 chrome 上网加速插件，但是一番对比下来，还是 helper 好用</p><h3 id="No-2-OneTab-amp-OneTab-Plus"><a href="#No-2-OneTab-amp-OneTab-Plus" class="headerlink" title="No.2 OneTab &amp; OneTab Plus"></a>No.2 OneTab &amp; OneTab Plus</h3><p>你是否经常因为打开的标签页太多，过于混乱而感到头疼，作为一个前端，每天打开无数的标签，有的是开发预览，有的是技术博客，管理起来是很麻烦的</p><p>OneTab Plus，一秒上手的傻瓜式操作，轻松管理所有标签页</p><p>之前我是使用 OneTab 的，很简洁，就是不太好看，后来看到了 OneTab Plus，OneTab Plus 毕竟是出自 Infinity 的产品，审美一直都是在线</p><p>安装的话，有了上面的 helper 插件，我们就可以直接在谷歌商店中搜索扩展安装了</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191221114152092.png" srcset="/img/loading.gif" alt="image-20191221114152092"></p><p>点击添加至 chrome 即可一键安装</p><p>支持的功能有很多，整合标签组，分类归档等等，界面干净整洁，这里不介绍使用了，就是傻瓜式操作，安装一试便知</p><p>可能有些人觉得这种管理标签的插件不是必要的，但是我觉得不妨安装试一试，还是很香的</p><h3 id="No-3-FeHelper"><a href="#No-3-FeHelper" class="headerlink" title="No.3 FeHelper"></a>No.3 FeHelper</h3><p>FeHelper 中文名为 WEB 前端助手，All In One 的一个工具，包含多个独立小应用，比如：Json 工具、代码美化、代码压缩、二维码、Postman、markdown、网页油猴、便签笔记、信息加密与解密、随机密码生成、Crontab 等等</p><p>如下图</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191221140814282.png" srcset="/img/loading.gif" alt="image-20191221140814282"></p><p>FeHelper 的这些功能都很常用，总的来说，说是前端必备神器也不为过，所以强烈推荐，装上它还是很有用的</p><p>安装的话也同上，有了 helper 后直接去谷歌商店搜索 FeHelper 安装即可，使用简单，自己摸索吧</p><p>下图为商店中 FeHelper</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191221141220058.png" srcset="/img/loading.gif" alt="image-20191221141220058"></p><h3 id="No-4-Vimium"><a href="#No-4-Vimium" class="headerlink" title="No.4 Vimium"></a>No.4 Vimium</h3><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>Vimium 是 Vim 和 Chromium 的结合，Vim 是 linux 中让你脱离鼠标编辑文本的利器，同样 Vimium 是让你脱离鼠标就能上网的终极利器，不用移动鼠标就能跳转页面，切换标签，打开历史记录，打开书签等等，这比传统的鼠键结合的方式要快得多</p><p>总之，Vimium 是极客必备，它可以让我们在浏览器中解放鼠标，效率与装逼集为一体，优雅而酷炫</p><p>作为一个经常和浏览器打交道的前端，这东西用之后有如神助，就很棒，极力推荐前端开发们使用，所以文中会细致介绍下</p><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><p>安装也同上，都是浏览器扩展插件嘛，有了 helper 后直接去谷歌商店搜索 Vimium 一键添加即可，就是下图这个</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191221144435965.png" srcset="/img/loading.gif" alt="image-20191221144435965"></p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>首先确保安装成功，浏览器地址栏右侧已经有了小图标</p><p>我们在浏览器打开一个新的标签页，搜索 vimium 回车，按下<code>f</code>键，当前页面的所有链接处都会分配快捷键，这也是最常用的 vimium 快捷键，效果如下图</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191221155430821.png" srcset="/img/loading.gif" alt="image-20191221155430821"></p><p>分配的快捷键最多两个字符，也就是说我们最多只需按三下键盘，无需鼠标，想去哪就去哪</p><p>我们想要搜索内容时，只需按下<code>o</code>键，输入内容即可看到结果，同地址栏搜索一样方便简洁，想要在新标签页打开只需按下大写的<code>O</code>，搜索界面如下</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222234639120.png" srcset="/img/loading.gif" alt="image-20191222234639120"></p><p>我是一个喜欢把看到的好帖子收藏下来的人，所有收藏我都存在了谷歌书签，我自认为我的标签分类也算比较细致了，如下图</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191221161303845.png" srcset="/img/loading.gif" alt="image-20191221161303845"></p><p>但是久而久之，收藏的东西太多了，不好查找，Vimium 可以非常方便的帮我们查找标签页的内容</p><p>只需按下<code>b</code>键，即可模糊搜索收藏的标签页内容，界面效果和<code>o</code>键搜索一致，大写<code>B</code>键也是在新标签页打开，相信对喜欢收藏帖子加标签的人来说很实用，如下图</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222234855365.png" srcset="/img/loading.gif" alt="image-20191222234855365"></p><h5 id="快捷键一览"><a href="#快捷键一览" class="headerlink" title="快捷键一览"></a>快捷键一览</h5><p>愉快的使用 Vimium，下面这些快捷键必不可少，使用过 Linux 的 vim 的同学会感到毫无压力，没有使用过的同学记住常用的就 OK 了，当然这些快捷键都可以更改，但是建议不要更改，用熟后 linux 的 vim 也是这些操作</p><pre><code class="js">j：        向下细微滚动窗口k：        向上细微滚动窗口J：        (Shift+j的意思，以下大写全部表示加Shift) 下一个标签页K：        上一个标签页d：        向下滚动半个屏幕u：        向上移动半个屏幕g+g：    同连续按两下g，回到顶部G：        到达页面底部H：        后退L：        前进f：        将当前网页上的所有可见链接/输入框分配一个快捷键，输入后就可以打开或者跳转到对应的输入框F：        同f，只不过是将在新窗口中打开页面g+i：    将光标 定位到输入框，如果有多个可以按Tab键切换b：        搜索书签，当前页面打开B：        搜索书签，新标签页打开x：        关闭当前页面X：        恢复刚刚关闭的页面o：        相当于Chrome中的地址栏，搜索并在当前窗口打开，Chrome在全屏时也可使用O：        同o，只不过是可以在新窗口中打开，很nice，Chrome在全屏时也可使用g+s：    查看网页的源代码r：        重新载入当前网页</code></pre><p><strong>注：</strong>浏览器自有页面该插件不可用，如控制台、默认的新标签页等等</p><h5 id="最后-1"><a href="#最后-1" class="headerlink" title="最后"></a>最后</h5><p>没什么可说的，真是装逼神器，赶紧安装试试，安装后你可以尝试下不使用鼠标，仅使用键盘给这篇帖子评论个消息或者点个赞 😄</p><h3 id="No-5-Saladict"><a href="#No-5-Saladict" class="headerlink" title="No.5 Saladict"></a>No.5 Saladict</h3><p>Saladict 沙拉查词是一款专业划词翻译扩展，为交叉阅读而生。大量权威词典涵盖中英日韩法德西语，支持复杂的划词操作、网页翻译、生词本与 PDF 浏览</p><p>以上是官方解释，我认为，它的划词翻译最好，在浏览器中我们阅读外文，你是不是经常点谷歌翻译，谷歌翻译把整个网页翻译为中文，这样做我认为不太好，经常这样搞，英文水平永远也提不上去，而划词翻译不同，我们可以尝试阅读英文文档，遇到不会的直接选中单词或句子进行翻译，慢慢的英文水准就会有所提高</p><p>对比其他划词翻译插件我选择 Saladict 的原因有两点</p><p>1.界面相对漂亮，使用方便，作为前端，我认为它的交互体验非常 nice</p><p>2.多渠道翻译更为精确</p><p>如下图所示</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191221200333962.png" srcset="/img/loading.gif" alt="image-20191221200333962"></p><p>我们选中一句话或者一个单词，就会在对应位置自动弹出一个小图标，点击图标即可弹出对应多版本的翻译，使用及其方便，更多功能可安装后自行体验</p><p>沙拉查词的功能也很多，不过我只用这一个简单翻译的功能，想了解更多可以查看 saladict 的官方文档<a href="https://saladict.crimx.com/manual.html" target="_blank" rel="noopener">saladict 传送门</a></p><p>安装方式还是从谷歌商店搜索 Saladict 一键安装即可，该插件如下</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191221220245249.png" srcset="/img/loading.gif" alt="image-20191221220245249"></p><h3 id="No-6-Octotree"><a href="#No-6-Octotree" class="headerlink" title="No.6 Octotree"></a>No.6 Octotree</h3><p>Octotree 是一款针对 github 的插件，通常我们在浏览 github 时查看一个文件要进去，想查看其他文件就要返回在点入文件，比较麻烦，安装此插件，在我们浏览 github 时，它会为我们生成一个树形结构的侧边栏，这样我们在查看 github 项目时就不用点入点出，极为方便，如下图</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191221221253478.png" srcset="/img/loading.gif" alt="image-20191221221253478"></p><p>此插件功能强大，但是如要使用更多功能，就需收费了，这点我觉得不太好，不过我们在不注册会员的情况下也可以使用它的树状侧边栏，如果你只需一个方便的侧边栏，那使用它就再好不过了</p><p>安装同上，谷歌商店中搜索扩展名 Octotree，如下图，一键安装使用</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191221221700133.png" srcset="/img/loading.gif" alt="image-20191221221700133"></p><h3 id="No-7-Sourcegraph"><a href="#No-7-Sourcegraph" class="headerlink" title="No.7 Sourcegraph"></a>No.7 Sourcegraph</h3><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p>Sourcegraph 又是一款为 github 而生的强大插件，它是一款可以为 Github 上的代码添加了即时文档和类型提示，并为每一个标识符添加了跳转到定义处的链接的 Chrome 扩展，它允许你像使用一个很好的 IDE 那样浏览源代码</p><p>我们看官方对它的解释</p><p>你可以从代码仓库和安装包甚至是函数里搜索代码，同时也可以直接点击被完全创建了链接的代码来阅读文档、跳转到变量定义或者马上找到可用的 Demo。总而言之，你可以在你的 web 浏览器上完成这一切，而不需要配置任何编辑器。由 Sourcegraph 出品的这款 Chrome 插件，可以非常方便的浏览和搜索 Github 上的代码，持跨 repository 搜索、跳转到定义、查找引用等功能，宛若一个功能强大的 IDE。核心功能如跳转到定义(Go-to-definition)——浏览文件或查看 pull 请求时，将鼠标悬停在代码上可以查看文档提示，单击即可跳转到定义、查找引用或全文搜索</p><p>可能有人还是不了解它的强大，这样说吧，我们把 github 的项目克隆下来，在 VSCode 打开查看，和直接在 github 上打开感觉如何，这根本就不用比较，github 上浏览项目代码很不方便，你只能像看文档一样查看，就像一个函数，我们要找这个函数定义所在，编译器里 command+鼠标左击直接就进入函数内部了，github 上是肯定不行的，而 Sourcegraph 可以帮你办到，说它是一款极简的线上 IDE 也不为过</p><h5 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h5><p>安装如上一样，谷歌商店搜索扩展 Sourcegraph 安装即可，如下即是</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191221223305327.png" srcset="/img/loading.gif" alt="image-20191221223305327"></p><h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><p>安装好该插件后，我们再打开 github 项目，就会看到项目中出现了一个图标如下</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191221223418443.png" srcset="/img/loading.gif" alt="image-20191221223418443"></p><p>点击该图标即可体验在线 IDE 的强大，它可以为我们浏览 github 优秀项目提供很大的助力</p><p>点击图标后进入界面如下</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191221223552397.png" srcset="/img/loading.gif" alt="image-20191221223552397"></p><p>可能到了这里，有人会问，既然有 Sourcegraph，那还要 Octotree 何用，Octotree 的侧边栏，Sourcegraph 也有</p><h5 id="Octotree-VS-Sourcegraph"><a href="#Octotree-VS-Sourcegraph" class="headerlink" title="Octotree VS Sourcegraph"></a>Octotree VS Sourcegraph</h5><p>Octotree 不需要跳转页面，就在 github 当前页面生成侧边栏，点击也是跳到对应的 github 地址下，使用极为方便，而 Sourcegraph 不同，它功能太过强大，所以打开会跳转到 Sourcegraph.com 上，打开速度和体验会稍稍有些不好，但是胜在功能强大</p><p>其实我之所以装两个，原因很简单，因为两者都可以用的上，一般我只是简单查看 github 项目时会使用 Octotree，比较快捷，但是我想要深究其中一些内容，又不想克隆到本地时，会使用 Sourcegraph，因为它更强大，函数查找，跳转定义简直不要太爽</p><p>有人可能说装这么多插件就算了，功能重叠的也装，这不是要累死谷歌，不急，看完你就知道了，咱有对策</p><h3 id="No-8-GitZip"><a href="#No-8-GitZip" class="headerlink" title="No.8 GitZip"></a>No.8 GitZip</h3><p>GitZip，全名为 GitZip for github，又是一款 github 神器，只要我们经常混迹 github，那么它就更不可或缺了</p><p>我们都知道，要克隆一个仓库中的文件，我们要把整个仓库克隆下来，这点很不爽，毕竟一个仓库这么大，可能我只需要其中一两个文件，全部克隆过于麻烦</p><p>GitZip，有了它，你就不必烦恼这个问题</p><h5 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h5><p>谷歌应用商店中搜索 GitZip，点击添加扩展即可，如下</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191221225332815.png" srcset="/img/loading.gif" alt="image-20191221225332815"></p><h5 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h5><p>找到一个 github 项目，这里以 vue 为例，我只想下载 vue 项目中的 src 文件夹，双击选中即可，如下图</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191221225536343.png" srcset="/img/loading.gif" alt="image-20191221225536343"></p><p>我们只需要双击选中想要下载的文件夹或文件，左侧会出现对号代表选中，网页右下角会出现下载的箭头图标，我们点击箭头，即可打包下载选中文件</p><p>第一次使用此插件时，内心真的是翻江倒海，虽然功能并不强大，这个小功能正是我所需要的</p><h3 id="No-9-GitHub-Hovercard"><a href="#No-9-GitHub-Hovercard" class="headerlink" title="No.9 GitHub Hovercard"></a>No.9 GitHub Hovercard</h3><h5 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h5><p>GitHub Hovercard，一听名字就又是一款 github 相关的插件，它的作用是-&gt;鼠标悬停快速预览</p><p>浏览 Github 时我们浏览一个项目、一个用户的信息、或者一个 issue，只能点击进去查看详情，如果经常浏览 github 的话，就有些麻烦了</p><p>GitHub Hovercard 这个插件可以让我们快速浏览项目信息/用户信息/项目讨论，只需要把鼠标悬停在想要查看的用户|项目|issue 上就可以查看了，十分方便</p><h5 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h5><p>下面是使用的一些截图</p><p>悬停在项目上时如下</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222011553442.png" srcset="/img/loading.gif" alt="image-20191222011553442"></p><p>悬停在用户上时如下</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222011743118.png" srcset="/img/loading.gif" alt="image-20191222011743118"></p><p>悬停在 issue 上时</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222011925152.png" srcset="/img/loading.gif" alt="image-20191222011925152"></p><p>悬浮在提交记录上时</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222012141465.png" srcset="/img/loading.gif" alt="image-20191222012141465"></p><p>总之，该插件对我们快速浏览项目帮助很大，我们每次要看一个详细信息就不用点击进去了，非常方便</p><h5 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a>安装</h5><p>谷歌商店搜索扩展名 GitHub Hovercard 添加至扩展即可，该插件如下</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222012618349.png" srcset="/img/loading.gif" alt="image-20191222012618349"></p><h3 id="No-10-React-Developer-Tools"><a href="#No-10-React-Developer-Tools" class="headerlink" title="No.10 React Developer Tools"></a>No.10 React Developer Tools</h3><p>React Developer Tools 这个就不介绍了，React 调试插件，前端都知道</p><h3 id="No-11-Vue-js-devtools"><a href="#No-11-Vue-js-devtools" class="headerlink" title="No.11 Vue.js devtools"></a>No.11 Vue.js devtools</h3><p>Vue.js devtools 同 React Developer Tools 一样，vue 调试插件，都是开发必备的，作为前端应该都知道，不介绍了</p><h3 id="No-12-Postman"><a href="#No-12-Postman" class="headerlink" title="No.12 Postman"></a>No.12 Postman</h3><p>没错，就是 postman，之所以安装 postman 浏览器扩展，就是不想装 Postman 桌面程序</p><p>不要装错呦，看下图</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222181152773.png" srcset="/img/loading.gif" alt="image-20191222181152773"></p><p>要安装地球 logo 的这款</p><p>网页中使用该扩展的界面如下</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222181256454.png" srcset="/img/loading.gif" alt="image-20191222181256454"></p><p>使用就不介绍了，大家都会用</p><h3 id="No-13-掘金"><a href="#No-13-掘金" class="headerlink" title="No.13 掘金"></a>No.13 掘金</h3><p>掘金 chrome 扩展插件，大家在掘金首页上应该见过它，在那下载安装就成</p><p>为什么推荐它呢，可能有些人看到过它，只不过没注意，我之前偶尔空闲，看了一下官方的介绍，觉得好用，就装了，装之后体验非常棒，就一直留着了，功能很实用，界面很简洁</p><p>它会在你打开一个新的标签页时打开掘金插件定制好的内容聚合页面，你依然可以在地址栏搜索内容，不过映入眼帘的不再是空白的百度或谷歌，而是下图</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191221230457980.png" srcset="/img/loading.gif" alt="image-20191221230457980"></p><p>如上图所示，打开一个新标签页，左侧会为你显示掘金的近期优质帖子，右边我们可以设置成 github 热门排行，当然这是我的选择，它不只是针对前端，后端和产品等不同人员皆可，自己选择感兴趣的东西即可</p><p>试想，每打开一个新的标签页，当日的 github 热门排行和掘金优质量帖子都会映入眼帘，我们可以在不知不觉中看到热门项目，帖子，如果感兴趣就点进去瞅瞅，这种内容聚合的创意我觉得很赞，大大节省了我刻意刷这些东西的时间</p><h3 id="No-14-Tampermonkey"><a href="#No-14-Tampermonkey" class="headerlink" title="No.14 Tampermonkey"></a>No.14 Tampermonkey</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>Tampermonkey，大名顶顶的油猴，一个强大的脚本管理扩展，说是谷歌扩展中最强大插件也不为过，这个插件不装上都对不住那些熬夜写脚本的开发者们，你可能听说过油猴，但是因为看到脚本感到距离遥远望而却步，其实它的操作非常简单，只要经过简单设置，下载一些现成脚本，就可以实现超级实用的功能，你可能知道它，你也可能不知道它，不管怎样，今天看到之后，装上它就对了</p><h4 id="安装-5"><a href="#安装-5" class="headerlink" title="安装"></a>安装</h4><p>谷歌应用商店搜索 Tampermonkey 扩展安装，该插件如下</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222013358211.png" srcset="/img/loading.gif" alt="image-20191222013358211"></p><h4 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h4><p>只是安装油猴并无太大作用，重点是通过它管理脚本，此插件太好用了，所以一定要给大家安利上，尽量描述的详细些</p><p>安装油猴后，在浏览器地址栏右侧就会出现油猴的小图标，左击它，会有如下列表</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222013747416.png" srcset="/img/loading.gif" alt="image-20191222013747416"></p><h5 id="获取脚本渠道"><a href="#获取脚本渠道" class="headerlink" title="获取脚本渠道"></a>获取脚本渠道</h5><p>首先我们要找几个脚本装一下，点击获取新脚本，会有如下页面</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222014025775.png" srcset="/img/loading.gif" alt="image-20191222014025775"></p><p>这里我们获取脚本的渠道有四，我们来看对比</p><ul><li>GreasyFork<ul><li>GreasyFork 是最受欢迎的后起之秀，它由 Jason Barnabe 创建</li><li>Jason Barnabe 同时也是 <a href="https://userstyles.org/" target="_blank" rel="noopener">Stylish</a> 网站的创办者，在其储存库中有大量的脚本资源</li><li>这个库也是我们首推的脚本库，里面插件超级多，关键是可选择中文</li><li>下文安装脚本会以此脚本库做示例</li></ul></li><li>OpenUserJS<ul><li>GreasyFork 之后开始创办</li><li>它由 Sizzle McTwizzle 创建,同样地,在其储存库中也拥有大量的脚本资源</li><li>他是英文的</li></ul></li><li>Userscripts.org<ul><li>老牌脚本库，不过现在不更新了，不推荐使用</li></ul></li><li>GitHub/Gist<ul><li>当然也可以在 github 或 gist 中搜索脚本资源使用，我是没从这找过，我一般都用 GreasyFork</li></ul></li></ul><h5 id="GreasyFork-中下载脚本"><a href="#GreasyFork-中下载脚本" class="headerlink" title="GreasyFork 中下载脚本"></a>GreasyFork 中下载脚本</h5><p>我一般都在 GreasyFork 中找脚本下着玩，里面的脚本足够用了</p><p>点击获取新脚本后，我们找到 GreasyFork 点击进入如下</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222014935554.png" srcset="/img/loading.gif" alt="image-20191222014935554"></p><p>我们点击右上角脚本列表，会看到无数的脚本资源，如下图</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222015035399.png" srcset="/img/loading.gif" alt="image-20191222015035399"></p><p>你也可以直接在搜索中输入关键字搜索脚本，我先随意下载一个做示例，就列表第一个吧，点击进入脚本详情</p><p>脚本的详情页会有对应的脚本使用介绍，看下就会用了</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222015203894.png" srcset="/img/loading.gif" alt="image-20191222015203894"></p><p>点击安装此脚本</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222015240191.png" srcset="/img/loading.gif" alt="image-20191222015240191"></p><p>再次点击安装即可，安装之后我们再次点击浏览器地址栏右侧油猴图标</p><p>选择管理面板点击进入，此时我们的油猴中就安装上一个脚本了，如下</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222015550494.png" srcset="/img/loading.gif" alt="image-20191222015550494"></p><p>如上图所示，我装的脚本不多，但是都挺好用的，推荐给大家</p><ul><li><p>id 为 5 的是下载图库素材的脚本</p><ul><li>使用它之后下载图片资源，嘿嘿，那还开什么千图网 vip</li></ul></li><li><p>id 为 1 的百度谷歌去广告的脚本</p><ul><li>使用它之后，那百度和谷歌被净化的只剩文字，非常舒服</li><li>还可以自己定制样式</li></ul></li><li><p>id 为 2 的是 CSDN 博客免登陆，去广告，净化剪贴板的脚本</p><ul><li>CSDN 广告太多了，而且看博客时想复制代码粘贴老是携带 CSDN 注入的信息</li><li>用了此脚本之后，嘿嘿</li></ul></li><li><p>id 为 3 的是百度文档免费下载，粘贴的脚本</p><ul><li>有时候我们会找一些文档素材，百度文档不能复制，下载要会员</li><li>有了此插件后，想复制下载，easy</li></ul></li><li><p>id 为 4 的是视频 vip 解析脚本</p><ul><li>还开什么视频 vip，想看啥，直接脚本搜即可</li></ul></li></ul><h4 id="最后-2"><a href="#最后-2" class="headerlink" title="最后"></a>最后</h4><p>上面说这些玩法是非常普通的，Tampermonkey 脚本管理工具玩法很多，脚本一途博大精深，有兴趣的话大家可以自己写脚本玩</p><p>下载的脚本安装后如何使用，一般在安装脚本的详情页会有对应的脚本使用介绍</p><p>脚本并不是都可用的，有些脚本收费，有的脚本则不可用</p><p>我下载的脚本并不多，更多好玩的脚本等着你去发掘</p><p>大家如果安装油猴了，到时候找到什么好玩免费的脚本，别忘了安利给我，先谢过</p><h3 id="No-15-SimpleExtManager"><a href="#No-15-SimpleExtManager" class="headerlink" title="No.15 SimpleExtManager"></a>No.15 SimpleExtManager</h3><p>SimpleExtManager，将此扩展放到最后，意味着它是压轴的，上面说了这么多插件，有 15 款，都是我正在使用的，可能大家会说装这么多扩展，本来谷歌就吃内存，全都安装下来还能扛的住吗？</p><p>有些扩展我们只在特殊的场景下才会使用，但是我们启用禁用一个扩展需要到扩展中心，很麻烦</p><p>SimpleExtManager 就是解决之道</p><p>它是一款快捷管理扩展的扩展插件，你可以使用该插件便捷管理扩展，快速打开扩展或关闭扩展</p><h5 id="安装-6"><a href="#安装-6" class="headerlink" title="安装"></a>安装</h5><p>还是老样子，谷歌应用商店直接搜索扩展 SimpleExtManager 一键添加即可，该扩展在商店中如下</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222114846108.png" srcset="/img/loading.gif" alt="image-20191222114846108"></p><h5 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h5><p>使用也非常简单</p><p>我们只需要点击地址栏对应的 SimpleExtManager 图标即可看到我们所有的扩展</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222114950097.png" srcset="/img/loading.gif" alt="image-20191222114950097"></p><p>如上图所示，禁用扩展直接取消选中即可，启用就勾选，还可快捷删除扩展</p><p>界面着实有点 low，不过胜在简单实用</p><h3 id="No-16-The-Great-Suspender"><a href="#No-16-The-Great-Suspender" class="headerlink" title="No.16 The Great Suspender"></a>No.16 The Great Suspender</h3><p>在使用浏览器的过程中，我们很可能会打开很多页面，而且会越来越多，是很消耗内存的，谷歌吃内存就是这</p><p>上面 SimpleExtManager 插件可以帮助我们管理扩展插件以优化 chrome 资源占用</p><p>The Great Suspender 这个插件，它则可以自动冻结一定时间内没有使用到的页面，从而较少内存消耗</p><p>居家必备的神器，用了它之后，你的 chrome 内存占用会减少很多的</p><p>这款插件长下面这个样子</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222175527666.png" srcset="/img/loading.gif" alt="image-20191222175527666"></p><p>使用很简单，你只需勾选冻结设置就可以了，冻结的网站如下图</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222215920409.png" srcset="/img/loading.gif" alt="image-20191222215920409"></p><p>解冻也非常方便，点击网站任意一处即可解冻</p><p>安装直接在谷歌应用商店搜索该扩展名字 The Great Suspender 即可</p><p>###小结</p><p>访问谷歌用 helper</p><p>高效管理标签使用 OneTab Plus</p><p>前端常用小工具 FeHelper 都有，Postman 网页端接口测试</p><p>不用鼠标，高效使用谷歌用 Vimium</p><p>划词翻译用 saladict</p><p>玩转 Github，Octotree / Sourcegraph / GitZip / Github Hovercard 四神器</p><p>Vue 开发用 Vue Devtools，react 开发用 React Developer Tools</p><p>掘金插件省去刻意查找的时间</p><p>Tampermonkey 油猴插件更是随心所欲，脚本爽到飞起</p><p>SimpleExtManager+The Great Suspender 让你的 chrome 运行如丝般顺滑</p><p>以上就是我安装并使用的 16 款非常 nice 的 chrome 扩展，大家如有更好的，请安利给我</p><h2 id="代码片段截图"><a href="#代码片段截图" class="headerlink" title="代码片段截图"></a>代码片段截图</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>早在之前，我看到别人分享的代码片段截图非常漂亮，如下图这种</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/code.png" srcset="/img/loading.gif" alt="code"></p><p>这种代码片段我之前一直以为是 Mac 专享，后来入手了 Mac 之后发现也没这功能啊，再到后来才知道，这并不是 Mac 专享，有两种办法皆可生成这种风格代码片段截图</p><h3 id="No-1-Carbon"><a href="#No-1-Carbon" class="headerlink" title="No.1 Carbon"></a>No.1 Carbon</h3><p><a href="https://carbon.now.sh/" target="_blank" rel="noopener">Carbon</a>是一个可以把你的代码转成一张精美海报的工具，让你的代码分享颜值爆表</p><p>Carbon 可以轻松将源代码创建成简洁美观的图像分享出去，支持自定义图片的语法主题，窗口样式</p><p>以下是官网图，使用简单</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222171426229.png" srcset="/img/loading.gif" alt="image-20191222171426229"></p><p>可借助这个网站生成漂亮的代码片段图片</p><h3 id="No-2-VS-Code-plugin-CodeSnap"><a href="#No-2-VS-Code-plugin-CodeSnap" class="headerlink" title="No.2 VS Code plugin CodeSnap"></a>No.2 VS Code plugin CodeSnap</h3><p>上述 Carbon 可以帮助我们生成漂亮的代码片段图片，但是使用它要打开网站 copy 代码，比较麻烦，我们会想，在编辑器中写的代码，能不能截图直接在编译器中完成，随之截图带上的也是我们编译器的主题样式，答案当然是可以的</p><p>VS Code 有一款插件，叫 CodeSnap，直接搜索该扩展安装即可，使用也简单</p><p>windows：<code>ctrl+shift+p</code></p><p>mac：<code>command+shift+p</code></p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222172647359.png" srcset="/img/loading.gif" alt="image-20191222172647359"></p><p>直接输入 codesnap 回车即可</p><p>然后选中你想截图的代码片段</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222172818160.png" srcset="/img/loading.gif" alt="image-20191222172818160"></p><p>插件生成的图片面板下有一个圆圈，点击即可保存图片，这种片段截图在编译器中，方便快捷，还可以保留编译器的样式，当然既然是 vscode 扩展，mac 和 windows 都可用</p><h2 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h2><h3 id="No-1-Processon"><a href="#No-1-Processon" class="headerlink" title="No.1 Processon"></a>No.1 Processon</h3><p>市面上的思维导图工具繁多，像百度脑图，xmind，mindmaster 等等，但是他们都得下载客户端，而且有的还收费</p><p>Processon 是一款免费在线的专业流程图和思维导图制作工具，官网如下</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222214812008.png" srcset="/img/loading.gif" alt="image-20191222214812008"></p><p>Processon 这个东西知道的人应该挺多的，因为它优点太多了</p><ul><li>在线工具，自然就有了跨平台的特性</li><li>在线存储</li><li>操作简单，0 学习成本，可制作图形巨多</li><li>可多人协作</li></ul><p>来看一款做好的思维脑图模板</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222200937011.png" srcset="/img/loading.gif" alt="image-20191222200937011"></p><p>在线存储，我们还可以将做好的脑图分享给其他人，颜值巨高，试试就知道了 <a href="https://www.processon.com/" target="_blank" rel="noopener">Processon 传送门</a></p><h3 id="No-2-Codeshare"><a href="#No-2-Codeshare" class="headerlink" title="No.2 Codeshare"></a>No.2 Codeshare</h3><p><a href="https://codeshare.io/" target="_blank" rel="noopener">Codeshare</a> 是一款在线代码编辑器，用于采访，故障排除，教学等</p><p>它最主要的功能是可以与开发人员实时共享代码，还可以共享视频，十分方便</p><p>官网界面如下</p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222214518356.png" srcset="/img/loading.gif" alt="image-20191222214518356"></p><h3 id="No-3-Gaoding-com"><a href="#No-3-Gaoding-com" class="headerlink" title="No.3 Gaoding.com"></a>No.3 Gaoding.com</h3><p>搞定设计旗下出品 搞定抠图，在线抠图，这个网站抠图巨快，算法贼 6，使用很方便</p><p>抠图的话就不用使用 PS 了，PS 太复杂，抠图太慢</p><p><a href="https://www.gaoding.com/koutu/" target="_blank" rel="noopener">Gaoding.com 传送门</a></p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222221502009.png" srcset="/img/loading.gif" alt="image-20191222221502009"></p><h3 id="No-4-remove-bg"><a href="#No-4-remove-bg" class="headerlink" title="No.4 remove.bg"></a>No.4 remove.bg</h3><p>Gaoding 是在线抠图工具，而 remove.bg 不同，remove.bg 从名字就可以看出作用，删除背景，上传一张图片，一键去除背景，一些简单的背景去除我们可以直接使用此站，复杂一些的就使用 Gaoding 手动抠，还是那两个字，方便</p><p><a href="https://www.remove.bg/" target="_blank" rel="noopener">remove.bg 传送门</a></p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222221148849.png" srcset="/img/loading.gif" alt="image-20191222221148849"></p><h3 id="No-5-无版权图片"><a href="#No-5-无版权图片" class="headerlink" title="No.5 无版权图片"></a>No.5 无版权图片</h3><p>无版权的图片资源，里面不乏一些精美图片，我一般没事会逛逛，找一些高清壁纸，好看的图片来收藏</p><p><a href="https://www.sitebuilderreport.com/" target="_blank" rel="noopener">sitebuilderrepor</a></p><p><a href="https://www.pexels.com/" target="_blank" rel="noopener">pexels</a></p><h3 id="No-6-Shodan"><a href="#No-6-Shodan" class="headerlink" title="No.6 Shodan"></a>No.6 Shodan</h3><p>最后给大家说一个搜索引擎 Shodan，被喻为“最可怕”的搜索引擎</p><p>Shodan 上搜索出来的不只是单纯的信息，而是所有接入互联网的设备，如你的手机、电脑、摄像头等等</p><p>大家如果有兴趣，可以自行了解下玩法，它可以让你更加深刻的认识网络</p><p><a href="https://www.shodan.io/" target="_blank" rel="noopener">Shodan 传送门</a></p><p><img src="/img/blog/%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%88%A9.assets/image-20191222222953478.png" srcset="/img/loading.gif" alt="image-20191222222953478"></p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>以上就是我这次的分享了，都是我经常使用的小东西，还有一些不经常使用的，比较偏门，就没放上去</p><p>我觉得每一个前端都会收藏一些稀奇古怪的玩意，大家不妨分享出来，互惠互利</p><p>大家要是有好玩的东西，又懒得码字，你直接评论或者私我，我去研究研究，回头补充上</p><p>发完这个帖子，接下来就开使写技术帖了，平常也喜欢写技术贴，存了很多的半篇半篇的帖子，觉得写的不太好，就不想发，也没时间完善，久而久之，半篇幅的帖子越来越多，不能这样颓废了</p><p>趁还年轻，趁着啥啥都还新鲜的劲头，加油</p>]]></content>
    
    
    <categories>
      
      <category>安利系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安利</tag>
      
      <tag>Chrome</tag>
      
      <tag>Vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「一步步读懂Vue源码No.2」调试环境搭建 - U</title>
    <link href="/blog/2019/11/25/vue/%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%AF%BB%E6%87%82Vue%E6%BA%90%E7%A0%81/%E3%80%8C%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%AF%BB%E6%87%82Vue%E6%BA%90%E7%A0%81No.2%E3%80%8D%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/blog/2019/11/25/vue/%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%AF%BB%E6%87%82Vue%E6%BA%90%E7%A0%81/%E3%80%8C%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%AF%BB%E6%87%82Vue%E6%BA%90%E7%A0%81No.2%E3%80%8D%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="「Vue-源码解析-No-2」调试环境搭建"><a href="#「Vue-源码解析-No-2」调试环境搭建" class="headerlink" title="「Vue 源码解析 No.2」调试环境搭建"></a>「Vue 源码解析 No.2」调试环境搭建</h1><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>下载好 Vue 源码后使用<code>npm install</code>安装依赖</p><p>vue 是基于 rollup 构建的 , 所以如果没有安装 rollup , 要先安装 rollup</p><p>npm 安装 rollop : <code>npm i -g rollup</code></p><p><strong>注：</strong>rollup 是一个 Js 模块打包器 , rollup 也可以打包项目, 不过这不是它擅长的, 他不支持热模块替换, 它最擅长的是打包 js , rollup 对于代码的 tree-shaking 和 es6 模块有算法优势的支持, 所以一些类库都在使用它(vue , react 等) , 继 grunt、gulp 实现自动化构建之后，webpack 引领了前端打包潮流，vue-cli 的脚手架就是基于 webpack 进行项目打包的。而 webpack 还在上升的势头的时候，又出了一个打包神器 parcel , 市面上常用的一些打包工具都在这里了, 具体差异 , 自行百度吧</p><h3 id="调试环境搭建"><a href="#调试环境搭建" class="headerlink" title="调试环境搭建"></a>调试环境搭建</h3><h5 id="生成-SourceMap-源码映射"><a href="#生成-SourceMap-源码映射" class="headerlink" title="生成 SourceMap(源码映射)"></a>生成 SourceMap(源码映射)</h5><p>修改<code>package.json</code>中 dev 脚本 , 加上<code>--sourcemap</code></p><pre><code class="json">&quot;scripts&quot;: {  &quot;dev&quot;: &quot;rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev&quot;  . . .}</code></pre><p>此命令用于运行时生成 sourcemap 映射文件 , 方便我们进行调试</p><p>运行<code>npm run dev</code> , dist 目录下如果生成了<code>vue.js.map</code> 就 ok 了</p><p>*<em>注 : *</em>如果你是 windows 系统 , 在执行<code>npm run dev</code>时可能会报错如下</p><pre><code class="js">[!](plugin Rollup Core) Error: Could not load e:/work-isboyjc/isboyjc/vue/src/core/config (imported by e:\work-isboyjc\isboyjc\vue\src\platforms\web\entry-runtime-with-compiler.js): ENOENT: no such file or directory, open &#39;e:\work-isboyjc\isboyjc\vue\src\core\config&#39;</code></pre><ol><li>确保你的 vue 源码路径无中文</li><li><code>roullp-plugin-alias</code> 插件对于 windows 的盘符解析忽略了小写的情况</li></ol><p>修改方法 :</p><p>找到<code>node_modules/rollup-plugin-alias/dist/rollup-plugin-alias.js</code>文件在大概 13 行的位置修改如下</p><pre><code class="js">const VOLUME = /^([A-Z]:)/i // 加上i , 忽略大小写const IS_WINDOWS = os.platform() === &quot;win32&quot;</code></pre><p>重新运行<code>npm run dev</code> , 问题解决!</p><blockquote><p>此处参考 : <a href="https://github.com/vuejs/vue/issues/2771#issuecomment-446090852" target="_blank" rel="noopener">vue.js 2.0 alpha error on start on windows 10 x64</a></p></blockquote><h5 id="创建调试文件"><a href="#创建调试文件" class="headerlink" title="创建调试文件"></a>创建调试文件</h5><p>创建调试文件<code>index.html</code>如下</p><pre><code class="html"></code></pre>]]></content>
    
    
    <categories>
      
      <category>一步步读懂Vue源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 项目中优雅使用 icon</title>
    <link href="/blog/2019/11/16/vue/Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BC%98%E9%9B%85%E4%BD%BF%E7%94%A8icon/"/>
    <url>/blog/2019/11/16/vue/Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BC%98%E9%9B%85%E4%BD%BF%E7%94%A8icon/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-项目中优雅使用-icon"><a href="#Vue-项目中优雅使用-icon" class="headerlink" title="Vue 项目中优雅使用 icon"></a>Vue 项目中优雅使用 icon</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>icon 在我们前端日常开发中是很常用的，它有很多种使用方式，时至今日，它的使用方式经过了很多种演变，本文会为大家介绍 icon 的一些历史演变，分析一下这几种使用方式的优劣，我们将采用<code>svg sprites</code>这种方式使用 icon，演示代码使用 vue+vue-cli3+，看完之后，你会发现这种使用方式完全称得上优雅二字</p><h3 id="追溯历史"><a href="#追溯历史" class="headerlink" title="追溯历史"></a>追溯历史</h3><h4 id="Img-标签引入"><a href="#Img-标签引入" class="headerlink" title="Img 标签引入"></a>Img 标签引入</h4><p>最早我们使用图标时只是单纯 img 标签引入图片，个人感觉也还好</p><p>但是这样网页上会有很多 img 图标的资源请求，这是它最大的缺点</p><h4 id="雪碧图-css-sprites"><a href="#雪碧图-css-sprites" class="headerlink" title="雪碧图(css sprites)"></a>雪碧图(css sprites)</h4><p>后来我们为了优化资源请求开始使用 CSS 雪碧图(css sprites)</p><p>CSS Sprites 在国内很多人叫 css 精灵/css 雪碧图(啥都行)，是一种网页图片应用处理方式。它允许你将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。加速的关键，不是降低质量，而是减少个数</p><p>CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用 CSS 的<code>background-image background- repeat background-position</code>的组合进行背景定位，<code>background-position</code>可以用数字精确的定位出背景图片的位置</p><p>利用 CSS Sprites 能很好地减少网页的 http 请求，从而大大的提高页面的性能，这也是 CSS Sprites 最大的优点</p><p>同时它的缺点也很明显，CSS Sprites 在开发的时候比较麻烦，需要计算基准位置来进行定位，维护的时候往往改动一个图标我们就得改整个雪碧图，一不小心就搞得整个网页的图标错位了</p><h4 id="font-库"><a href="#font-库" class="headerlink" title="font 库"></a>font 库</h4><p>再到后来就出现了 font 库，也就是字体图标库，它出现给了我们开发很大便利，使用起来也非常方便，字体图标为什么方便，因为我们可以直接从市面上的 font 字体图标库里找图标，直接使用，还可以很好的控制一些基础样式</p><p>国内估计使用量最大也是最全的图标库我觉得就是阿里矢量图标库(iconfont)了，各种图标简直不要太多，最重要的是开源免费</p><p>拿 iconfont 来说，它有三种使用方式，分别是<code>unicode，font-class，symbol</code>，都非常简单</p><p>当然，没有使用过的小伙伴直接百度搜索关键词 iconfont 使用，相信看一看就会了</p><p>接下来我们来看下这三种方式的优缺点(官方的)：</p><h3 id="font-使用方式对比"><a href="#font-使用方式对比" class="headerlink" title="font 使用方式对比"></a>font 使用方式对比</h3><h4 id="unicode-引用"><a href="#unicode-引用" class="headerlink" title="unicode 引用"></a>unicode 引用</h4><hr><p>unicode 是字体在网页端最原始的应用方式，特点是：</p><ul><li>兼容性最好，支持 ie6+，及所有现代浏览器。</li><li>支持按字体的方式去动态调整图标大小，颜色等等。</li><li>但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。</li></ul><blockquote><p>注意：新版 iconfont 支持多色图标，这些多色图标在 unicode 模式下将不能使用，如果有需求建议使用 symbol 的引用方式</p></blockquote><p>unicode 使用步骤如下：</p><h5 id="第一步：拷贝项目下面生成的-font-face"><a href="#第一步：拷贝项目下面生成的-font-face" class="headerlink" title="第一步：拷贝项目下面生成的 font-face"></a>第一步：拷贝项目下面生成的 font-face</h5><pre><code class="js">@font-face {font-family: &#39;iconfont&#39;;    src: url(&#39;iconfont.eot&#39;);    src: url(&#39;iconfont.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),    url(&#39;iconfont.woff&#39;) format(&#39;woff&#39;),    url(&#39;iconfont.ttf&#39;) format(&#39;truetype&#39;),    url(&#39;iconfont.svg#iconfont&#39;) format(&#39;svg&#39;);}</code></pre><h5 id="第二步：定义使用-iconfont-的样式"><a href="#第二步：定义使用-iconfont-的样式" class="headerlink" title="第二步：定义使用 iconfont 的样式"></a>第二步：定义使用 iconfont 的样式</h5><pre><code class="js">.iconfont{    font-family:&quot;iconfont&quot; !important;    font-size:16px;font-style:normal;    -webkit-font-smoothing: antialiased;    -webkit-text-stroke-width: 0.2px;    -moz-osx-font-smoothing: grayscale;}</code></pre><h5 id="第三步：挑选相应图标并获取字体编码，应用于页面"><a href="#第三步：挑选相应图标并获取字体编码，应用于页面" class="headerlink" title="第三步：挑选相应图标并获取字体编码，应用于页面"></a>第三步：挑选相应图标并获取字体编码，应用于页面</h5><pre><code class="js">&lt;i class=&quot;iconfont&quot;&gt;&amp;#x33;&lt;/i&gt;</code></pre><h4 id="font-class-引用"><a href="#font-class-引用" class="headerlink" title="font-class 引用"></a>font-class 引用</h4><hr><p>font-class 是 unicode 使用方式的一种变种，主要是解决 unicode 书写不直观，语意不明确的问题。</p><p>与 unicode 使用方式相比，具有如下特点：</p><ul><li>兼容性良好，支持 ie8+，及所有现代浏览器。</li><li>相比于 unicode 语意明确，书写更直观。可以很容易分辨这个 icon 是什么。</li><li>因为使用 class 来定义图标，所以当要替换图标时，只需要修改 class 里面的 unicode 引用。</li><li>不过因为本质上还是使用的字体，所以多色图标还是不支持的。</li></ul><p>使用步骤如下：</p><h5 id="第一步：拷贝项目下面生成的-fontclass-代码："><a href="#第一步：拷贝项目下面生成的-fontclass-代码：" class="headerlink" title="第一步：拷贝项目下面生成的 fontclass 代码："></a>第一步：拷贝项目下面生成的 fontclass 代码：</h5><pre><code class="js">//at.alicdn.com/t/font_8d5l8fzk5b87iudi.css</code></pre><h5 id="第二步：挑选相应图标并获取类名，应用于页面："><a href="#第二步：挑选相应图标并获取类名，应用于页面：" class="headerlink" title="第二步：挑选相应图标并获取类名，应用于页面："></a>第二步：挑选相应图标并获取类名，应用于页面：</h5><pre><code class="css">&lt;i class=&quot;iconfont icon-xxx&quot;&gt;&lt;/i&gt;</code></pre><h4 id="symbol-引用"><a href="#symbol-引用" class="headerlink" title="symbol 引用"></a>symbol 引用</h4><hr><p>这是一种全新的使用方式，应该说这才是未来的主流，也是平台目前推荐的用法。这种用法其实是做了一个 svg 的集合，与上面两种相比具有如下特点：</p><ul><li>支持多色图标了，不再受单色限制。</li><li>通过一些技巧，支持像字体那样，通过<code>font-size</code>,<code>color</code>来调整样式。</li><li>兼容性较差，支持 ie9+,及现代浏览器。</li><li>浏览器渲染 svg 的性能一般，还不如 png。</li></ul><p>使用步骤如下：</p><h5 id="第一步：拷贝项目下面生成的-symbol-代码："><a href="#第一步：拷贝项目下面生成的-symbol-代码：" class="headerlink" title="第一步：拷贝项目下面生成的 symbol 代码："></a>第一步：拷贝项目下面生成的 symbol 代码：</h5><pre><code class="js">//at.alicdn.com/t/font_8d5l8fzk5b87iudi.js</code></pre><h5 id="第二步：加入通用-css-代码（引入一次就行）："><a href="#第二步：加入通用-css-代码（引入一次就行）：" class="headerlink" title="第二步：加入通用 css 代码（引入一次就行）："></a>第二步：加入通用 css 代码（引入一次就行）：</h5><pre><code class="js">&lt;style type=&quot;text/css&quot;&gt;    .icon {       width: 1em; height: 1em;       vertical-align: -0.15em;       fill: currentColor;       overflow: hidden;    }&lt;/style&gt;</code></pre><h5 id="第三步：挑选相应图标并获取类名，应用于页面："><a href="#第三步：挑选相应图标并获取类名，应用于页面：" class="headerlink" title="第三步：挑选相应图标并获取类名，应用于页面："></a>第三步：挑选相应图标并获取类名，应用于页面：</h5><pre><code class="js">&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt;  &lt;use xlink:href=&quot;#icon-xxx&quot;&gt;&lt;/use&gt;&lt;/svg&gt;</code></pre><p>以上三种使用姿势的优缺点相信大家都了解了，symbol 这中使用方式就是本文的正题了，其实之前我是一直都使用 font-class 这种方式的(大家估计用这个的也很多)，但是它有点麻烦，因为我每次迭代项目时，修改或者添加图标都要去重新下载一份新的包，还不支持多色图标，但是现在我觉决定换了它，因为 get 到了一种更好的方式，它就是 symbol</p><p>symbol 它支持多色图标，兼容性到 ie9+，这也没什么，毕竟某 e 浏览器差不多凉透了，浏览器渲染 svg 性能这个也可以不用担心，早在 14 年张鑫旭的一篇帖子 <a href="http://www.zhangxinxu.com/wordpress/2014/07/introduce-svg-sprite-technology/?spm=a313x.7781069.1998910419.50" target="_blank" rel="noopener">SVG Sprite 介绍</a> 完美诠释了 svg sprite 的工作方式，并且对其很看好，或许这就是大佬的眼光吧 - _ -</p><p>单纯使用 iconfont 官方那种 symbol 方式其实是有点 low 的，实际开发中我们可以结合项目，让他变得简单，接下来我们就要进入本文正题，优雅使用 icon 了，哈哈哈，码这么多字，我太难了</p><h3 id="项目中优雅使用-icon"><a href="#项目中优雅使用-icon" class="headerlink" title="项目中优雅使用 icon"></a>项目中优雅使用 icon</h3><h5 id="搭建环境获取图标"><a href="#搭建环境获取图标" class="headerlink" title="搭建环境获取图标"></a>搭建环境获取图标</h5><p>我们使用 vue-cli3 搭建项目</p><p>怎么样才算优雅，首先我们在 src 目录下新建<code>icons/</code>文件夹，在<code>icons/</code>文件夹下建<code>svg/</code>文件夹，将来我们项目中的 svg 图标都会统一放在这里</p><p>接下来我们在官网搞来一个 svg 图标</p><p><img src="/img/blog/Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BC%98%E9%9B%85%E4%BD%BF%E7%94%A8icon.assets/image-20191116165415085.png" srcset="/img/loading.gif" alt="image-20191116165415085"></p><p><img src="/img/blog/Vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BC%98%E9%9B%85%E4%BD%BF%E7%94%A8icon.assets/image-20191116165528974.png" srcset="/img/loading.gif" alt="image-20191116165528974"></p><p>点击 svg 下载到<code>icons/svg</code>目录下修改文件名为<code>qq.svg</code>，或者是在<code>icons/svg</code>目录下新建一个<code>qq.svg</code>文件，把复制的 svg 代码放进去也可以</p><p>这样就获取到了一个图标，很 easy</p><h5 id="处理-svg-图标"><a href="#处理-svg-图标" class="headerlink" title="处理 svg 图标"></a>处理 svg 图标</h5><p>vue-cli 对 svg 文件有默认的<code>url-loader</code> 处理，我们要使用 svg 图标需单独进行配置</p><p>下载一个插件<code>svg-sprite-loader</code>来单独处理我们的 svg 图标，它是一个 webpack loader，支持将多个 svg 打包成 svg sprites</p><p>npm 下载</p><pre><code class="js">npm install svg-sprite-loader -D</code></pre><p>yarn 下载</p><pre><code class="js">yarn add svg-sprite-loader -D</code></pre><p>我们要怎么使用它呢，首先我们不能覆盖原有的 svg 解析 loader，我们只需要把<code>icons/svg</code>这个文件夹下的 svg 文件解析打包即可，我们在<code>vue.config.js</code>中 chainWebpack 函数中配置，来看代码</p><pre><code class="js">// 内置路径包const path = require(&quot;path&quot;)// 定义resolve方法，获取绝对路径function resolve(dir) {  return path.join(__dirname, dir)}module.exports = {  // 一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例  // 允许对内部的 webpack 配置进行更细粒度的修改  chainWebpack: config =&gt; {    // 配置svg默认规则排除icons目录中svg文件处理    config.module      .rule(&quot;svg&quot;)      .exclude.add(resolve(&quot;src/icons&quot;))      .end()    // 新增icons规则，设置svg-sprite-loader处理icons目录中svg文件    config.module      .rule(&quot;icons&quot;)      .test(/\.svg$/)      .include.add(resolve(&quot;src/icons&quot;))      .end()      .use(&quot;svg-sprite-loader&quot;)      .loader(&quot;svg-sprite-loader&quot;)      .options({ symbolId: &quot;icon-[name]&quot; })      .end()  }}</code></pre><p>如果我们不清楚 cli 的默认配置，怕改错，可通过 vue inspect 审查 webpack 内部配置，详细请看： <a href="*https://cli.vuejs.org/zh/guide/webpack.html#%E5%AE%A1%E6%9F%A5%E9%A1%B9%E7%9B%AE%E7%9A%84-webpack-%E9%85%8D%E7%BD%AE*">inspect 使用</a></p><p>上面代码中我们使用了 webpack 的链式高级用法来处理 loader，首先排除了默认 svg 的 loader 对我们<code>icons/</code>目录下 svg 文件的处理，然后新增了一个规则让<code>svg-sprite-loader</code>处理我们<code>icons/</code>文件夹下的 svg 文件，最后我们设置了<code>icon-</code>加上经过处理的 svg 文件名作为 symbolId，也就是说我们在使用<code>qq.svg</code>时可以直接在 use 标签使用<code>#icon-qq</code>，关于链式操作不了解的小伙伴可以看: <a href="[https://cli.vuejs.org/zh/guide/webpack.html#%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C-%E9%AB%98%E7%BA%A7](https://cli.vuejs.org/zh/guide/webpack.html#链式操作-高级)">链式操作(高级)</a></p><p>代码中我们引入了<code>path</code>这样一个内置的包，定义了一个<code>resolve</code>方法，该方法主要是来获取文件绝对路径的，我们把使用路径的地方都使用该方法转为绝对路径，当然使用相对路径也是可以的，但是不太安全，平台解析相对路径有差异性，所以绝对路径是最安全的</p><h5 id="svg-sprites-图标使用"><a href="#svg-sprites-图标使用" class="headerlink" title="svg sprites 图标使用"></a>svg sprites 图标使用</h5><p>现在我们就可以在你想使用图标的位置使用了，使用方式如下</p><p>在<code>main.js</code>中引入(全局引入)要使用的图标文件</p><pre><code class="js">import &quot;@/icons/svg/qq.svg&quot;</code></pre><p>模版中使用</p><pre><code class="vue">&lt;svg&gt;  &lt;use xlink:href=&quot;#icon-qq&quot;&gt;&lt;/use&gt;&lt;/svg&gt;</code></pre><p>你以为这就完了？不，还远远不够，这样使用一个图标就得引入文件一次也太麻烦了，接着看下文</p><h5 id="进阶-svg-文件自动引入"><a href="#进阶-svg-文件自动引入" class="headerlink" title="进阶-svg 文件自动引入"></a>进阶-svg 文件自动引入</h5><p>知道为什么在<code>icons/</code>文件夹下还有一个存放 svg 文件的<code>svg/</code>文件夹吗，就是为了这一步自动化引入准备的，我们在<code>icons/</code>文件夹下新建<code>index.js</code>文件，两行代码搞定，内容如下</p><pre><code class="js">// icons图标自动加载const req = require.context(&quot;./svg&quot;, false, /\.svg$/)req.keys().map(req)</code></pre><p>上面代码中我们使用<code>require.context</code>设置了当前目录下的<code>./svg</code>文件为上下文，使用正则匹配了它需要检测的文件名，这样它就会在当前目录的 svg 文件夹下去匹配符合规则的文件名</p><p>然后我们使用<code>req.keys</code>拿到所有文件名数组，再使用 map 遍历加载 req 方法，这样当该文件被调用时会遍历加载所有匹配到的文件，这就很 nice 了</p><p>看看我们改进后的使用方法：</p><p>注释掉之前的代码，在<code>main.js</code>中引入<code>icons/index.js</code>文件</p><pre><code class="js">import &quot;@/icons/index.js&quot;</code></pre><p>模板中使用和上面一样，不过这次改进当我们再次下载了一个 svg 图标时，不用再引入一遍图标 svg 了，因为我们做了自动化，<code>icons/svg/</code>下的 svg 后缀图标文件都可被自动引入</p><pre><code class="vue">&lt;svg&gt;  &lt;use xlink:href=&quot;#icon-qq&quot;&gt;&lt;/use&gt;&lt;/svg&gt;&lt;svg&gt;  &lt;use xlink:href=&quot;#icon-wx&quot;&gt;&lt;/use&gt;&lt;/svg&gt;...</code></pre><p>是不是很方便，你以为结束了？不，我们还可以再简化，因为每次使用都得 svg 标签包着 use 太麻烦了，写着也不太雅观，我们继续简化，一定要看起来使用起来都十分优雅</p><h5 id="再进阶-SvgIcon-组件"><a href="#再进阶-SvgIcon-组件" class="headerlink" title="再进阶-SvgIcon 组件"></a>再进阶-SvgIcon 组件</h5><p>在<code>components/</code>目录下新建<code>SvgIcon/index.vue</code>文件，我们写一个 svgicon 组件，封装一下再全局注册，这样使用起来就会很方便了！</p><p>svg-icon 组件代码如下：</p><pre><code class="vue">&lt;template&gt;  &lt;svg :class=&quot;svgClass&quot; aria-hidden=&quot;true&quot; v-on=&quot;$listeners&quot;&gt;    &lt;use :xlink:href=&quot;iconName&quot; /&gt;  &lt;/svg&gt;&lt;/template&gt;&lt;script&gt;export default {  name: &quot;SvgIcon&quot;,  props: {    iconClass: {      type: String,      required: true    },    className: {      type: String,      default: &quot;&quot;    }  },  computed: {    iconName() {      return `#icon-${this.iconClass}`    },    svgClass() {      if (this.className) {        return &quot;svg-icon &quot; + this.className      } else {        return &quot;svg-icon&quot;      }    }  }}&lt;/script&gt;&lt;style scoped&gt;.svg-icon {  width: 1em;  height: 1em;  vertical-align: -0.15em;  fill: currentColor;  overflow: hidden;}&lt;/style&gt;</code></pre><p>当然组件内部我们还可以根据自身项目情况进行扩展，我这边写了基础的配置</p><p>组件写好了之后我们在<code>icons/index.js</code>中进行全局注册，这样我们只引入这一个文件就可以达到自动加载和组件注册两个功能</p><p><code>icons/index.js</code>改进如下：</p><pre><code class="js">import Vue from &quot;vue&quot;import SvgIcon from &quot;@/components/SvgIcon&quot;// icons图标自动加载const req = require.context(&quot;./svg&quot;, false, /\.svg$/)req.keys().map(req)// 全局注册svg-icon组件Vue.component(&quot;svg-icon&quot;, SvgIcon)</code></pre><p>最后就是我们的使用了，在<code>main.js</code>文件引入<code>icons/index.js</code></p><pre><code class="js">import &quot;@/icons/index.js&quot;</code></pre><p>再来看看我们使用图标的方法，组件中：</p><pre><code class="vue">&lt;template&gt;  &lt;svg-icon icon-class=&quot;qq&quot; class-name=&quot;qq-style&quot;&gt;&lt;/svg-icon&gt;&lt;/template&gt;</code></pre><p>看，我们只用在<code>icon-class</code>中传入要使用的图标文件名就可以了，当然<code>class-name</code>还可以传入一个类，进行一些简单的样式修改，是不是很优雅，你 get 到了吗？</p><h3 id="Vue-Awesome"><a href="#Vue-Awesome" class="headerlink" title="Vue-Awesome"></a>Vue-Awesome</h3><p>从掘友那了解到了<a href="https://github.com/Justineo/vue-awesome" target="_blank" rel="noopener">vue-awesome</a>，体验了一番，很 nice，内置了<a href="https://fontawesome.com/" target="_blank" rel="noopener">fontawesome</a>字体图标库</p><p>好像也没啥可对比的，svg 图标引入原理差不多，vue-awesome 除了内置了 fontawesome 图标库之外也可以自己引入图标使用，做了很全面的封装，针对图标由很多功能，所以使用的话会体积会稍大</p><p>不过个人觉得，有了 iconfont 图标库，好像没有太大必要去再用 fontawesome，fontawesome 也并不是全免费，而且国外站点访问很慢，iconfont 毕竟是阿里出的，很全，针对 icon 的话我们可能并不需要太多功能，所以上面我们自己配置的话清晰明了，就已经够用，自己写的话熟悉流程 10 分钟搭一个，实在不够用，我们可以在组件花些功夫，自己做封装的话针对性强，定制性当然是看我们自己需要了，最靠谱的是使用轮子不如造轮子，哈哈</p><p>vue-awesome 是很好的，我们可以从中借鉴一些思路用于自己开发 icon 组件也是不错的，比如那些功能，我们都可以一一实现下，重要的是过程，哈哈</p><blockquote><p>参考文章：</p><p><a href="http://www.zhangxinxu.com/wordpress/2014/07/introduce-svg-sprite-technology/?spm=a313x.7781069.1998910419.50" target="_blank" rel="noopener">未来必热：SVG Sprites 技术介绍-张鑫旭</a></p><p><a href="https://juejin.im/post/59bb864b5188257e7a427c09" target="_blank" rel="noopener">手摸手，带你优雅的使用 icon-掘金</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Vue实战系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「一步步读懂Vue源码No.1」目录结构概览 - U</title>
    <link href="/blog/2019/10/15/vue/%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%AF%BB%E6%87%82Vue%E6%BA%90%E7%A0%81/%E3%80%8C%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%AF%BB%E6%87%82Vue%E6%BA%90%E7%A0%81No.1%E3%80%8D%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88/"/>
    <url>/blog/2019/10/15/vue/%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%AF%BB%E6%87%82Vue%E6%BA%90%E7%A0%81/%E3%80%8C%E4%B8%80%E6%AD%A5%E6%AD%A5%E8%AF%BB%E6%87%82Vue%E6%BA%90%E7%A0%81No.1%E3%80%8D%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1 id="「一步步读懂-Vue-源码-No-1」目录结构概览"><a href="#「一步步读懂-Vue-源码-No-1」目录结构概览" class="headerlink" title="「一步步读懂 Vue 源码 No.1」目录结构概览"></a>「一步步读懂 Vue 源码 No.1」目录结构概览</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="为什么学习源码"><a href="#为什么学习源码" class="headerlink" title="为什么学习源码"></a>为什么学习源码</h4><p>工作中难免会遇到一些问题，学习源码最直接的好处是能帮我们直接定位问题的根本原因，从而帮助我们解决问题</p><p>学习源码可以很好地巩固基础，修炼内功，提升技术 , 日常开发中我们很难把 js 的一些核心(类型、变量、函数、作用域、闭包、原型链、event loop 等 )在实践中运用自如，主要原因还是实践的少了，大部分时间都在写业务代码 , 学习源码可以让我们 js 功底更加深厚</p><p>前端框架 , 不知道如何形容 React 的好 , 但是我个人更喜欢 Vue 一点 , 作为 Vue 的爱好者和开发者 , 当然不能仅仅局限于使用 Vue 上 , 要了解 Vue 背后一系列的运行机制(数据驱动 , 数据更新 , 虚拟 DOM, diff 实现 , API 实现等等) , 才能更好的掌握 Vue , 而想要了解这些 , 最好的方式就是读源码</p><h4 id="关于本帖"><a href="#关于本帖" class="headerlink" title="关于本帖"></a>关于本帖</h4><p>源码是很枯燥的 , 只是看很难理解 , 需要多动手实践 , 所以在此记录下在源码学习中的理解 , 持续更新 ,争取年前整理完 vue 源码吧</p><p>码字的过程中收集了很多零碎帖子参考(当然要说抄袭也是可以的 , 这个我完全不反驳 , 毕竟你也可以每天奋战到 12 点 , 每天看上百篇帖子 , 取其精华 , 弃其糟糠 , 可惜并没有 , 而且我看过的其中我觉得值得大家阅读的文章我也会列出来 , 希望更多的人能够阅读) , 再加上一些自己的理解</p><p>所有涉及到的帖子会在每一节末列出来供大家阅读 , 码字不易 , 好文值得推荐</p><p>由于参考查阅的帖子太多，除却一些个人认为非常非常好的帖子(其实都很好), 不会全部列出(主要是太多了 , 只是这一篇帖子就参考了不下 30 篇文章 , 学习看他们怎么写的有什么区别 , 来保证自己所写全面又无错 , 当然这个全面不是指的所有细节面面俱到 , 而是指除却 vue 核心源码外所涉及的知识体系我都会尽可能的做一个简述列出来为大家的源码学习标注下 , 这些简述的部分会提供我看过的相关优秀帖子供大家参阅 , 所学所写皆来自网上各位前辈的尽心输出 , 我也在尽我所能反馈更多的人 , 这就是一种十分理想互联网生态 , 既帮助自己巩固 , 又可以帮到他人 , 技术学习应当如此 ^-^ )</p><p>每一篇帖子都花费了大量时间 , 已极力保证无错 , 奈何本人水平有限 , 如有不正 , 敬请指出 , 不喜勿喷 , 谢谢</p><p>进入正文</p><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p>在 github 克隆<a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">Vue 官方源码传送门</a></p><p>当前克隆版本 : 2.6.10</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><h4 id="结构简述"><a href="#结构简述" class="headerlink" title="结构简述"></a>结构简述</h4><p>打开克隆下的 vue 文件，我们会看到以下的目录结构</p><p>首先我们先总览一下 ，看这些文件都是干什么的，都有什么作用 ，以下是我克隆的 vue 源码目录</p><ul><li>.circleci</li><li>.github</li><li>benchmarks/</li><li>dist/</li><li>examples/</li><li>flow/</li><li>packages/</li><li>scripts/</li><li>src/</li><li>test/</li><li>types/</li><li>.babelrc.js</li><li>.editorconfig</li><li>.eslintignore</li><li>.eslinttrc.js</li><li>.flowconfig</li><li>.gitignore</li><li>BACKERS.md</li><li>LICENSE</li><li>package.json</li><li>REMADE.md</li><li>yarn.lock</li></ul><p>所有文件都在这了 ，先忽略项目中的一些配置，我门来细究其中几个重要文件夹的作用</p><p>文末会有一个概览，简述了所有文件作用</p><h4 id="benchmarks"><a href="#benchmarks" class="headerlink" title="benchmarks/"></a>benchmarks/</h4><p>benchmarks 是性能测试文件，Vue 的性能测试 demo，比如大数据量的 table 或者渲染大量 SVG，不做赘述</p><h4 id="dist"><a href="#dist" class="headerlink" title="dist/"></a>dist/</h4><h5 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h5><p>dist 文件夹中是打包之后输出的不同版本 Vue 文件</p><p>关于各种版本的作用，要在哪种情况下使用，dist 目录下有 REMADE.md 说明文件，很详细，不过是比较官方的英文版，中文通俗版翻译如下</p><table><thead><tr><th></th><th>UMD</th><th>CommonJS</th><th>ES Module(基于构建工具使用)</th><th>ES Module(直接用于浏览器)</th></tr></thead><tbody><tr><td>完整版</td><td>vue.js</td><td>vue.common.js</td><td>vue.esm.js</td><td>vue.esm.browser.js</td></tr><tr><td>只包含运行时版</td><td>vue.runtime.js</td><td>vue.runtime.common.js</td><td></td><td></td></tr><tr><td>完整版(生产环境)</td><td>vue.min.js</td><td></td><td></td><td>vue.esm.browser.min.js</td></tr><tr><td>只包含运行时版(生产环境)</td><td>vue.runtime.min.js</td><td></td><td></td><td></td></tr></tbody></table><h5 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h5><p><strong>完整版(Full)</strong>: 同时包含编译器和运行时的版本</p><p><strong>编译器(Compiler)</strong>：用来将模板字符串编译成为 JavaScript 渲染函数的代码</p><p><strong>运行时(runtime)</strong>： 用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除了编译器其它都有</p><p><strong>UMD</strong>：UMD 版本可以通过 <code>&lt;script&gt;标签直接用在浏览器中。</code> 位于<a href="https://Unpkg.com/vue的Unpkg" target="_blank" rel="noopener">https://Unpkg.com/vue的Unpkg</a> CDN 的默认文件 vue.js 运行时 + 编译器的 UMD 版本 (vue.js)</p><p><strong>CommonJS</strong>：CommonJS 版本用来配合老的打包工具比如 Browserify 或 webpack 1。这些打包工具的默认文件 (<code>pkg.main</code>) 是只包含运行时的 CommonJS 版本 (<code>vue.runtime.common.js</code>)</p><p><strong>ES Module</strong>： 从 2.6 开始 Vue 会提供两个 ES Modules (ESM) 构建文件：</p><ul><li>为打包工具提供的 ESM：为诸如 webpack 2 或 Rollup 提供的现代打包工具。ESM 格式被设计为可以被静态分析，所以打包工具可以利用这一点来进行“tree-shaking”将用不到的代码排除出。为这些打包工具提供的默认文件 (<code>pkg.module</code>) 是只有运行时的 ES Module 构建 (<code>vue.runtime.esm.js</code>)。</li><li>为浏览器提供的 ESM (2.6+)：用于在现代浏览器中通过 <code>&lt;script type=&quot;module&quot;&gt;</code> 直接导入</li></ul><h5 id="运行时-编译器-vs-仅运行时"><a href="#运行时-编译器-vs-仅运行时" class="headerlink" title="运行时+编译器 vs 仅运行时"></a>运行时+编译器 vs 仅运行时</h5><p>如果你需要动态编译模板（例如，使用项目中我们使用了 template 模板，或者使用其 in-dom html 作为模板安装到一个元素），那么就需要编译器把它编译</p><p>例如我们在 cli 或其他地方中使用 vue loader 或 vueify 时，*.vue 文件中的模板在生成时会编译为 js。打包好的 js 已经编译过了，我们就不需要编译器了，因此可以使用仅运行时的 vue.js 包。</p><p>例如我们老项目迭代开发中，在原生 html 中使用 vue 模版语法，在 js 中创建 vue 实例并挂载 dom，使用 cdn 引入 vue.js，这个时候需要对模版进行编译，那么我们就要使用带有编译器的版本(vue.js)</p><p>由于仅运行时的包比完整的包体积要轻 30%，因此官方说应尽可能使用仅运行时</p><h5 id="开发-Development-vs-生产-Production-模式"><a href="#开发-Development-vs-生产-Production-模式" class="headerlink" title="开发(Development) vs 生产(Production)模式"></a>开发(Development) vs 生产(Production)模式</h5><p>开发/生产模式简单来说就是未压缩的文件用于开发，压缩后的文件用于生产</p><p>CommonJS 和 ES 模块的包是为 npm 捆绑包设计的，因此官方没有为它们提供压缩版本，因为我们有使用到它们的场景时，使用完了肯定得自己打包，因为我们使用了 npm 捆绑包嘛 ，到最后就直接连同项目一块打包了，不需要压缩版本</p><p>commonjs 和 es 模块构建还保留对 process.env.node_env 的原始检查，用以确定它们应该运行的模式。应该使用适当的绑定器配置来替换这些环境变量，方便控制将在哪种模式下运行 Vue。用字符串文字替换 process.env.NODE_env 还允许像 UglifyJS(可以理解为一个打包 js 的插件)这样的小型化程序完全删除仅用于开发的代码块，从而减少最终文件大小</p><h4 id="examples"><a href="#examples" class="headerlink" title="examples/"></a>examples/</h4><p>examples 文件中存有 vue 官方的一些通用功能示例 demo，有时间可以看下</p><h4 id="flow"><a href="#flow" class="headerlink" title="flow/"></a>flow/</h4><p>JavaScript 是一门动态类型语言，变量的类型是可以随时改变的，这种灵活性虽然可以使代码编写过程不用太多考虑类型的适配和转变，但是会提高在运行时产生错误的概率，这也是大多后端瞧不上 js 的一个点，说是 js 不严格啥的，我觉得挺好，嘿嘿</p><p>当然我们可以使用 TS 弥补这种短板，但是 TS 我们需要重新学习一套语言而且它还需要编译器把相应的代码编译成原生的 JavaScript 代码 ，成本较高</p><p>为了弥补这种不足，在<code>Vue</code>源码里，尤大采用了<code>Flow</code>作为静态类型检查，<code>Flow</code>是<code>facebook</code>出品的静态类型检查工具，在现有项目中加上类型标注后，可以在代码阶段就检测出对变量的不恰当使用，利用 Flow 进行类型检查，可以使项目代码更加健壮，确保项目的其他参与者也可以写出规范的代码</p><p>尤大曾在知乎上提及过对比 TS，Flow 的优点 , 以及为什么 vue2.0+为什么使用他</p><ul><li>Flow 可以一个一个文件地迁移，如果使用 TypeScript，则需要全部替换，成本极高，短期内并不现实</li><li>Babel 和 ESLint 都有对应的 Flow 插件以支持语法，可以完全沿用现有的构建配置，非常小成本的改动就可以拥有静态类型检查的能力</li><li>更贴近 ES 规范。除了 Flow 的类型声明之外，其他都是标准的 ES。万一哪天不想用 Flow 了，用<code>babel-plugin-transform-flow-strip-types</code>转一下，就得到符合规范的 ES</li><li>在需要的地方保留 ES 的灵活性，并且对于生成的代码尺寸有更好的控制力 (rollup / 自定义 babel 插件）</li></ul><p>所以 flow 文件就是做数据类型声明的，我们会经常看到下图中这种类型声明的代码</p><p><img src="/img/blog/Vue%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97.assets/vue_flow.png" srcset="/img/loading.gif" alt="vue_flow"></p><p>vue 中使用 flow 做的类型校验，而这些类型统一在 flow 文件夹下定义</p><p>关于 Flow 的使用在这里不做赘述了，太麻烦，这里给大家粘一个知乎上关于 Flow 的帖子，看完包会那种，毕竟我这么笨的人都看的美滋滋，官方文档一并粘在下方</p><p><a href="https://zhuanlan.zhihu.com/p/26204569" target="_blank" rel="noopener">Flow 使用入门-知乎传送门</a></p><p><a href="https://flow.org/en/docs/getting-started/" target="_blank" rel="noopener">Flow 官方文档传送门</a></p><p><a href="https://www.jianshu.com/nb/28560782" target="_blank" rel="noopener">Flow 中文文档–简书十篇</a></p><p><strong>另</strong>: 了解了解就行了，毕竟 vue3.0 源码使用的 Ts，哈哈</p><h4 id="packages"><a href="#packages" class="headerlink" title="packages/"></a>packages/</h4><p>packages 文件夹下包含 4 个 vue 相关又独立的 NPM 包 ，有<code>vue-server-render,weex-vue-framework</code>等 , 提供给不同使用场景使用</p><h4 id="scripts"><a href="#scripts" class="headerlink" title="scripts/"></a>scripts/</h4><h4 id="src"><a href="#src" class="headerlink" title="src/"></a>src/</h4><h4 id="test"><a href="#test" class="headerlink" title="test/"></a>test/</h4><p>test 文件夹下就是一些测试用例 (如单元测试 , 端到端测试 , weex 、ssr 测试等等) , 不做赘述</p><h4 id="types"><a href="#types" class="headerlink" title="types/"></a>types/</h4><p>types 文件下是使用 TypeScript 定义的类型声明，其中还包含了一些测试文件 , 因为 vue2.+有对 TS 的支持</p><p>对此文件不做赘述 , 了解是干什么的就行 , 因为 2.+版本类型检测主要是用的 Flow , vue3.+就全面使用 TS 了</p><h4 id="结构概览"><a href="#结构概览" class="headerlink" title="结构概览"></a>结构概览</h4><pre><code class="js">├── .circleci ---------------------------------- 包含CircleCI持续集成/持续部署工具的配置文件├── .github ------------------------------------ 项目相关的说明文档├── benchmarks --------------------------------- 性能测试文件,处理大量数据时测试demo├── dist --------------------------------------- 打包之后输出的不同版本Vue文件├── examples ----------------------------------- 官方给出的实用demo案例代码├── flow --------------------------------------- Flow 数据类型声明文件├── packages ----------------------------------- 特定环境下独立的包(weex,服务端渲染器等)├── scripts ------------------------------------ 构建(打包)的脚本配置文件│   ├── git-hooks ------------------------------ git钩子的目录│   ├── alias.js ------------------------------- 别名配置文件│   ├── build.js ------------------------------- Rollup 构建文件│   ├── config.js ------------------------------ Rollup 构建配置的文件(重)│   ├── gen-release-note.js -------------------- 生成发布通知│   ├── get-weex-version.js -------------------- 获取 weex 版本│   ├── release-weex.sh ------------------------ 自动发布新版本weex脚本│   ├── ci.sh ---------------------------------- 持续集成运行的脚本│   ├── release.sh ----------------------------- 自动发布新版本脚本├── src ---------------------------------------- vue核心源码文件│   ├── compiler ------------------------------- 编译相关，主要将 template 编译为 render 函数│   ├── core ----------------------------------- 最核心代码，和平台无关│   │   ├── components ------------------------- 抽象出来的通用组件│   │   ├── instance --------------------------- Vue 构造函数设计相关的代码│   │   ├── global-api ------------------------- Vue 构造函数挂载全局方法(静态方法)或属性的代码│   │   ├── observer --------------------------- 响应系统，包含数据观测的核心代码│   │   ├── vdom ------------------------------- vDOM创建(creation)&amp;打补丁(patching)函数├── ├── platforms ------------------------------ 平台特有的相关代码，不同平台的构建入口文件│   │   ├── web -------------------------------- web平台│   │   │   ├── entry-runtime.js --------------- 不带编译器构建的入口│   │   │   ├── entry-runtime-with-compiler.js - 自带编译器构建的入口│   │   │   ├── entry-compiler.js -------------- vue-template-compiler 包的入口文件│   │   │   ├── entry-server-renderer.js ------- vue-server-renderer 包的入口文件│   │   │   ├── entry-server-basic-renderer.js - 输出 packages/vue-server-renderer/basic.js│   │   ├── weex ------------------------------- 混合应用├── ├── server --------------------------------- 服务端渲染│   ├── sfc ------------------------------------ .vue 文件解析│   ├── shared --------------------------------- 整个项目通用代码├── test --------------------------------------- 测试用例├── types -------------------------------------- TypeScript定义的类型声明，包含了测试文件├── .babelrc ----------------------------------- babel 配置文件├── .editorconfig ------------------------------ 编辑器语法规范配置├── .eslintignore ------------------------------ eslint 校验忽略文件├── .eslintrc ---------------------------------- eslint 配置文件├── .flowconfig -------------------------------- flow 的配置文件├── .gitignore --------------------------------- git 忽略配置├── BACKERS.md --------------------------------- 发起人和赞助者信息文件├── README.md ---------------------------------- 项目说明文档├── LICENSE ------------------------------------ 项目开源协议├── package.json ------------------------------- 项目管理文件├── README.md ---------------------------------- 项目文档├── yarn.lock||package-lock.json --------------- yarn||npm 版本锁定文件</code></pre><blockquote><p>本文相关参考:</p><p>学习路线相关:</p><p><a href="https://juejin.im/post/5b18d2d7f265da6e410e0e20" target="_blank" rel="noopener">来聊聊源码学习–掘金传送门</a></p><p>Flow 相关:</p><p><a href="https://zhuanlan.zhihu.com/p/26204569" target="_blank" rel="noopener">Flow 使用入门-知乎传送门</a></p><p><a href="https://www.jianshu.com/nb/28560782" target="_blank" rel="noopener">Flow 中文文档–简书十篇</a></p><p><a href="https://flow.org/en/docs/getting-started/" target="_blank" rel="noopener">Flow 官方文档传送门</a></p><p>短篇 Vue 源码阐述:</p><p><a href="https://my.oschina.net/u/3692906/blog/2050377#h2_1" target="_blank" rel="noopener">Vue 源码全方位剖析–OSCHINA 社区传送门</a></p><p>系统 Vue 源码文章:</p><p><a href="https://ustbhuangyi.github.io/vue-analysis/v2/prepare/" target="_blank" rel="noopener">Vue 技术揭秘–电子书</a></p><p><a href="https://github.com/answershuto/learnVue" target="_blank" rel="noopener">Vue.js 源码解析–github</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>一步步读懂Vue源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「你不知道的 Vue」组件通信大全</title>
    <link href="/blog/2019/09/12/vue/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Vue/%E3%80%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Vue%E3%80%8D%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E5%A4%A7%E5%85%A8/"/>
    <url>/blog/2019/09/12/vue/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Vue/%E3%80%8C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Vue%E3%80%8D%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="「你不知道的-Vue」组件通信大全"><a href="#「你不知道的-Vue」组件通信大全" class="headerlink" title="「你不知道的 Vue」组件通信大全"></a>「你不知道的 Vue」组件通信大全</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>说起 Vue 组件通信，可能都以为是个基础的话题，但是这个基础的东西你可能了解的不太透彻</p><p>参考工作中及 Vue 文档，写了市面上的所有的组件通信方式，如有遗漏欢迎补充</p><p>将来如果面试或者技术交流中有人问你组件通信，可以以此回怼</p><p>中间也穿插了一些和内容相关的我们不经常用却非常实用的小技巧，仔细阅读，会有点收获的</p><p>不知道为什么，好多人宁愿看看贴子，也不愿意仔细读文档，其实官方文档啥都有</p><p>估计大部分人都觉得看文档太慢了，认为搜一篇贴子读完 2 分钟比看文档 10 分钟学到的多</p><p>其实也对，但是官方文档上很全面而且绝对正确，这是贴子比不了的，所以还是有必要读一读文档的</p><p>最后来一句：请仔细阅读我们的 Vue 文档，哈哈</p><p>好了，进入正题</p><h3 id="No-1-prop"><a href="#No-1-prop" class="headerlink" title="No.1-prop"></a>No.1-prop</h3><blockquote><p>props 属性是开发中最常用的一种组件通信通讯方式 , 父组件中在组件标签上定义属性 , 子组件内定义 props 接收，用大家基本上都会用，但是如果你仔细阅读文档的话，它有很多技巧</p><p>注意 prop 是单向的，它只能父传子不能子传父</p></blockquote><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><ul><li>父组件传值</li></ul><pre><code class="html">&lt;tempalte&gt;    &lt;Child msg=&quot;hello word&quot;&gt;&lt;/Child&gt;&lt;/template&gt;</code></pre><ul><li>子组件接收</li></ul><pre><code class="html">&lt;tempalte&gt;    &lt;h1&gt;{{msg}}&lt;/h1&gt;&lt;/template&gt;&lt;script&gt;  export default{    props:[&quot;msg&quot;]  }&lt;/script&gt;</code></pre><h4 id="prop-值大小写"><a href="#prop-值大小写" class="headerlink" title="prop 值大小写"></a>prop 值大小写</h4><p>HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符，当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名</p><p>其实就是如果你使用短横线分隔命名方式传个值，接收时要转为驼峰写法</p><ul><li>父组件</li></ul><pre><code class="html">&lt;tempalte&gt;    &lt;Child child-data=&quot;hello word&quot;&gt;&lt;/Child&gt;&lt;/template&gt;</code></pre><ul><li>子组件</li></ul><pre><code class="html">&lt;tempalte&gt;    &lt;h1&gt;{{msg}}&lt;/h1&gt;&lt;/template&gt;&lt;script&gt;  export default{    props:[&quot;childData&quot;]  }&lt;/script&gt;</code></pre><h4 id="关于父组件传值"><a href="#关于父组件传值" class="headerlink" title="关于父组件传值"></a>关于父组件传值</h4><h5 id="传入的-prop-无值"><a href="#传入的-prop-无值" class="headerlink" title="传入的 prop 无值"></a>传入的 prop 无值</h5><p>不知道你有没有见过 prop 没有值的情况，反正我被坑过，prop 在没有值的情况下其实就是意味着值为 true</p><pre><code class="html">&lt;child isBool&gt;&lt;/child&gt;</code></pre><p>上述等同于</p><pre><code class="html">&lt;child isBool=&quot;true&quot;&gt;&lt;/child&gt;</code></pre><h5 id="传入一个对象的所有属性"><a href="#传入一个对象的所有属性" class="headerlink" title="传入一个对象的所有属性"></a>传入一个对象的所有属性</h5><p>如果你想要将一个对象的所有属性都作为 prop 传入，可以使用不带参数的<code>v-bind</code>简写，可以理解为展开了对象的所有属性值，如下</p><p>如果我想把对象 obj 的所有属性都传进去</p><pre><code class="js">obj = {  aa: 1,  bb: &quot;omg&quot;,  cc: [1, 2, 3]}</code></pre><p>可简写为</p><pre><code class="html">&lt;child v-bind=&quot;obj&quot;&gt;&lt;/child&gt;</code></pre><p>等价于</p><pre><code class="html">&lt;child :aa=&quot;obj.aa&quot; :bb=&quot;obj.bb&quot; :cc=&quot;obj.cc&quot;&gt;&lt;/child&gt;</code></pre><h4 id="关于子组件接收值"><a href="#关于子组件接收值" class="headerlink" title="关于子组件接收值"></a>关于子组件接收值</h4><h5 id="prop-的校验"><a href="#prop-的校验" class="headerlink" title="prop 的校验"></a>prop 的校验</h5><pre><code class="html">&lt;script&gt;  export default {    // props可以以字符串数组形式列出，但是不推荐使用这种    // props:[&quot;msg&quot;,&quot;data&quot;]    // 以对象形式接收值，每一个key做为一个值，可带有校验    // 推荐使用带有校验的方式，代码更清晰    props: {      // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)      // type的默认类型有 [String,Number,Boolean,Object,Date,Function,Symbol]      // 另外 type 还可以是一个自定义的构造函数，比如自定义了一个Person构造方法，校验时则会通过instanceof判断该值是不是通过 new Person 创建的      aa: Number,      // 多个可能的类型      bb: [String, Number],      // required，是否为必填项      cc: {        type: String,        required: true      },      // default，带有默认值      dd: {        type: Number,        default: 100      },      // 带有默认值的对象      ee: {        type: Object,        // 对象或数组默认值必须从一个工厂函数获取        default: function() {          return { message: &quot;hello&quot; }        }      },      // 自定义验证函数      ff: {        validator: function(value) {          // 这个值必须匹配下列字符串中的一个          return [&quot;success&quot;, &quot;warning&quot;, &quot;danger&quot;].indexOf(value) !== -1        }      }    }  }&lt;/script&gt;</code></pre><p>当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告</p><h5 id="非-prop-的特性"><a href="#非-prop-的特性" class="headerlink" title="非 prop 的特性"></a>非 prop 的特性</h5><h6 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h6><p>一个非 prop 特性是指传向一个组件，但是该组件并没有相应 prop 定义的特性</p><p>其实意思就是我们在使用一个组件时，传了很多值，但是其中有些值在子组件中并没有定义 props 接收，那么这些值会自动继承到子组件的根元素上</p><ul><li>父组件</li></ul><pre><code class="html">&lt;Child aaa=&quot;111&quot; bbb=&quot;222&quot; ccc=&quot;333&quot; ddd=&quot;444&quot;&gt;&lt;/Child&gt;</code></pre><ul><li>子组件</li></ul><pre><code class="html">&lt;tempalte&gt;    &lt;div&gt;    &lt;h1&gt;{{aaa}}&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default{    props:[&quot;aaa&quot;]  }&lt;/script&gt;</code></pre><p>如上述这个例子，我们在父组件中传了四个值，子组件中只接收了一个 aaa，那么其他的值会跑哪去了呢，未定义接收的值就会自动添加到子组件的跟元素上，子组件<strong>编译渲染后</strong>结果如下</p><pre><code class="html">&lt;div bbb=&quot;222&quot; ccc=&quot;333&quot; ddd=&quot;444&quot;&gt;  &lt;h1&gt;111&lt;/h1&gt;&lt;/div&gt;</code></pre><p>我们要怎样取到这些未定义接收的值呢，Vue 官方在 2.4 之后新增了<code>$attrs</code>，它就会继承所有的父组件属性（除了 prop 声明的属性、class 和 style ）</p><p>也就是说这些未定义接收的属性，会全在$attrs 里面，这样我们取就很方便了，如下</p><pre><code class="html">&lt;tempalte&gt;    &lt;div&gt;    &lt;h1&gt;{{aaa}}&lt;/h1&gt;    &lt;p&gt;{{$attrs.bbb}}{{$attrs.ccc}}{{$attrs.ddd}}&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default{    props:[&quot;aaa&quot;],    created(){      console.log(this.$attrs)    }  }&lt;/script&gt;</code></pre><h6 id="禁用继承"><a href="#禁用继承" class="headerlink" title="禁用继承"></a>禁用继承</h6><p>上面说到，未定义接收的属性值会被自动添加到组件根元素，我们看编译后的组件根元素就可以看到，这样不太美观，那有没有办法不让他自动继承到根元素呢</p><p>Vue 官方为我们提供了<code>inheritAttrs</code>属性，它接受一个布尔值，用于控制组件是否会在根元素自动继承父组件的属性值(在 props 中未定义接收的)，它默认为 true，所以我们上面才可以看到编译后的根组件上有那些属性值，我们把它改成 false，如下</p><pre><code class="html">&lt;tempalte&gt;    &lt;div&gt;    &lt;h1&gt;{{aaa}}&lt;/h1&gt;    &lt;p&gt;{{$attrs.bbb}}{{$attrs.ccc}}{{$attrs.ddd}}&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default{    inheritAttrs:false,    props:[&quot;aaa&quot;]  }&lt;/script&gt;</code></pre><p>这样就不会继承到根组件啦</p><p>有时候我们在写组件时，父组件中传了很多值，我们想不管子组件有没有接收，这些属性值都作为属性放在子组件某个元素上，这个时候我们可以参考上述 [prop 传值传一个对象的所有属性] 写法，使用<code>v-bind=&quot;$attr&quot;</code>把未定义接收的值展开全放在一个元素上，因为<code>$attrs</code>也是一个对象，讲的不太明白，我们来看应用场景</p><p>如下面的 input 组件(只是组件名字写成了 el-input，它并不是 element-ui)</p><ul><li>父组件中</li></ul><pre><code class="html">&lt;el-input type=&quot;text&quot; maxlength=&quot;10&quot; placeholder=&quot;请输入姓名&quot;&gt;&lt;/el-input&gt;</code></pre><ul><li>el-input 子组件</li></ul><pre><code class="html">&lt;tempalte&gt;    &lt;div&gt;    &lt;input :type=&quot;type&quot; v-bind=&quot;$attrs&quot; /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default{    name:&quot;elInput&quot;,    inheritAttrs:false,    props:{      type:{        type:String,        default:&#39;text&#39;      }    }  }&lt;/script&gt;</code></pre><p>如上述，我们要自定义一个 input 组件，我们想对 input 做一些扩展，但是又不想改变原生的使用方式</p><p>就像上面，我们要对 type 值做扩展处理，就只接收了 type，传值时我传了原生 input 属性的 placeholder 和 maxlength，这两个我并不需要做扩展，所以没有定义接收，这个时候它会自动继承到子组件跟元素，这样不太好看，所以我设置了<code>inheritAttrs:false</code>，我想把这两个没定义接收的属性都放到 input 标签上，就在 input 标签上写了个<code>v-bind=&quot;$attrs&quot;</code>，就是上面展开对象的写法，它就会把<code>$attrs</code>上所有属性值都展开到 input 元素属性上，大功告成，这只是其中一种使用场景，你 get 到了嘛</p><h6 id="替换-合并已有的特性"><a href="#替换-合并已有的特性" class="headerlink" title="替换/合并已有的特性"></a>替换/合并已有的特性</h6><p>另外，如果你在父组件中传入了一个属性，子组件根元素上也有一个相同属性，由于会自动继承的关系，那么父组件传入的属性值会覆盖子组件跟元素的属性值，这之中只有 class 和 style 是个例外，class 和 style 会把两边的值合并起来，如下</p><ul><li>父组件</li></ul><pre><code class="html">&lt;Child type=&quot;Number&quot; class=&quot;aaa&quot;&gt;&lt;/Child&gt;</code></pre><ul><li>子组件</li></ul><pre><code class="html">&lt;template&gt;  &lt;input type=&quot;text&quot; class=&quot;sss&quot; /&gt;&lt;/template&gt;</code></pre><p>这样子组件再编译时会编译成下面这种</p><pre><code class="html">&lt;input type=&quot;Number&quot; class=&quot;aaa sss&quot; /&gt;</code></pre><p>注意<code>inheritAttrs: false</code> 选项可以关闭继承，但是不会影响 style 和 class 的绑定</p><h3 id="No-2-emit-amp-on-u"><a href="#No-2-emit-amp-on-u" class="headerlink" title="No.2-$emit &amp; $on -u"></a>No.2-$emit &amp; $on -u</h3><blockquote><p>$emit 触发当前实例自定义事件 , 附加参数会传给监听器回调</p><p>$on 监听当前实例上的自定义事件。事件可以由 vm.$emit 触发。监听器回调函数会接收所有传入事件触发函数的额外参数</p></blockquote><h4 id="emit"><a href="#emit" class="headerlink" title="$emit"></a>$emit</h4><p>vm.$emit( event, […args] )</p><p>emit 第一个参数则是所要派发的事件名，必须是 String 类型的，其他参数都会传给监听器</p><ul><li>子组件</li></ul><pre><code class="vue">&lt;tempalte&gt;    &lt;button @click=&quot;onClick&quot;&gt;lalala&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default{  data(){    return {      test:&#39;我是子组件child的test&#39;    }  },  methods:{    onClick(){      this.$emit(&quot;childFn&quot;,&#39;哈哈哈&#39;,&#39;omg&#39;)    }  }}&lt;/script&gt;</code></pre><ul><li>父组件</li></ul><pre><code class="vue">&lt;tempalte&gt;    &lt;Child msg=&quot;hello word&quot; @childFn=&quot;onChild&quot;&gt;&lt;/Child&gt;&lt;/template&gt;&lt;script&gt;export default{  data(){    return {}  },  methods:{    onChild(a,b){      console.log(&quot;父组件收到&quot;)      console.log(a,b)    }  }}&lt;/script&gt;</code></pre><p>子组件 emit 一个<code>childFn</code>事件，父组件调用子组件<code>Child</code>时在其上自定义了一个相同的<code>childFn</code>事件来接收，上面这种用法想必大家最常用，用法不多做赘述</p><p>那么问题来了，子组件和父组件谁在派发事件，又是谁在监听事件，猜一猜？<strong>(圈起来)</strong></p><h4 id="on"><a href="#on" class="headerlink" title="$on"></a>$on</h4><h3 id="No-3-attrs-amp-​-listeners-u"><a href="#No-3-attrs-amp-​-listeners-u" class="headerlink" title="No.3-$attrs &amp; ​$listeners -u"></a>No.3-$attrs &amp; ​$listeners -u</h3><h3 id="No-4-provide-amp-inject-u"><a href="#No-4-provide-amp-inject-u" class="headerlink" title="No.4-provide &amp; inject -u"></a>No.4-provide &amp; inject -u</h3><blockquote><p>provide 和 inject 为 2.2.0 新增主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。</p><p>这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。</p></blockquote><h3 id="No-5-parent-amp-children-u"><a href="#No-5-parent-amp-children-u" class="headerlink" title="No.5-parent &amp; children -u"></a>No.5-parent &amp; children -u</h3><h3 id="No-6-root"><a href="#No-6-root" class="headerlink" title="No.6-$root"></a>No.6-$root</h3><blockquote><p>$root 当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己</p></blockquote><ul><li>main.js 中</li></ul><pre><code class="js">new Vue({  data: {    bar: &quot;bar&quot;  },  router,  store,  render: h =&gt; h(App)}).$mount(&quot;#app&quot;)</code></pre><p><code>this.$root</code>可获取到当前项目组件树的根 Vue 实例，也就是整个实例。。</p><p>如上我们在根实例创建时写了一个 data，里面放了一个 bar</p><p>那么我们在任何组件都可以通过<code>this.$root.bar</code>获取到 bar，也可以更改它</p><p>你可以吧所有想要跨级使用的数据放在根实例上，这也算是一种通讯方式，但是请不要在项目中使用，不然被人发现了，性命堪忧</p><p>因为你都放在这，项目稍微一大，你根本不知道数据的流向，不知道在哪使用了，也不知道在哪更改了它，就是所谓的强耦合，烂代码。。</p><h3 id="No-7-refs"><a href="#No-7-refs" class="headerlink" title="No.7-$refs"></a>No.7-$refs</h3><blockquote><p><code>ref</code> 被用来给元素或子组件注册引用信息，引用信息将会注册在父组件的 <code>$refs</code> 对象上</p><p>如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</p></blockquote><p>平常我们大多数都是使用$refs 获取 dom 元素，但是如果我们仔细看文档，其实它也可以获取子组件实例，如下</p><ul><li>子元素</li></ul><pre><code class="html">&lt;template&gt;  &lt;div&gt;{{msg}}&lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default {    data() {      return {        msg: &quot;我是msg&quot;      }    }  }&lt;/script&gt;</code></pre><ul><li>父组件</li></ul><pre><code class="html">&lt;template&gt;  &lt;Child ref=&quot;aaa&quot;&gt;&lt;/Child&gt;&lt;/template&gt;&lt;script&gt;  export default {    mounted() {      setTimeout(() =&gt; {        console.log(this.$refs.child)        this.$refs.child.msg = &quot;我是子组件中的msg，我被改变了&quot;      }, 5000)    }  }&lt;/script&gt;</code></pre><p>注意：我们亲爱的文档说，ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在，所以上文是在 mounted 生命周期中获取的</p><p>如上所示，子组件中我定义了一个 msg，在父组件挂载完成 5 秒后更改了子组件中的 msg，我们看输出，输出的是 child 组件实例，<strong>说明父组件中我通过$refs 获取到了 child 实例</strong>，可以看到，子组件的 msg 值在 5 秒后也被改变了。</p><p>啥子？它有啥用？你都获取到子组件的实例了，还不是想怎么玩怎么玩，你想在父组件中改子组件属性值调用子组件方法啥的都可以，你品，细品</p><h3 id="No-8-EventBus-u"><a href="#No-8-EventBus-u" class="headerlink" title="No.8-EventBus -u"></a>No.8-EventBus -u</h3><h3 id="No-9-broadcast-amp-dispatch-u"><a href="#No-9-broadcast-amp-dispatch-u" class="headerlink" title="No.9-broadcast &amp; dispatch -u"></a>No.9-broadcast &amp; dispatch -u</h3><h3 id="No-10-solt-u"><a href="#No-10-solt-u" class="headerlink" title="No.10-solt -u"></a>No.10-solt -u</h3><h3 id="No-11-路由传参-u"><a href="#No-11-路由传参-u" class="headerlink" title="No.11-路由传参 -u"></a>No.11-路由传参 -u</h3><h3 id="No-12-Vue-observable-u"><a href="#No-12-Vue-observable-u" class="headerlink" title="No.12-Vue.observable -u"></a>No.12-Vue.observable -u</h3><h3 id="No-13-Vuex-u"><a href="#No-13-Vuex-u" class="headerlink" title="No.13-Vuex -u"></a>No.13-Vuex -u</h3>]]></content>
    
    
    <categories>
      
      <category>你不知道的Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 基础面试题</title>
    <link href="/blog/2019/06/10/vue/Vue%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/blog/2019/06/10/vue/Vue%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-基础面试题"><a href="#Vue-基础面试题" class="headerlink" title="Vue 基础面试题"></a>Vue 基础面试题</h1><h3 id="1-MVVM-amp-amp-MVC"><a href="#1-MVVM-amp-amp-MVC" class="headerlink" title="1. MVVM&amp;&amp;MVC"></a>1. MVVM&amp;&amp;MVC</h3><h4 id="1-1-MVVM"><a href="#1-1-MVVM" class="headerlink" title="1.1 MVVM"></a>1.1 MVVM</h4><pre><code class="js">MVVM -&gt; Model-View-ViewModelModel 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。View 代表UI组件，它负责将数据模型转化成UI展现出来。ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</code></pre><h4 id="1-2-MVC"><a href="#1-2-MVC" class="headerlink" title="1.2 MVC"></a>1.2 MVC</h4><pre><code class="JS">MVC是Model-View- Controller的简写，即模型-视图-控制器，M和V和MVVM中的M和V是一样的，C是Controller即页面义务逻辑使用MVC的目的就是为了M和V代码分离。MVVM的VM并不是完全取代C，VM存在的目的是抽离C中的业务逻辑</code></pre><h4 id="1-3-MVVM-amp-amp-MVC-区别"><a href="#1-3-MVVM-amp-amp-MVC-区别" class="headerlink" title="1.3 MVVM&amp;&amp;MVC 区别"></a>1.3 MVVM&amp;&amp;MVC 区别</h4><pre><code class="js">MVC是单向的数据传递。MVVM是双向数据绑定，主要解决了MVC中大量的DOM操作使页面的渲染性能降低，加载速度变慢，影响用户体验</code></pre><h3 id="2-Vue-生命周期"><a href="#2-Vue-生命周期" class="headerlink" title="2. Vue 生命周期"></a>2. Vue 生命周期</h3><h4 id="2-1-什么是生命周期"><a href="#2-1-什么是生命周期" class="headerlink" title="2.1 什么是生命周期"></a>2.1 什么是生命周期</h4><pre><code class="js">Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期</code></pre><h4 id="2-2-生命周期的作用"><a href="#2-2-生命周期的作用" class="headerlink" title="2.2 生命周期的作用"></a>2.2 生命周期的作用</h4><pre><code class="js">生命周期中有多个事件钩子，在控制整个Vue实例的过程时更容易形成好的逻辑</code></pre><h4 id="2-3-生命周期阶段"><a href="#2-3-生命周期阶段" class="headerlink" title="2.3 生命周期阶段"></a>2.3 生命周期阶段</h4><pre><code class="js">它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后beforeCreate （创建前） 在数据观测和初始化事件还未开始created         （创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来beforeMount  （载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。mounted      （载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。beforeUpdate （更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。updated      （更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。beforeDestroy（销毁前） 在实例销毁之前调用。实例仍然完全可用。destroyed    （销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</code></pre><h4 id="2-4-第一次加载会触发哪些钩子"><a href="#2-4-第一次加载会触发哪些钩子" class="headerlink" title="2.4 第一次加载会触发哪些钩子"></a>2.4 第一次加载会触发哪些钩子</h4><pre><code class="js">会触发beforeCreate, created, beforeMount, mounted</code></pre><h4 id="2-5-DOM-渲染在哪个周期中就已经完成"><a href="#2-5-DOM-渲染在哪个周期中就已经完成" class="headerlink" title="2.5 DOM 渲染在哪个周期中就已经完成"></a>2.5 DOM 渲染在哪个周期中就已经完成</h4><pre><code class="js">DOM 渲染在 mounted 中就已经完成</code></pre><h3 id="3-双向绑定原理"><a href="#3-双向绑定原理" class="headerlink" title="3. 双向绑定原理"></a>3. 双向绑定原理</h3><h4 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h4><pre><code class="js">Object.defineProperty()vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty（）来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 {{}}），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果</code></pre><h4 id="3-2-js-实现双向数据绑定"><a href="#3-2-js-实现双向数据绑定" class="headerlink" title="3.2 js 实现双向数据绑定"></a>3.2 js 实现双向数据绑定</h4><pre><code class="html">&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;input type=&quot;text&quot; id=&quot;txt&quot; /&gt;    &lt;p id=&quot;show&quot;&gt;&lt;/p&gt;  &lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt;  var obj = {}  Object.defineProperty(obj, &quot;txt&quot;, {    get: function() {      return obj    },    set: function(newValue) {      document.getElementById(&quot;txt&quot;).value = newValue      document.getElementById(&quot;show&quot;).innerHTML = newValue    }  })  document.addEventListener(&quot;keyup&quot;, function(e) {    obj.txt = e.target.value  })&lt;/script&gt;</code></pre><h3 id="4-Vue-组件传参"><a href="#4-Vue-组件传参" class="headerlink" title="4. Vue 组件传参"></a>4. Vue 组件传参</h3><h4 id="4-1-父与子传参"><a href="#4-1-父与子传参" class="headerlink" title="4.1 父与子传参"></a>4.1 父与子传参</h4><pre><code class="js">子组件通过props方法接受数据</code></pre><h4 id="4-2-子与父传参"><a href="#4-2-子与父传参" class="headerlink" title="4.2 子与父传参"></a>4.2 子与父传参</h4><pre><code class="js">$emit方法传递参数</code></pre><h4 id="4-3-非父子-amp-amp-兄弟间传参"><a href="#4-3-非父子-amp-amp-兄弟间传参" class="headerlink" title="4.3 非父子&amp;&amp;兄弟间传参"></a>4.3 非父子&amp;&amp;兄弟间传参</h4><pre><code class="js">eventBus，创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，这个比较合适。也可以直接使用用VUEX，具体来说看需求</code></pre><h3 id="5-Vue-路由"><a href="#5-Vue-路由" class="headerlink" title="5. Vue 路由"></a>5. Vue 路由</h3><h4 id="5-1-路由跳转"><a href="#5-1-路由跳转" class="headerlink" title="5.1 路由跳转"></a>5.1 路由跳转</h4><pre><code class="js">声明式(标签式)&lt;router-link :to=&quot;index&quot;&gt;编程式router.push({path:&#39;/&#39;,query:{}})</code></pre><h4 id="5-2-路由实现：hash-模式-和-history-模式"><a href="#5-2-路由实现：hash-模式-和-history-模式" class="headerlink" title="5.2 路由实现：hash 模式 和 history 模式"></a>5.2 路由实现：hash 模式 和 history 模式</h4><pre><code class="js">hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。history模式：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”</code></pre><h4 id="5-3-Vue-路由守卫-路由钩子"><a href="#5-3-Vue-路由守卫-路由钩子" class="headerlink" title="5.3 Vue 路由守卫(路由钩子)"></a>5.3 Vue 路由守卫(路由钩子)</h4><p>全局守卫</p><pre><code class="js">beforeEach，afterEach 路由钩子函数，也叫路由守卫beforeEach 全局前置守卫，当一个导航触发时，全局前置守卫按照创建顺序调用参数：to：route即将要进入的目标路由对象from：route当前导航正要离开的路由next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转    next()：跳转下一个页面    next(false): 中断当前的导航，返回原来页面    next({path:&#39;/&#39;})：跳转到一个不同的地址，当前的导航被中断，进行一个新的导航注意：一定要调用next(),否则钩子就不会被 resolved，页面会卡在那，一般用于对路由跳转前进行拦截afterEach 全局后置钩子router.afterEach((to, from) =&gt; {})和前置守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身</code></pre><p>局部(组件)守卫</p><pre><code class="js">组件中路由钩子beforeRouteEnter(to,from,next){} 路由跳转时注：此钩子在beforeCreate之前执行，但是next在组件mounted周期之后,无法直接调用this访问组件实例，可用next访问vm实例，修改数据beforeRouteLeave(to,from,next){...next()} 离开路由时注意：可以直接访问this,next不可回调beforeRouteUpdate 路由切换时</code></pre><h4 id="5-4-动态渲染路由-addRoutes"><a href="#5-4-动态渲染路由-addRoutes" class="headerlink" title="5.4 动态渲染路由 addRoutes"></a>5.4 动态渲染路由 addRoutes</h4><pre><code class="js">addRoutes用于动态添加路由常用场景：页面级权限控制，服务端存储路由对象，登录后页面加载时根据不同权限动态渲染路由</code></pre><h3 id="6-Vue-计算属性"><a href="#6-Vue-计算属性" class="headerlink" title="6. Vue 计算属性"></a>6. Vue 计算属性</h3><h4 id="6-1-为什么使用计算属性-优点"><a href="#6-1-为什么使用计算属性-优点" class="headerlink" title="6.1 为什么使用计算属性(优点)"></a>6.1 为什么使用计算属性(优点)</h4><pre><code class="js">模板中放入太多的逻辑会让模板过重且难以维护，在需要对数据进行复杂处理，且可能多次使用的情况下，尽量采取计算属性的方式优点：1. 使得数据处理结构清晰2. 依赖于数据，数据更新，处理结果自动更新3. 计算属性内部this指向vm实例4. 在template调用时，直接写计算属性名即可5. methods不管依赖的数据变不变，都会重新计算，computed依赖数据不变时缓存中获取，不会重新计算</code></pre><h3 id="7-Vuex"><a href="#7-Vuex" class="headerlink" title="7. Vuex"></a>7. Vuex</h3><h4 id="7-1-简述"><a href="#7-1-简述" class="headerlink" title="7.1 简述"></a>7.1 简述</h4><pre><code class="js">vue中状态管理器，实现组件间的数据共享通过状态（数据源）集中管理驱动组件的变化，应用级的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中在main.js引入store，注入。新建了一个目录store，... export</code></pre><h3 id="8-浅谈-keep-alive"><a href="#8-浅谈-keep-alive" class="headerlink" title="8. 浅谈 keep-alive"></a>8. 浅谈 keep-alive</h3><pre><code class="js">keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染，相当于强缓存vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include)</code></pre><p>示例：</p><pre><code class="html">&lt;keep-alive include=&quot;include_components&quot; exclude=&quot;exclude_components&quot;&gt;  &lt;component&gt;    &lt;!-- 该组件是否缓存取决于include和exclude属性 --&gt;  &lt;/component&gt;&lt;/keep-alive&gt;&lt;keep-alive  &gt;&lt;router-view v-if=&quot;”$route.meta.keepAlive”&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;”$route.meta.keepAlive”&quot;&gt;&lt;/router-view&gt;</code></pre><p>参数：</p><pre><code class="js">include - 字符串或正则表达式，只有名称匹配的组件会被缓存exclude - 字符串或正则表达式，任何名称匹配的组件都不会被缓存include 和 exclude 的属性允许组件有条件地缓存。二者都可以用“，”分隔字符串、正则表达式、数组。当使用正则或者是数组时，要使用v-bind</code></pre><p>示例：</p><pre><code class="html">&lt;!-- 逗号分隔字符串，只有组件a与b被缓存。 --&gt;&lt;keep-alive include=&quot;a,b&quot;&gt;  &lt;component&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 正则表达式 (需要使用 v-bind，符合匹配规则的都会被缓存) --&gt;&lt;keep-alive :include=&quot;/a|b/&quot;&gt;  &lt;component&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- Array (需要使用 v-bind，被包含的都会被缓存) --&gt;&lt;keep-alive :include=&quot;[&#39;a&#39;, &#39;b&#39;]&quot;&gt;  &lt;component&gt;&lt;/component&gt;&lt;/keep-alive&gt;</code></pre><h3 id="9-Vue-自定义指令"><a href="#9-Vue-自定义指令" class="headerlink" title="9. Vue 自定义指令"></a>9. Vue 自定义指令</h3><pre><code class="js">vue.directive,可以写在组件内部，也可以写在外部作为全局的使用它的钩子有bind，inserted，update等</code></pre><h3 id="10-Vue-两大核心是什么"><a href="#10-Vue-两大核心是什么" class="headerlink" title="10. Vue 两大核心是什么"></a>10. Vue 两大核心是什么</h3><pre><code class="js">1. 数据驱动2. 组件系统</code></pre><h3 id="11-route-和-router-的区别"><a href="#11-route-和-router-的区别" class="headerlink" title="11. $route 和$router 的区别"></a>11. $route 和$router 的区别</h3><pre><code class="js">$route是&lt;路由信息对象&gt;，包括path，params，hash，query，fullPath，matched，name等路由信息参数$router是&lt;路由实例&gt;对象包括了路由的跳转方法，钩子函数等</code></pre><h3 id="12-Vue-常用修饰符"><a href="#12-Vue-常用修饰符" class="headerlink" title="12. Vue 常用修饰符"></a>12. Vue 常用修饰符</h3><pre><code class="js">.prevent: 提交事件不再重载页面.stop   : 阻止单击事件冒泡.self   : 当事件发生在该元素本身而不是子元素的时候会触发.capture: 事件侦听，事件发生的时候会调用</code></pre><h3 id="13-Vue-中-v-on-怎样绑定多个事件"><a href="#13-Vue-中-v-on-怎样绑定多个事件" class="headerlink" title="13. Vue 中 v-on 怎样绑定多个事件"></a>13. Vue 中 v-on 怎样绑定多个事件</h3><pre><code class="js">方法名后加 () =&gt; 调用方法 多个方法用 ; 隔开例：&lt;div @click=&quot;one();two();three()&quot;&gt;&lt;/div&gt;</code></pre><h3 id="14-vue-中-key-值的作用"><a href="#14-vue-中-key-值的作用" class="headerlink" title="14. vue 中 key 值的作用"></a>14. vue 中 key 值的作用</h3><pre><code class="js">当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key的作用主要是为了高效的更新虚拟DOM简单来说：为了避免重复渲染，高效更新渲染DOM</code></pre><h3 id="15-Vue-中-css-怎样只在当前组件起作用"><a href="#15-Vue-中-css-怎样只在当前组件起作用" class="headerlink" title="15. Vue 中 css 怎样只在当前组件起作用"></a>15. Vue 中 css 怎样只在当前组件起作用</h3><pre><code class="html">style标签中写入scoped即可 例如：&lt;style scoped&gt;&lt;/style&gt;</code></pre><h3 id="16-v-if-和-v-show-区别"><a href="#16-v-if-和-v-show-区别" class="headerlink" title="16. v-if 和 v-show 区别"></a>16. v-if 和 v-show 区别</h3><pre><code class="js">v-if按照条件是否渲染，如果为false不会渲染v-show是相当于display的block或none，为false是还是会渲染，只不过隐藏了</code></pre><h3 id="17-为什么避免-v-if-和-v-for-用在一起"><a href="#17-为什么避免-v-if-和-v-for-用在一起" class="headerlink" title="17. 为什么避免 v-if 和 v-for 用在一起"></a>17. 为什么避免 v-if 和 v-for 用在一起</h3><pre><code class="js">vue处理指令时，v-for比v-if具有更高的优先级，通过v-if移动到容器的元素，不会在重复遍历列表中的每个值，取而代之的是，我们只检查它一次，且不会v-if为否的时候运算v-for</code></pre><h3 id="18-单页面-SPA-和多页面的区别-优缺点"><a href="#18-单页面-SPA-和多页面的区别-优缺点" class="headerlink" title="18. 单页面(SPA)和多页面的区别(优缺点)"></a>18. 单页面(SPA)和多页面的区别(优缺点)</h3><pre><code class="js">单页面：整个项目中只有一个完整的HTML页面，其它&quot;页面&quot;只是一段HTML片断而已优: 请求少缺: 不利于搜索引擎优化，首次加载时间长页面跳转本质：把当前DOM树中某个DIV删除，下载并挂载另一个div片断多页面：项目中有多个独立的完整的HTML页面缺: 请求次数多，效率低页面跳转本质: 删除旧的DOM树，重新下载新的DOM树</code></pre><h3 id="19-Vue-的优缺点是什么"><a href="#19-Vue-的优缺点是什么" class="headerlink" title="19. Vue 的优缺点是什么"></a>19. Vue 的优缺点是什么</h3><pre><code class="js">优点：低耦合，可重用性，独立开发，可测试，渐进式缺点：不利于SEO，社区维护力度不强，相比还不够成熟</code></pre><h3 id="20-vue-和-react-区别"><a href="#20-vue-和-react-区别" class="headerlink" title="20. vue 和 react 区别"></a>20. vue 和 react 区别</h3><pre><code class="js">相同点：都鼓励组件化，都有props的概念，都有自己的构建工具，React与Vue只有框架的骨架，其他的功能如路由、状态管理等是框架分离的组件不同点：React：单向数据流，语法—JSX，在React中你需要使用setState()方法去更新状态Vue：双向数据流，语法--HTML，state对象并不是必须的，数据由data属性在Vue对象中进行管理。适用于小型应用，对于大型应用而言不太适合</code></pre>]]></content>
    
    
    <categories>
      
      <category>面试系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GIT常用命令</title>
    <link href="/blog/2019/04/12/git/GIT%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/blog/2019/04/12/git/GIT%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="GIT-常用命令"><a href="#GIT-常用命令" class="headerlink" title="GIT 常用命令"></a>GIT 常用命令</h1><h3 id="SSH-公钥"><a href="#SSH-公钥" class="headerlink" title="SSH 公钥"></a>SSH 公钥</h3><h5 id="查看本机-ssh-公钥"><a href="#查看本机-ssh-公钥" class="headerlink" title="查看本机 ssh 公钥"></a>查看本机 ssh 公钥</h5><pre><code class="js">1. 打开git bash窗口2. 进入.ssh目录： cd ~/.ssh3. 查看.ssh文件下有无id_rsa.pub文件：ls4. 查看公钥：cat id_rsa.pub  或者  vim id_rsa.pub上述步骤合为一步: cat ~/.ssh/id_rsa.pub</code></pre><h5 id="生成本机-ssh-公钥"><a href="#生成本机-ssh-公钥" class="headerlink" title="生成本机 ssh 公钥"></a>生成本机 ssh 公钥</h5><pre><code class="js">1. 命令行下输入: ssh-keygen2. 确认存放公钥的地址，默认就是上面说的路径，直接enter键确认3. 输入密码和确认密码，如果不想设置密码直接不输入内容 按enter键4. 重复上面查看公钥步骤</code></pre><h5 id="git-中字母代表"><a href="#git-中字母代表" class="headerlink" title="git 中字母代表"></a>git 中字母代表</h5><pre><code class="js">A         # 增加的文件C       # 文件的一个新拷贝D       # 删除的一个文件M       # 文件的内容或者mode被修改了R       # 文件名被修改了T       # 文件类型被修改了U       # 文件没有被合并(需要完成合并才能进行提交)X       # 未知状态(git的bug , 可以向git提交bug report)</code></pre><h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><h5 id="查询本机已配置参数"><a href="#查询本机已配置参数" class="headerlink" title="查询本机已配置参数"></a>查询本机已配置参数</h5><pre><code class="js">git config --list</code></pre><h5 id="签名级别"><a href="#签名级别" class="headerlink" title="签名级别"></a>签名级别</h5><pre><code class="js">system // 所有用户(本系统)global // 全局local // 本地(默认)</code></pre><h5 id="配置签名–用户名和邮箱"><a href="#配置签名–用户名和邮箱" class="headerlink" title="配置签名–用户名和邮箱"></a>配置签名–用户名和邮箱</h5><p>Git 提交前，必须配置签名, 即用户名和邮箱 信息会永久保存到历史记录</p><pre><code class="js">项目级别git config user.name [AAA]git config user.email [邮箱地址]系统级别git config --global user.name &quot;aaa&quot;git config --global user.email 111@qq.com</code></pre><h5 id="签名信息位置"><a href="#签名信息位置" class="headerlink" title="签名信息位置"></a>签名信息位置</h5><pre><code class="js">cat.git / config</code></pre><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><h5 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h5><pre><code class="js">mkdir 新目录名     // 创建一个新目录cd 新目录名        // 进入新目录下pwd               // 显示当前路径</code></pre><h5 id="初始化版本库"><a href="#初始化版本库" class="headerlink" title="初始化版本库"></a>初始化版本库</h5><pre><code class="js">git init</code></pre><h5 id="查看-git-文件"><a href="#查看-git-文件" class="headerlink" title="查看.git 文件"></a>查看.git 文件</h5><pre><code class="js">ls - ah</code></pre><h5 id="添加到仓库暂存区"><a href="#添加到仓库暂存区" class="headerlink" title="添加到仓库暂存区"></a>添加到仓库暂存区</h5><pre><code class="js">git add a.txt index.html</code></pre><h5 id="提交到本地仓库"><a href="#提交到本地仓库" class="headerlink" title="提交到本地仓库"></a>提交到本地仓库</h5><pre><code class="js">git commit -m &quot;提交说明&quot;</code></pre><h5 id="查看当前仓库工作区的状态"><a href="#查看当前仓库工作区的状态" class="headerlink" title="查看当前仓库工作区的状态"></a>查看当前仓库工作区的状态</h5><pre><code class="js">git status</code></pre><h5 id="比较修改的差异"><a href="#比较修改的差异" class="headerlink" title="比较修改的差异"></a>比较修改的差异</h5><pre><code class="js">git diff</code></pre><h5 id="查看提交日志"><a href="#查看提交日志" class="headerlink" title="查看提交日志"></a>查看提交日志</h5><p>16 进制字符串代表 commit id</p><pre><code class="js">git log                                         // 按提交时间列出所有的更新,显示完整信息git log --pretty=oneline                      // 将每个提交放在一行显示,显示完整commit idgit log --oneline                             // 将每个提交放在一行显示,显示不完整commit idgit reflog (HEAD@{移动到当前版本})               // 查看之前版本的log,包括删除的,可查找历史commitID</code></pre><h5 id="版本回滚"><a href="#版本回滚" class="headerlink" title="版本回滚"></a>版本回滚</h5><p>上一版本<code>HEAD^</code>，上上一版本<code>HEAD^^</code> ，上 100<code>HEAD~100</code></p><pre><code class="js">git reset --hard HEAD^</code></pre><h5 id="撤回回滚"><a href="#撤回回滚" class="headerlink" title="撤回回滚"></a>撤回回滚</h5><p>没关闭命令行,a8543 为回退前文件 commitID,只需要前几位就行</p><pre><code class="js">git reset --hard a8543</code></pre><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h5 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h5><pre><code class="js">git clone &#39;仓库地址&#39;</code></pre><h5 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h5><pre><code class="js">git remote add &#39;仓库地址&#39;</code></pre><h5 id="查看关联远程库"><a href="#查看关联远程库" class="headerlink" title="查看关联远程库"></a>查看关联远程库</h5><pre><code class="js">git remote -v</code></pre><h5 id="修改关联远程库"><a href="#修改关联远程库" class="headerlink" title="修改关联远程库"></a>修改关联远程库</h5><pre><code class="js">git remote set-url origin &#39;仓库地址&#39;</code></pre><h5 id="推送远程仓库"><a href="#推送远程仓库" class="headerlink" title="推送远程仓库"></a>推送远程仓库</h5><pre><code class="js">git push -u origin master   // 第一次推送git push origin master      // 再次推送</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript常用内置API</title>
    <link href="/blog/2019/03/10/javascript/JavaScript%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AEAPI/"/>
    <url>/blog/2019/03/10/javascript/JavaScript%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AEAPI/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-常用内置-API"><a href="#JavaScript-常用内置-API" class="headerlink" title="JavaScript 常用内置 API"></a>JavaScript 常用内置 API</h1><h3 id="JS-简述"><a href="#JS-简述" class="headerlink" title="JS 简述"></a>JS 简述</h3><h5 id="三大对象"><a href="#三大对象" class="headerlink" title="三大对象"></a>三大对象</h5><h6 id="本地对象"><a href="#本地对象" class="headerlink" title="本地对象"></a>本地对象</h6><ul><li>与宿主无关，独立于宿主环境的 ECMAScript 实现提供的对象</li><li>简单来说，本地对象就是 <code>ECMA-262</code> 定义的类（引用类型）</li><li>这些引用类型在运行过程中需要通过 <code>new</code> 来创建所需的实例对象</li></ul><p>包括：</p><p>引用类型：<code>Object</code>、<code>Function</code>、<code>Array</code>、<code>Date</code>、<code>RegExp</code></p><p>基本包装类型：<code>String</code>、<code>Boolean</code>、<code>Number</code></p><p>其他类型：<code>Error</code>、<code>EvalError</code>、<code>RangeError</code>、<code>ReferenceError</code>、<code>SyntaxError</code>、<code>TypeError</code>、<code>URIError</code>等</p><h6 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h6><ul><li>与宿主无关，独立于宿主环境的 ECMAScript 实现提供的对象，在 ECMAScript 程序开始执行时出现</li><li>在 <code>ECMAScript</code> 程序开始执行前就存在，本身就是实例化内置对象，开发者无需再去实例化</li><li>内置对象是本地对象的子集</li><li>很多时候，会直接把本地对象和内置对象统称为内置对象，也被叫做单体内置对象</li></ul><p>包含：</p><p><code>Global</code>和<code>Math</code></p><p><code>ECMAScript5</code>中增添了<code>JSON</code>这个存在于全局的内置对象</p><h6 id="宿主对象"><a href="#宿主对象" class="headerlink" title="宿主对象"></a>宿主对象</h6><ul><li>由 ECMAScript 实现的宿主环境提供的对象，包含两大类，一个是宿主提供，一个是自定义类对象</li><li>所有非本地对象都属于宿主对象</li><li>对于嵌入到网页中的 JS 来说，其宿主对象就是浏览器提供的对象，浏览器对象有很多，如<code>Window</code>和<code>Document</code>等</li><li>所有的<code>DOM</code>和<code>BOM</code>对象都属于宿主对象</li></ul><p>包括：</p><ol><li><p>宿主提供的对象</p><p>a. BOM&amp;DOM 等</p></li><li><p>自定义对象</p><p>a. 对象直接量（字面量）</p><p>b. new 操作符跟构造函数</p><p>c. function 对象</p></li></ol><h5 id="两大属性"><a href="#两大属性" class="headerlink" title="两大属性"></a>两大属性</h5><h6 id="自有-实例-属性"><a href="#自有-实例-属性" class="headerlink" title="自有(实例)属性"></a>自有(实例)属性</h6><p>也可叫实例属性：指对象自身的属性，也就是直接在对象中定义的属性</p><h6 id="私有-原型-属性"><a href="#私有-原型-属性" class="headerlink" title="私有(原型)属性"></a>私有(原型)属性</h6><p>也可叫原型属性：指对象从原型中继承的属性，也就是在对象的原型对象中定义的属性</p><h3 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h3><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><h6 id="str-length"><a href="#str-length" class="headerlink" title="str.length"></a>str.length</h6><p>返回字符串的长度</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><h6 id="charAt"><a href="#charAt" class="headerlink" title="charAt()"></a>charAt()</h6><p>功能：返回指定位置的字符</p><p>参数：必须，为目标字符的下标位置</p><blockquote><p>若参数 index 不在 0 与 string.length 之间，该方法将返回一个空字符串</p></blockquote><h6 id="charCodeAt"><a href="#charCodeAt" class="headerlink" title="charCodeAt()"></a>charCodeAt()</h6><p>功能：返回在指定位置的字符的 Unicode 编码</p><p>参数：必须，为目标字符的下标位置</p><blockquote><p>若参数 index 不在 0 与 string.length 之间，该方法将返回 NaN</p></blockquote><h6 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h6><p>功能：检索字符串，返回指定子字符串在字符串中首次出现的位置。</p><p>参数 1：检索目标子字符串，必须</p><p>参数 2：在字符串中开始检索的位置，可选。省略该参数，则将从字符串的首字符开始检索</p><blockquote><p>indexOf() 方法对大小写敏感</p><p>如果要检索的字符串值没有出现，则该方法返回 -1</p></blockquote><h6 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h6><p>功能：从后向前搜索字符串，返回指定子字符串在字符串中首次出现的位置</p><p>参数 1：检索目标子字符串，必须</p><p>参数 2：在字符串中开始检索的位置，可选。省略该参数，则将从字符串的最后一个字符开始检索</p><h6 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h6><p>功能：返回指定位置的字符</p><p>参数：必须，规定要检索的字符串值或待匹配的 RegExp 对象</p><p>返回值：存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g</p><blockquote><p>regexp 没有 g，match() 方法只执行一次匹配，如果没有找到任何匹配的文本， match() 将返回 null，否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息，该数组的第 0 个元素存放的是匹配文本，返回的数组还含有两个对象属性：index 属性为 stringObject 中的索引，input 属性是对 stringObject 的引用</p><p>regexp 具有标志 g，则 match() 方法将执行全局检索，找到 stringObject 中的所有匹配子字符串。若没有找到子串，返回 null。如果找到了一个或多个匹配子串，则返回一个数组。返回数组元素中存放的是 stringObject 中所有的匹配子串，没有 index 属性或 input 属性</p></blockquote><p>示例：</p><pre><code class="js">let s = &quot;hello23 world23&quot;console.log(s.match(/\d{2}/)) //[ &#39;23&#39;, index: 5, input: &#39;hello21 world21&#39; ]let s = &quot;hello23 world23&quot;console.log(s.match(/\d{2}/g)) //[ &#39;23&#39;, &#39;23&#39; ]</code></pre><h6 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h6><p>功能：在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p><p>参数 1：regexp/substr，必须，规定子字符串或要匹配的 RegExp 对象</p><p>参数 2：replacement，必须，用于替换的字符串值</p><p>返回值：替换后的一个新字符串</p><p>示例：</p><pre><code class="js">var s = &quot;hello world hello&quot;console.log(s.replace(&quot;hello&quot;, &quot;hi&quot;)) //hi world helloconsole.log(s.replace(/hello/, &quot;hi&quot;)) //hi world helloconsole.log(s.replace(/hello/g, &quot;hi&quot;)) //hi world hi</code></pre><blockquote><p>方法返回一个新字符串，不会修改原字符串</p></blockquote><h6 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h6><p>功能：检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串</p><p>参数：regexp/substr，必须，规定子字符串或要匹配的 RegExp 对象</p><p>返回值：原字符串中第一次匹配到目标字符串的起始位置</p><p>示例：</p><pre><code class="js">var s = &quot;hello world hello&quot;console.log(s.search(&quot;hello&quot;)) //0console.log(s.search(/hello/g)) //0console.log(s.search(/hello2/)) //-1</code></pre><blockquote><p>方法不执行全局匹配，它将忽略标志 g。也就是说，它只匹配一次。若没匹配到结果，则返回-1</p></blockquote><p>toLowerCase()</p><p>功能：把字符串转换为小写</p><p>返回值：一个新字符串</p><p>示例：</p><pre><code class="js">var s = &quot;Hello World&quot;console.log(s.toLowerCase()) //hello world</code></pre><p>toUpperCase()</p><p>功能：把字符串转换为大写</p><p>返回值：一个新字符串</p><p>示例：</p><pre><code class="js">var s = &quot;Hello World&quot;console.log(s.toUpperCase()) //HELLO WORLD</code></pre><h6 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h6><p>功能：用于连接两个或多个字符串</p><p>语法：stringObject.concat(stringX,stringX,…,stringX)</p><p>返回值：衔接后的新字符串</p><blockquote><p>concat 方法不会修改原字符串</p><p>stringObject.concat() 与 Array.concat() 很相似</p><p>通常使用 “ + “ 运算符来进行字符串的连接运算通常会更简便一些</p></blockquote><p>示例：</p><pre><code class="js">var s1 = &quot;hello &quot;var s2 = &quot;world &quot;var s3 = &quot;001&quot;console.log(s1.concat(s2, s3)) //hello world 001</code></pre><h6 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h6><p>功能：把一个字符串分割成字符串数组，Array.join( ) 的逆操作</p><p>参数 1：separator，必须，字符串或正则表达式，从该参数指定的地方分割原字符串</p><p>参数 2：howmany，可选，指定返回数组的最大长度</p><p>返回值：一个字符串数组</p><p>示例：</p><pre><code class="js">var s = &quot;he llo&quot;console.log(s.split(&quot;&quot;)) //[ &#39;h&#39;, &#39;e&#39;, &#39; &#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39; ]console.log(s.split(&quot; &quot;)) //[ &#39;he&#39;, &#39;llo&#39; ]console.log(s.split(&quot;l&quot;)) //[&quot;he &quot;, &quot;&quot;, &quot;o&quot;]</code></pre><h6 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h6><p>功能：截取字符串的某个部分</p><p>参数 1：截取的起始位置，必须</p><p>参数 2：截取的结束位置，可选</p><p>返回值：截取部分，一个新的字符串</p><blockquote><p>String.slice() 与 Array.slice() 相似</p><p>slice 方法的两个参数接受负值，若为负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推。 未指定第二个参数，则默认截取至字符串的末尾。 slice 方法不修改原字符串</p></blockquote><p>示例：</p><pre><code class="js">var s = &quot;he llo&quot;console.log(s.slice(3)) //lloconsole.log(s.slice(1, 5)) //e llconsole.log(s.slice(-5)) //e lloconsole.log(s.slice(-5, -1)) //e ll</code></pre><h6 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h6><p>功能：截取从指定下标开始的指定数目的字符</p><p>参数 1：start，必须，截取的起始位置，接受负值</p><p>参数 2：length，可选，截取字符串的长度，未指定，则默认截取到原字符串的末尾</p><p>返回值：截取部分，一个新的字符串</p><blockquote><p>ECMAscript 中未对该方法进行标准化，不建议使用</p></blockquote><p>示例：</p><pre><code class="js">var s = &quot;he llo&quot;console.log(s.substr(3)) //lloconsole.log(s.substr(3, 2)) //llconsole.log(s.substr(-3, 2)) //ll</code></pre><h6 id="substring"><a href="#substring" class="headerlink" title="substring()"></a>substring()</h6><p>功能：截取字符串中介于两个指定下标之间的字符</p><p>参数 1：start，必须，截取的起始位置</p><p>参数 2：end，可选，截取的结束位置，未指定，则默认截取到原字符串的末尾</p><p>返回值：截取部分，一个新的字符串</p><p>示例：</p><pre><code class="js">var s = &quot;he llo&quot;console.log(s.substring(3)) //lloconsole.log(s.substring(3, 5)) //llconsole.log(s.substring(5, 3)) //llconsole.log(s.substring(3, 3)) //&#39;&#39;</code></pre><blockquote><p>与 slice() 和 substr() 方法不同的是，substring() 不接受负的参数</p><p>如果参数 start 与 stop 相等，那么该方法返回的一个空串</p><p>如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数</p></blockquote><h6 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h6><p>功能：去除字符串的头尾空格</p><h3 id="Array-对象"><a href="#Array-对象" class="headerlink" title="Array 对象"></a>Array 对象</h3><h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><h6 id="length"><a href="#length" class="headerlink" title="length"></a>length</h6><p>返回数组中元素的数目</p><blockquote><p>设置 length 属性可改变数组的大小。如果设置的值比其当前值小，数组将被截断，其尾部的元素将丢失。如果设置的值比它的当前值大，数组将增大，新的元素被添加到数组的尾部，它们的值为 undefined</p></blockquote><h6 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h6><p>数组对象构造器，返回对创建此对象的数组函数的引用</p><h6 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h6><p>数组对象原型，用于向对象添加属性和方法</p><h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><h6 id="concat-1"><a href="#concat-1" class="headerlink" title="concat()"></a>concat()</h6><p>用于拼接数组，不会改变原有数组</p><blockquote><p>如果要进行 concat() 操作的参数是数组，那么添加的是数组中的元素，而不是数组</p></blockquote><h6 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h6><p>把数组中的所有元素放入一个字符串，元素是通过指定的分隔符进行分隔的</p><blockquote><p>若省略了分隔符参数，则默认使用逗号作为分隔符</p></blockquote><p>示例：</p><pre><code class="js">let arr = [1, 2, 3]arr.join() // &#39;1,2,3&#39;arr.join(0) // &#39;10203&#39;</code></pre><h6 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h6><p>向数组的末尾添加一个或多个元素，返回新的数组长度</p><h6 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h6><p>用于删除数组的最后一个元素，把数组长度减 1，返回被删除元素</p><blockquote><p>如果数组已经为空，则 pop() 不改变数组，并返回 undefined</p></blockquote><h6 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h6><p>用于把数组的第一个元素从其中删除，并返回被移除的这个元素</p><blockquote><p>如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined</p><p>该方法直接修改原数组</p></blockquote><h6 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h6><p>向数组的开头添加一个或更多元素，并返回新的数组长度</p><blockquote><p>该方法直接修改原数组</p></blockquote><h6 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h6><p>用于反转数组中元素顺序</p><p>该方法直接修改原数组，不会创建新数组</p><h6 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h6><p>用于对数组的元素进行排序</p><p>该排序直接修改原数组</p><p>该方法接受一个可选参数，若未使用参数，将按字母顺序对数组元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</p><p>如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：</p><ul><li>若 a 小于 b，排序后 a 应该在 b 之前，则返回一个小于 0 的值</li><li>若 a 等于 b，则返回 0。</li><li>若 a 大于 b，则返回一个大于 0 的值</li></ul><p>示例：</p><pre><code class="js">arr1 = [&quot;tom&quot;, &quot;array&quot;, &quot;obj&quot;, &quot;string&quot;, &quot;bool&quot;]arr1.sort() // [&quot;array&quot;, &quot;bool&quot;, &quot;obj&quot;, &quot;string&quot;, &quot;tom&quot;] 按照字母顺序arr2 = [1, 20, 90, 21, 1000, 300]arr2.sort() // [1, 1000, 20, 21, 300, 90]arr2.sort((a, b) =&gt; {  return a - b}) // [1, 20, 21, 90, 300, 1000]arr2.sort((a, b) =&gt; {  return b - a}) // [1000, 300, 90, 21, 20, 1]</code></pre><h6 id="slice-1"><a href="#slice-1" class="headerlink" title="slice()"></a>slice()</h6><p>参数：start [,end]</p><p>截取原数组从 start 到 end 位置（不包含它）元素组成的子数组</p><blockquote><p>该方法返回一个新数组，不会修改原数组</p><p>若未指定 end 参数，那么截取 start 直到原数组最后一个元素（包含它）</p></blockquote><h6 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h6><p>参数：index,howmany [,item1,item2…]</p><p>删除从 index 处开始的 hownamy 个元素，并且用可选参数列表中声明的一个或多个值来替换那些被删除的元素</p><blockquote><p>该方法返回的是含有被删除的元素组成的数组，若无被删元素，则返回空数组。</p><p>若参数只有 index，那么原数组将从 index 开始删除直至结尾。</p><p>该方法直接修改原数组</p></blockquote><h6 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h6><p>参数:1:必须,要判断的元素 2:可选,表示判断的起始位置,可为负数</p><p>返回值:true||false</p><blockquote><p>ES6 数组方法</p><p>判断数组是否包含某一元素</p><p>它直接返回 true 或者 false 表示是否包含元素，对 NaN 一样能有有效</p></blockquote><h6 id="forEach-v-i-a-gt"><a href="#forEach-v-i-a-gt" class="headerlink" title="forEach((v,i,a)=&gt;{})"></a>forEach((v,i,a)=&gt;{})</h6><p>作用：让数组的每一项都执行一次给定的 callback</p><p>参数：callback v 表示当前项的值，i 表示当前索引，a 表示数组本身</p><blockquote><p>forEach 遍历的范围在第一次调用 callback 前就会确定。调用 forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。已删除的项不会被遍历到</p></blockquote><h6 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h6><p>参数：map(callback, thisValue)</p><blockquote><p>callback 为必须项，(currentValue,index,arr)=&gt;{}</p><p><em>currentValue</em> 必须。当前元素的值</p><p><em>index</em> 可选。当前元素的索引值</p><p><em>arr</em> 可选。当前元素属于的数组对象</p><p>thisValue 可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。 如果省略了 thisValue，或者传入 null、undefined，那么回调函数的 this 为全局对象</p></blockquote><p>示例：</p><pre><code class="js">var numbers = [4, 9, 16, 25]numbers.map(Math.sqrt) // 2,3,4,5</code></pre><h3 id="Number-对象"><a href="#Number-对象" class="headerlink" title="Number 对象"></a>Number 对象</h3><h5 id="toExponential"><a href="#toExponential" class="headerlink" title="toExponential()"></a>toExponential()</h5><p>把对象的值转换为指数计数法</p><p>示例：</p><pre><code class="js">var num = 5.56789var n = num.toExponential() // 5.56789e+0</code></pre><h5 id="toFixed"><a href="#toFixed" class="headerlink" title="toFixed()"></a>toFixed()</h5><p>把数字转换为字符串，结果的小数点后有指定位数的数字</p><p>示例：</p><pre><code class="js">var num = 5.56789var n = num.toFixed(2) // 5.57</code></pre><h5 id="toPrecision"><a href="#toPrecision" class="headerlink" title="toPrecision()"></a>toPrecision()</h5><p>把数字格式化为指定的长度</p><p>示例：</p><pre><code class="js">var num = new Number(13.3714)var n = num.toPrecision(2) // 13</code></pre><h3 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h3><h5 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h5><p>功能：将字符串反序列化成对象</p><p>参数：JSON 字符串</p><p>返回值：对象</p><h5 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h5><p>功能：将一个对象解析为 JSON 字符串</p><p>参数：对象</p><p>返回值：JSON 字符串</p><blockquote><p>该字符串应该符合 JSON 格式，并且可以被 JSON.parse 方法还原</p><p>JSON.stringify(obj, selectedProperties)还可以接受一个数组</p><p>作为第二个参数，指定需要转成字符串的属性</p><p>还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性</p><p>如果是数字，表示每个属性前面添加的空格（最多不超过 10 个）</p><p>如果是字符串（不超过 10 个字符），则该字符串会添加在每行前面</p></blockquote><h3 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h3><h5 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h5><h6 id="Math-E"><a href="#Math-E" class="headerlink" title="Math.E"></a>Math.E</h6><p>常数 e</p><h6 id="Math-LN2"><a href="#Math-LN2" class="headerlink" title="Math.LN2"></a>Math.LN2</h6><p>2 的自然对数</p><h6 id="Math-LN10"><a href="#Math-LN10" class="headerlink" title="Math.LN10"></a>Math.LN10</h6><p>10 的自然对数</p><h6 id="Math-LOG2E"><a href="#Math-LOG2E" class="headerlink" title="Math.LOG2E"></a>Math.LOG2E</h6><p>以 2 为底的 e 的对数</p><h6 id="Math-LOG10E"><a href="#Math-LOG10E" class="headerlink" title="Math.LOG10E"></a>Math.LOG10E</h6><p>以 10 为底的 e 的对数</p><h6 id="Math-PI"><a href="#Math-PI" class="headerlink" title="Math.PI"></a>Math.PI</h6><p>常数 Pi</p><h6 id="Math-SQRT1-2"><a href="#Math-SQRT1-2" class="headerlink" title="Math.SQRT1_2"></a>Math.SQRT1_2</h6><p>0.5 的平方根</p><h6 id="Math-SQRT2"><a href="#Math-SQRT2" class="headerlink" title="Math.SQRT2"></a>Math.SQRT2</h6><p>2 的平方根</p><h5 id="数学方法"><a href="#数学方法" class="headerlink" title="数学方法"></a>数学方法</h5><h6 id="Math-abs"><a href="#Math-abs" class="headerlink" title="Math.abs()"></a>Math.abs()</h6><p>返回参数的绝对值</p><h6 id="Math-ceil"><a href="#Math-ceil" class="headerlink" title="Math.ceil()"></a>Math.ceil()</h6><p>向上取整，接受一个参数，返回大于该参数的最小整数</p><h6 id="Math-floor"><a href="#Math-floor" class="headerlink" title="Math.floor()"></a>Math.floor()</h6><p>向下取整</p><h6 id="Math-max-n-n1-…"><a href="#Math-max-n-n1-…" class="headerlink" title="Math.max(n,n1,…)"></a>Math.max(n,n1,…)</h6><p>可接受多个参数，返回最大值</p><h6 id="Math-min-n-n1"><a href="#Math-min-n-n1" class="headerlink" title="Math.min(n,n1,..)"></a>Math.min(n,n1,..)</h6><p>可接受多个参数，返回最小值</p><h6 id="Math-pow-n-e"><a href="#Math-pow-n-e" class="headerlink" title="Math.pow(n,e)"></a>Math.pow(n,e)</h6><p>指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值</p><h6 id="Math-sqrt"><a href="#Math-sqrt" class="headerlink" title="Math.sqrt()"></a>Math.sqrt()</h6><p>返回参数值的平方根。如果参数是一个负值，则返回 NaN</p><h6 id="Math-log"><a href="#Math-log" class="headerlink" title="Math.log()"></a>Math.log()</h6><p>返回以 e 为底的自然对数值</p><h6 id="Math-exp"><a href="#Math-exp" class="headerlink" title="Math.exp()"></a>Math.exp()</h6><p>返回 e 的指数，也就是常数 e 的参数次方</p><h6 id="Math-round"><a href="#Math-round" class="headerlink" title="Math.round()"></a>Math.round()</h6><p>四舍五入</p><h6 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h6><p>返回 0 到 1 之间的一个伪随机数，可能等于 0，但是一定小于 1。</p><h5 id="三角函数方法"><a href="#三角函数方法" class="headerlink" title="三角函数方法"></a>三角函数方法</h5><h6 id="Math-sin"><a href="#Math-sin" class="headerlink" title="Math.sin()"></a>Math.sin()</h6><p>返回参数的正弦</p><h6 id="Math-cos"><a href="#Math-cos" class="headerlink" title="Math.cos()"></a>Math.cos()</h6><p>返回参数的余弦</p><h6 id="Math-tan"><a href="#Math-tan" class="headerlink" title="Math.tan()"></a>Math.tan()</h6><p>返回参数的正切</p><h6 id="Math-asin"><a href="#Math-asin" class="headerlink" title="Math.asin()"></a>Math.asin()</h6><p>返回参数的反正弦（弧度值）</p><h6 id="Math-acos"><a href="#Math-acos" class="headerlink" title="Math.acos()"></a>Math.acos()</h6><p>返回参数的反余弦（弧度值）</p><h6 id="Math-atan"><a href="#Math-atan" class="headerlink" title="Math.atan()"></a>Math.atan()</h6><p>返回参数的反正切（弧度值）</p><h3 id="Date-对象"><a href="#Date-对象" class="headerlink" title="Date 对象"></a>Date 对象</h3><h5 id="Date"><a href="#Date" class="headerlink" title="Date()"></a>Date()</h5><p>返回当日的日期和时间</p><h5 id="getDate"><a href="#getDate" class="headerlink" title="getDate()"></a>getDate()</h5><p>从 Date 对象返回一个月中的某一天 (1 ~ 31)</p><h5 id="getDay"><a href="#getDay" class="headerlink" title="getDay()"></a>getDay()</h5><p>从 Date 对象返回一周中的某一天 (0 ~ 6)</p><h5 id="getMonth"><a href="#getMonth" class="headerlink" title="getMonth()"></a>getMonth()</h5><p>从 Date 对象返回月份 (0 ~ 11)</p><h5 id="getFullYear"><a href="#getFullYear" class="headerlink" title="getFullYear()"></a>getFullYear()</h5><p>从 Date 对象以四位数字返回年份</p><h5 id="getYear"><a href="#getYear" class="headerlink" title="getYear()"></a>getYear()</h5><p>ECMAScript v3 开始，JavaScript 的实现就不再使用该方法， 请使用 getFullYear() 方法代替</p><h5 id="getHours"><a href="#getHours" class="headerlink" title="getHours()"></a>getHours()</h5><p>返回 Date 对象的小时 (0 ~ 23)</p><h5 id="getMinutes"><a href="#getMinutes" class="headerlink" title="getMinutes()"></a>getMinutes()</h5><p>返回 Date 对象的分钟 (0 ~ 59)</p><h5 id="getSeconds"><a href="#getSeconds" class="headerlink" title="getSeconds()"></a>getSeconds()</h5><p>返回 Date 对象的秒数 (0 ~ 59)</p><h5 id="getMilliseconds"><a href="#getMilliseconds" class="headerlink" title="getMilliseconds()"></a>getMilliseconds()</h5><p>返回 Date 对象的毫秒(0 ~ 999)</p><h5 id="getTime"><a href="#getTime" class="headerlink" title="getTime()"></a>getTime()</h5><p>返回 1970 年 1 月 1 日至今的毫秒数</p><h5 id="getTimezoneOffset"><a href="#getTimezoneOffset" class="headerlink" title="getTimezoneOffset()"></a>getTimezoneOffset()</h5><p>返回本地时间与格林威治标准时间 (GMT) 的分钟差</p><h5 id="getUTCDate"><a href="#getUTCDate" class="headerlink" title="getUTCDate()"></a>getUTCDate()</h5><p>根据世界时从 Date 对象返回月中的一天 (1 ~ 31)</p><h5 id="getUTCDay"><a href="#getUTCDay" class="headerlink" title="getUTCDay()"></a>getUTCDay()</h5><p>根据世界时从 Date 对象返回周中的一天 (0 ~ 6)</p><h5 id="getUTCMonth"><a href="#getUTCMonth" class="headerlink" title="getUTCMonth()"></a>getUTCMonth()</h5><p>根据世界时从 Date 对象返回月份 (0 ~ 11)</p><h5 id="getUTCFullYear"><a href="#getUTCFullYear" class="headerlink" title="getUTCFullYear()"></a>getUTCFullYear()</h5><p>根据世界时从 Date 对象返回四位数的年份</p><h5 id="getUTCHours"><a href="#getUTCHours" class="headerlink" title="getUTCHours()"></a>getUTCHours()</h5><p>根据世界时返回 Date 对象的小时 (0 ~ 23)</p><h5 id="getUTCMinutes"><a href="#getUTCMinutes" class="headerlink" title="getUTCMinutes()"></a>getUTCMinutes()</h5><p>根据世界时返回 Date 对象的分钟 (0 ~ 59)</p><h5 id="getUTCSeconds"><a href="#getUTCSeconds" class="headerlink" title="getUTCSeconds()"></a>getUTCSeconds()</h5><p>根据世界时返回 Date 对象的秒钟 (0 ~ 59)</p><h5 id="getUTCMilliseconds"><a href="#getUTCMilliseconds" class="headerlink" title="getUTCMilliseconds()"></a>getUTCMilliseconds()</h5><p>根据世界时返回 Date 对象的毫秒(0 ~ 999)</p><h5 id="parse"><a href="#parse" class="headerlink" title="parse()"></a>parse()</h5><p>返回 1970 年 1 月 1 日午夜到指定日期（字符串）的毫秒数</p><h5 id="setDate"><a href="#setDate" class="headerlink" title="setDate()"></a>setDate()</h5><p>设置 Date 对象中月的某一天 (1 ~ 31)</p><h5 id="setMonth"><a href="#setMonth" class="headerlink" title="setMonth()"></a>setMonth()</h5><p>设置 Date 对象中月份 (0 ~ 11)</p><h5 id="setFullYear"><a href="#setFullYear" class="headerlink" title="setFullYear()"></a>setFullYear()</h5><p>设置 Date 对象中的年份（四位数字）</p><h5 id="setYear"><a href="#setYear" class="headerlink" title="setYear()"></a>setYear()</h5><p>请使用 setFullYear() 方法代替</p><h5 id="setHours"><a href="#setHours" class="headerlink" title="setHours()"></a>setHours()</h5><p>设置 Date 对象中的小时 (0 ~ 23)</p><h5 id="setMinutes"><a href="#setMinutes" class="headerlink" title="setMinutes()"></a>setMinutes()</h5><p>设置 Date 对象中的分钟 (0 ~ 59)</p><h5 id="setSeconds"><a href="#setSeconds" class="headerlink" title="setSeconds()"></a>setSeconds()</h5><p>设置 Date 对象中的秒钟 (0 ~ 59)</p><h5 id="setMilliseconds"><a href="#setMilliseconds" class="headerlink" title="setMilliseconds()"></a>setMilliseconds()</h5><p>设置 Date 对象中的毫秒 (0 ~ 999)</p><h5 id="setTime"><a href="#setTime" class="headerlink" title="setTime()"></a>setTime()</h5><p>以毫秒设置 Date 对象</p><h5 id="setUTCDate"><a href="#setUTCDate" class="headerlink" title="setUTCDate()"></a>setUTCDate()</h5><p>根据世界时设置 Date 对象中月份的一天 (1 ~ 31)</p><h5 id="setUTCMonth"><a href="#setUTCMonth" class="headerlink" title="setUTCMonth()"></a>setUTCMonth()</h5><p>根据世界时设置 Date 对象中的月份 (0 ~ 11)</p><h5 id="setUTCFullYear"><a href="#setUTCFullYear" class="headerlink" title="setUTCFullYear()"></a>setUTCFullYear()</h5><p>根据世界时设置 Date 对象中的年份（四位数字）</p><h5 id="setUTCHours"><a href="#setUTCHours" class="headerlink" title="setUTCHours()"></a>setUTCHours()</h5><p>根据世界时设置 Date 对象中的小时 (0 ~ 23)</p><h5 id="setUTCMinutes"><a href="#setUTCMinutes" class="headerlink" title="setUTCMinutes()"></a>setUTCMinutes()</h5><p>根据世界时设置 Date 对象中的分钟 (0 ~ 59)</p><h5 id="setUTCSeconds"><a href="#setUTCSeconds" class="headerlink" title="setUTCSeconds()"></a>setUTCSeconds()</h5><p>根据世界时设置 Date 对象中的秒钟 (0 ~ 59)</p><h5 id="setUTCMilliseconds"><a href="#setUTCMilliseconds" class="headerlink" title="setUTCMilliseconds()"></a>setUTCMilliseconds()</h5><p>根据世界时设置 Date 对象中的毫秒 (0 ~ 999)</p><h5 id="toSource"><a href="#toSource" class="headerlink" title="toSource()"></a>toSource()</h5><p>返回该对象的源代码</p><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h5><p>把 Date 对象转换为字符串</p><h5 id="toTimeString"><a href="#toTimeString" class="headerlink" title="toTimeString()"></a>toTimeString()</h5><p>把 Date 对象的时间部分转换为字符串</p><h5 id="toDateString"><a href="#toDateString" class="headerlink" title="toDateString()"></a>toDateString()</h5><p>把 Date 对象的日期部分转换为字符串</p><h5 id="toGMTString"><a href="#toGMTString" class="headerlink" title="toGMTString()"></a>toGMTString()</h5><p>请使用 toUTCString() 方法代替</p><h5 id="toUTCString"><a href="#toUTCString" class="headerlink" title="toUTCString()"></a>toUTCString()</h5><p>根据世界时，把 Date 对象转换为字符串</p><h5 id="toLocaleString-NaN"><a href="#toLocaleString-NaN" class="headerlink" title="toLocaleString()"></a>toLocaleString()</h5><p>根据本地时间格式，把 Date 对象转换为字符串</p><h5 id="toLocaleTimeString"><a href="#toLocaleTimeString" class="headerlink" title="toLocaleTimeString()"></a>toLocaleTimeString()</h5><p>根据本地时间格式，把 Date 对象的时间部分转换为字符串</p><h5 id="toLocaleDateString"><a href="#toLocaleDateString" class="headerlink" title="toLocaleDateString()"></a>toLocaleDateString()</h5><p>根据本地时间格式，把 Date 对象的日期部分转换为字符串</p><h5 id="UTC"><a href="#UTC" class="headerlink" title="UTC()"></a>UTC()</h5><p>根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数</p><h5 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h5><p>返回 Date 对象的原始值</p><h3 id="Global-对象"><a href="#Global-对象" class="headerlink" title="Global 对象"></a>Global 对象</h3><blockquote><p>全局对象只是一个对象，而不是类。既没有构造函数，也无法实例化一个新的全局对象</p></blockquote><h5 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h5><h6 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h6><p>代表正的无穷大的数值</p><h6 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h6><p>代表非数字</p><h6 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h6><p>代表未定义的值</p><p>示例：</p><pre><code class="js">var avar b = &quot;&quot;var c = nullconsole.log(a === undefined) //trueconsole.log(b === undefined) //falseconsole.log(c == undefined) //true</code></pre><h5 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h5><h6 id="encodeURI-URIString"><a href="#encodeURI-URIString" class="headerlink" title="encodeURI(URIString)"></a>encodeURI(URIString)</h6><p>功能：将字符串作为 URI 进行编码，返回值为 URIstring 的副本</p><p>参数：URIString(必须)，一个待编码的字符串</p><blockquote><p>该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( ) 。</p><p>该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：;/?:@&amp;=+$,#</p><p>如果 URI 组件中含有分隔符，比如 ? 和 #，则应当使用 encodeURIComponent() 方法分别对各组件进行编码</p></blockquote><p>示例：</p><pre><code class="js">console.log(encodeURI(&quot;http://www.baidu.com/my m?:@&amp;=+$#&quot;))// http://www.baidu.com/my%20m?:@&amp;=+$#</code></pre><h6 id="decodeURI"><a href="#decodeURI" class="headerlink" title="decodeURI()"></a>decodeURI()</h6><p>功能：上述解码</p><h6 id="encodeURIComponent-URIString"><a href="#encodeURIComponent-URIString" class="headerlink" title="encodeURIComponent(URIString)"></a>encodeURIComponent(URIString)</h6><p>功能：将字符串作为 URI 组件进行编码，返回值为 URIstring 的副本</p><p>参数：URIString(必须)，一个待编码的字符串</p><blockquote><p>该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( )</p><p>其他字符（比如 ：;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的</p></blockquote><blockquote><p>encodeURI 和 encodeURIComponent 的区别：</p><p>它们都是编码 URL，唯一区别就是编码的字符范围，其中 encodeURI 方法不会对下列字符编码 ASCII 字母、数字、<del>!@#$&amp;_()=:/,;?+’<br>encodeURIComponent 方法不会对下列字符编码 ASCII 字母、数字、</del>!_()’<br>所以 encodeURIComponent 比 encodeURI 编码的范围更大。<br>实际例子来说，encodeURIComponent 会把 http:// 编码成 http%3A%2F%2F 而 encodeURI 却不会。</p></blockquote><p>示例：</p><pre><code class="js">console.log(encodeURI(&#39;http://www.baidu.com/home/some other thing&#39;)//编码后为：http://www.baidu.com/home/some%20other%20thing 空格被编码成了%20console.log(encodeURIComponent(&#39;http://www.baidu.com/home/some other thing&#39;))//http%3A%2F%2Fwww.baidu.com%2Fhome%2Fsome%20other%20thing    &quot;/&quot;被编码，无法使用var param = &quot;http://www.baidu.com/home/&quot;     //param为参数param = encodeURIComponent(param)var url = &quot;http://www.baidu.com?next=&quot; + paramconsole.log(url) //&#39;http://www.baidu.com?next=http%3A%2F%2Fwww.baidu.com%2Fhome%2F&#39;// 参数中的 &quot;/&quot; 被编码了，如果用encodeURI会出问题，因为后面的/是需要编码的</code></pre><h6 id="decodeURIComponent"><a href="#decodeURIComponent" class="headerlink" title="decodeURIComponent()"></a>decodeURIComponent()</h6><p>功能：上述解码</p><h6 id="escape-string"><a href="#escape-string" class="headerlink" title="escape(string)"></a>escape(string)</h6><p>功能：对字符串进行编码，把中文变乱码</p><blockquote><p>会转义除了<code>@*_+-./</code>以外的所有字符</p><p>已经从 Web 标准中废弃。绝大多数情况都可以使用<code>encodeURI</code>和<code>encodeURIComponent</code>来代替</p></blockquote><p>示例：</p><pre><code class="js">var aaa = &quot;中国123,&quot;escape(aaa) // &quot;%u4E2D%u56FD123%2C&quot;</code></pre><h6 id="unescape"><a href="#unescape" class="headerlink" title="unescape()"></a>unescape()</h6><p>功能：上述反编译</p><h6 id="parseInt-string-radix"><a href="#parseInt-string-radix" class="headerlink" title="parseInt(string,radix)"></a>parseInt(string,radix)</h6><p>功能：解析一个字符串，并返回一个整数。</p><p>参数：</p><ul><li>string(必须)：待解析的字符串</li><li>radix(可选)：表示要解析的数字的基数。该值介于 2 ~ 36 之间，如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN</li></ul><blockquote><p>开头和结尾的空格是允许的</p><p>如果字符串的第一个字符不能被转换为数字，那么 parseFloat() 会返回 NaN</p><p>当参数  <em>radix</em>  的值为 0，或没有设置该参数时，parseInt() 会根据  <em>string</em>  来判断数字的基数 。如果 string 以 “0x” 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。如果 string 以 0 开头，那么 ECMAScript v3 允许 parseInt() 的一个实现把其后的字符解析为八进制或十六进制的数字。如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数</p></blockquote><p>示例：</p><pre><code class="js">parseInt(&quot;10&quot;) //返回 10parseInt(&quot;19&quot;, 10) //返回 19 (10+9)parseInt(&quot;11&quot;, 2) //返回 3 (2+1)parseInt(&quot;17&quot;, 8) //返回 15 (8+7)parseInt(&quot;1f&quot;, 16) //返回 31 (16+15)parseInt(&quot;010&quot;) //未定：返回 10 或 8parseInt(&quot;0x0011&quot;) //17</code></pre><h6 id="parseFloat-string"><a href="#parseFloat-string" class="headerlink" title="parseFloat(string)"></a>parseFloat(string)</h6><p>功能：解析一个字符串，并返回一个浮点数</p><p>参数：string(必须)，待解析的字符串</p><blockquote><p>该函数指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止</p></blockquote><p>示例：</p><pre><code class="js">parseFloat(&quot;10&quot;) //10parseFloat(&quot;10.00&quot;) //10parseFloat(&quot;10.33&quot;) //10.33parseFloat(&quot; 60 &quot;) //60 首尾空格会忽略parseFloat(&quot;23 34 45&quot;) //23 中间空格不会忽略，会中断parseFloat(&quot;23 years&quot;) //23parseFloat(&quot;i am 23&quot;) //NaN</code></pre><h6 id="isFinite-number"><a href="#isFinite-number" class="headerlink" title="isFinite(number)"></a>isFinite(number)</h6><p>功能：用于检查其参数是否是无穷大</p><p>参数：</p><ul><li>number(必须)：待检测数字<br>如果 number 是有限数字（或可转换为有限数字），那么返回 true。否则，如果 number 是 NaN（非数字），或者是正、负无穷大的数，则返回 false</li></ul><p>示例：</p><pre><code class="js">console.log(isFinite(123)) //trueconsole.log(isFinite(-1.23)) //trueconsole.log(isFinite(6 - 3)) //trueconsole.log(isFinite(0)) //trueconsole.log(isFinite(0 / 0)) //falseconsole.log(isFinite(&quot;Hello&quot;)) //false</code></pre><h6 id="isNaN-number"><a href="#isNaN-number" class="headerlink" title="isNaN(number)"></a>isNaN(number)</h6><p>功能：用于检查其参数是否为非数字值</p><p>参数：</p><ul><li>number(必须)：待检测数字<br>如果 number 是非数字值 NaN（或者能被转换成 NaN），返回 true，否则返回 false</li></ul><p>示例：</p><pre><code class="js">console.log(isNaN(123)) //falseconsole.log(isNaN(-1.23)) //falseconsole.log(isNaN(6 - 3)) //falseconsole.log(isNaN(0)) //falseconsole.log(isNaN(0 / 0)) //trueconsole.log(isNaN(&quot;Hello&quot;)) //true</code></pre><h6 id="Number-object"><a href="#Number-object" class="headerlink" title="Number(object)"></a>Number(object)</h6><p>功能：把对象的值转换为数字</p><p>参数：</p><ul><li>object(必须)：待转换的对象<br>如果参数是 Date 对象，Number() 返回从 1970 年 1 月 1 日至今的毫秒数，即时间戳。如果对象的值无法转换为数字，那么 Number() 函数返回 NaN</li></ul><p>示例：</p><pre><code class="js">console.log(Number(true)) // 1console.log(Number(false)) // 0console.log(Number(new Date())) // 1506266494726console.log(Number(&quot;999&quot;)) // 999console.log(Number(&quot;999 888&quot;)) // NaN</code></pre><h6 id="String-object"><a href="#String-object" class="headerlink" title="String(object)"></a>String(object)</h6><p>功能：把对象的值转换为字符串</p><p>参数：object(必须)，待转换的对象</p><p>示例：</p><pre><code class="js">console.log(String(true)) // &#39;true&#39;</code></pre><h6 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h6><p>返回一个 JavaObject 的 JavaClass</p><h6 id="eval-string"><a href="#eval-string" class="headerlink" title="eval(string)"></a>eval(string)</h6><p>功能：可计算某个字符串，并执行其中的的 JavaScript 代码</p><p>参数：必需，要计算的字符串，其中含有要计算的 JavaScript 表达式或要执行的语句</p><p>返回值：通过计算 string 得到的值</p><h3 id="Console-对象"><a href="#Console-对象" class="headerlink" title="Console 对象"></a>Console 对象</h3><h5 id="console-log-text-text2-…"><a href="#console-log-text-text2-…" class="headerlink" title="console.log(text,text2,…)"></a>console.log(text,text2,…)</h5><p>用于在 console 窗口输出信息</p><blockquote><p>它可以接受多个参数，将它们的结果连接起来输出</p><p>如果第一个参数是格式字符串（使用了格式占位符）</p><p>console.log 方法将依次用后面的参数替换占位符，然后再进行输出</p></blockquote><h5 id="console-info"><a href="#console-info" class="headerlink" title="console.info()"></a>console.info()</h5><p>在 console 窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标</p><h5 id="console-debug"><a href="#console-debug" class="headerlink" title="console.debug()"></a>console.debug()</h5><p>在 console 窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标</p><h5 id="console-warn"><a href="#console-warn" class="headerlink" title="console.warn()"></a>console.warn()</h5><p>输出信息时，在最前面加一个黄色三角，表示警告</p><h5 id="console-error"><a href="#console-error" class="headerlink" title="console.error()"></a>console.error()</h5><p>输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈</p><h5 id="console-table"><a href="#console-table" class="headerlink" title="console.table()"></a>console.table()</h5><p>可以将复合类型的数据转为表格显示</p><h5 id="console-count"><a href="#console-count" class="headerlink" title="console.count()"></a>console.count()</h5><p>用于计数，输出它被调用了多少次</p><h5 id="console-dir"><a href="#console-dir" class="headerlink" title="console.dir()"></a>console.dir()</h5><p>用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示</p><h5 id="console-dirxml"><a href="#console-dirxml" class="headerlink" title="console.dirxml()"></a>console.dirxml()</h5><p>用于以目录树的形式，显示 DOM 节点</p><h5 id="console-assert"><a href="#console-assert" class="headerlink" title="console.assert()"></a>console.assert()</h5><p>接受两个参数，第一个参数是表达式，第二个参数是字符串</p><blockquote><p>只有当第一个参数为 false，才会输出第二个参数，否则不会有任何结果</p></blockquote><h5 id="console-time"><a href="#console-time" class="headerlink" title="console.time()"></a>console.time()</h5><h5 id="console-timeEnd"><a href="#console-timeEnd" class="headerlink" title="console.timeEnd()"></a>console.timeEnd()</h5><p>这两个方法用于计时，可以算出一个操作所花费的准确时间</p><blockquote><p>time 方法表示计时开始，timeEnd 方法表示计时结束, 它们的参数是计时器的名称</p><p>调用 timeEnd 方法之后，console 窗口会显示“计时器名称: 所耗费的时间”</p></blockquote><h5 id="console-profile"><a href="#console-profile" class="headerlink" title="console.profile()"></a>console.profile()</h5><p>用来新建一个性能测试器（profile），它的参数是性能测试器的名字</p><h5 id="console-profileEnd"><a href="#console-profileEnd" class="headerlink" title="console.profileEnd()"></a>console.profileEnd()</h5><p>用来结束正在运行的性能测试器</p><h5 id="console-group"><a href="#console-group" class="headerlink" title="console.group()"></a>console.group()</h5><h5 id="console-groupend"><a href="#console-groupend" class="headerlink" title="console.groupend()"></a>console.groupend()</h5><p>上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开</p><h5 id="console-groupCollapsed"><a href="#console-groupCollapsed" class="headerlink" title="console.groupCollapsed()"></a>console.groupCollapsed()</h5><p>用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的</p><h5 id="console-trace"><a href="#console-trace" class="headerlink" title="console.trace()"></a>console.trace()</h5><p>显示当前执行的代码在堆栈中的调用路径</p><h5 id="console-clear"><a href="#console-clear" class="headerlink" title="console.clear()"></a>console.clear()</h5><p>用于清除当前控制台的所有输出，将光标回置到第一行</p><blockquote><p>本文参考：</p><p><a href="https://segmentfault.com/a/1190000011467723#articleHeader1" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011467723#articleHeader1</a></p><p><a href="https://www.runoob.com/js/js-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/js/js-tutorial.html</a></p><p>您可以克隆到本地，随时随地翻阅，md 格式文档，推荐使用 typora</p><p>本文是为了熟悉下 JS 的 API 所写，只是些常用的，不如手册全面</p><p>如需全面的 api 文档，请移步菜鸟教程等 JS 手册</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue-cli2.0构建流程</title>
    <link href="/blog/2018/10/12/vue/Vue-cli2.0%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
    <url>/blog/2018/10/12/vue/Vue-cli2.0%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-cli2-0-构建流程"><a href="#Vue-cli2-0-构建流程" class="headerlink" title="Vue-cli2.0 构建流程"></a>Vue-cli2.0 构建流程</h1><p>学习 vue 时，总觉得 vue-cli 搭建很复杂，其实也不过如此，使用别人搭建好的包在打包时总会报一些莫名其妙的错误，还是自己动手比较可靠，就像我总觉得我自己写的代码是最好的^_^</p><p>首先，检测 NodeJS 环境</p><p>Windows+R 快捷键打开 cmd 输入以下命令</p><pre><code class="js">node - v</code></pre><p>如果出现 NodeJS 的版本号，表示你已经安装了 NodeJS</p><p><img src="/img/blog/old.assets/01.png" srcset="/img/loading.gif" alt=""></p><p>反之就是没有安装 NodeJS 了</p><p>安装 NodeJS 请走官网传送门</p><p><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">传送门—NodeJS 安装</a></p><p>接下来就正式进入今天的主题脚手架搭建了</p><p>你可以使用 npm 安装，npm 安装速度慢些（因为服务器在国外），你也可以使用淘宝的镜像安装</p><p>安装淘宝镜像，打开 cmd 命令框，输入</p><pre><code class="js">npm install -g cnpm –registry=https://registry.npm.taobao.org</code></pre><p>安装淘宝镜像之后把命令中的 npm 变成 cnpm 就可以了，我这里使用的是 npm 安装 (因为我觉得也慢不了多少)</p><p>全局安装 Vue 脚手架</p><pre><code class="js">npm install -g vue-cli</code></pre><p>安装成功之后 cd 进你的项目文件夹目录</p><p>初始化项目</p><pre><code class="js">vue-init &lt;template-name&gt; [project-name]# &lt;template-name&gt; —— 打包工具# [project-name]  —— 项目名称</code></pre><p><img src="/img/blog/old.assets/02.png" srcset="/img/loading.gif" alt=""></p><p>回答完问题稍等片刻，初始化成功之后就会显示以下内容</p><p><img src="/img/blog/old.assets/03.png" srcset="/img/loading.gif" alt=""></p><p>然后根据提示 cd 进你的项目目录</p><p>输入<code>npm run dev</code>运行项目，如下</p><p><img src="/img/blog/old.assets/04.png" srcset="/img/loading.gif" alt=""></p><p>这个时候就可以在浏览器输入 <code>http://localhost:8080</code> ，出现以下界面脚手架搭建成功</p><p><img src="/img/blog/old.assets/05.png" srcset="/img/loading.gif" alt=""></p><p>以上就是 vue-cli 搭建的全部过程</p><p>脚手架项目结构</p><pre><code class="js">├── build/                      # webpack 编译配置文件: 开发环境与生产环境│   └── ...├── config/│   ├── index.js                # 项目核心配置│   └── ...├ ── node_module/               # 项目中安装的依赖包   ── src/│   ├── main.js                 # 项目入口文件│   ├── App.vue                 # 项目入口vue组件│   ├── components/             # 组件│   │   └── ...│   └── assets/                 # 资源文件，一般放一些静态资源│       └── ...├── static/                     # 纯静态资源 (打包时不会编译，会直接拷贝到dist/static/里面)├── test/│   └── unit/                   # 单元测试│   │   ├── specs/              # 测试规范│   │   ├── index.js            # 测试入口文件│   │   └── karma.conf.js       # 测试运行配置文件│   └── e2e/                    # 端到端测试│   │   ├── specs/              # 测试规范│   │   ├── custom-assertions/  # 端到端测试自定义断言│   │   ├── runner.js           # 运行测试的脚本│   │   └── nightwatch.conf.js  # 运行测试的配置文件├── .babelrc                    # babel 配置文件├── .editorconfig               # 编辑配置文件├── .gitignore                  # 用来过滤一些版本控制的文件，比如node_modules文件夹├── index.html                  # index.html 项目模板入口文件└── package.json                # 项目文件，记载项目依赖及项目说明（重）└── README.md                   # 说明文档，介绍自己的项目，markdown语法书写</code></pre><p>最后项目打包请输入</p><pre><code class="js">npm run bulid</code></pre><p>打包完成后会在项目目录下生成一个 dist 文件</p><pre><code class="js">├── dist/│   ├── index.js                # 项目入口文件│   └── static                   # 静态资源及打包后的一些js/css文件</code></pre><p>详情待续。。。</p><p>最后：喜欢前端，欢迎探讨！！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>被摒弃的jQuery</title>
    <link href="/blog/2018/09/26/jquery/%E8%A2%AB%E6%91%92%E5%BC%83%E7%9A%84jQuery/"/>
    <url>/blog/2018/09/26/jquery/%E8%A2%AB%E6%91%92%E5%BC%83%E7%9A%84jQuery/</url>
    
    <content type="html"><![CDATA[<h1 id="被摒弃的-jQuery"><a href="#被摒弃的-jQuery" class="headerlink" title="被摒弃的 jQuery"></a>被摒弃的 jQuery</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>今年 IT 界发生了很多大事，无意间看到<code>jQ</code>的信息后，我决定码了这篇文章</p><p>首先回顾一下今年的大事(-_-)</p><p>十岁的 GitHub 作为全球最大开源代码托管网站，可谓是全球程序员的一片圣地，但是，今年 6 月，微软以 75 亿美元（折合人民币 480 亿 ）的价格收购了 Github</p><p>根据 cnBeta 新闻，在 GitHub 新闻发布之后，GitLab 收到了超过 14300 个独立访问者，这些开发者在 GitLab.com 上开设了超过 10 万个新的存储库</p><p>很多人因为 GitHub 被微软收购从而转去 GitLab，但是大家都没有想过 GitHub 的这种状况和 Google 投资了竞争对手的 GitLab 没有关系吗</p><p>想着也真是搞笑！</p><p>全球最大的闭源软件公司微软(Mircosoft)对于全球最大的开源软件社区 GitHub 的贡献最多</p><p>手握最大开源数据库 MySQL 和开源编程语言 Java 的 Oracle 是开源死敌</p><p>时代性的开源编程语言 Java 的老大 Oracle 在向非付费用户开枪了</p><p>全球最大源代码托管网站 Github 也被微软帝国收购</p><p>Google 也投资了 GitLab</p><p>开源缔造了 IT 时代，如果开源被把控。。。</p><p>目前，GitHub 一切正常，不知未来如何。。。</p><hr><p>喷了一下(~ _ ~)，以上不是本文主体，进入正题，在微软收购 GitHub 后，表示不打算在 GitHub 上做太多改变，且以开发者为中心的初心不会改变，会积极地拥抱开源 ，52 天后，也就是 7 月份，Github 做出一些微软特色的改变，这之中最重要的是 GitHub 网站<strong>重构过程中放弃了 jQuery</strong>，没有再次使用其他任何框架去代替它，而是使用了原生的 JS ，本文是我个人针对此事的看法:</p><h2 id="jQuery-简介"><a href="#jQuery-简介" class="headerlink" title="jQuery 简介"></a>jQuery 简介</h2><p>jQuery 诞生于 2006 年 8 月，作者 John Resig ，jQuery 倡导写更少的代码，做更多的事情。它封装了 JavaScript 常用的功能代码，提供一种简便的 JavaScript 设计模式，优化 HTML 文档操作、事件处理、动画设计和 Ajax 交互</p><p>jQuery 凭借着 跨浏览器、 简单高效 、稳定可靠 、 插件丰富 这些特性迅速风靡全球</p><p>jQuery 使得操作 DOM、定义动画和实现“AJAX”请求，变得十分简单。简单来说，它使得 Web 开发者可以创建更现代、更动态的效果 ，最重要的是，通过 jQuery 在一种浏览器上实现的功能，基本上也能在其他浏览器上运行</p><p>时至今日，jQuery 仍然在支撑着数以千万计各种规模网站的运作</p><p>但是 jQuery 为什么会被摒弃呢？综合网上以及我自己的看法我认为有以下几点：</p><h2 id="摒弃原因"><a href="#摒弃原因" class="headerlink" title="摒弃原因"></a>摒弃原因</h2><ul><li>原生 Js 的发展，使得原生 API 足够的强大</li><li>jQuery 中的经典<code>$(selector)</code> 可以简单地用<code>querySelectorAll()</code>替换</li><li>CSS 类名切换，可以通过<code>Element.classList</code>实现</li><li>CSS 现在支持在样式表中定义视觉动画，无需使用 JavaScript</li><li>$.ajax 请求可以用 Fetch 标准实现（在不支持的浏览器上可以使用 XHR）</li><li><code>addEventListener()</code>接口已经十分稳定，足以跨平台使用</li><li>jQuery 提供的一些语法糖，已随着 JavaScript 语言的发展，而变得多余</li><li>链式语法并不能满足我们直观地书写代码的需要</li><li>自定义元素技术让用户无需下载、解析或编译任何框架</li><li>原生作为标准，更方便以后维持代码的灵活性</li><li>jQuery 大量 DOM 操作虽然方便，但是会牺牲很多页面的性能</li><li>浏览器兼容问题越来越少 ，如今浏览器 API 及其 polyfill 已经有足够标准化的 Web 应用程序开发</li><li>React、Vue 和 Angularjs 等主流前端框架并不依赖 jQuery，都可以独立使用</li><li>以 DOM 为中心的开发模式过于传统 ，目前复杂页面开发流行的是以数据/状态为中心的开发模式</li><li>前端服务化的趋势，<strong>同构</strong>渲染的问题，也是一个要移除 jQuery 的迫切原因</li></ul><p>同构</p><p>同构指前后端运行同一份代码，后端也可以渲染出页面。React 等流行框架天然支持，已经具有可行性。把现有应用改成同构时，因为代码要运行在服务端，但服务端没有 DOM，所以引用 jQuery 就会报错，在很多场合也要避免直接操作 DOM。</p><h2 id="个人感言"><a href="#个人感言" class="headerlink" title="个人感言"></a>个人感言</h2><p>曾经辉煌的 jQuery 终于走到了可以华丽谢幕的时刻，当然，John Resig 是一个伟大的开发者，jQuery 也是一个伟大的工具，<code>一个伟大的工具是指，它解决的问题不再存在，那么可以功成身退了</code>，这句话我觉得非常好，jQuery 引领了一个前端时代，这是不可否认的</p><p>作为一个前端原生爱好者，个人觉得，随着时代的变迁、技术的进步，jQuery 赖以存在的环境正逐渐消失。jQuery 提供了非常易用的 DOM 操作 API，屏蔽了浏览器差异，虽然极大地提高了开发效率，但这也导致很多前端只懂 jQuery ，而忽略了 js，特别是对于那些对前端深感兴趣的初学者，很多都把重心放在了 jQuery 之类的库上，偏离了本质，等回过头来再研究 js 时，费时不说，还会很不习惯，甚至很难转变，长此以往，不利于 js 语言的蓬勃发展，在我心中，js 和 css 是真正的前端核心，这两样技术，js 主导着核心编程，css 引导我们探索与创造，对我来说，这两样水都很深，很难吃透，在工作中考虑开发效率的话，三大框架精一足以，简洁方便，一些简单的操作，原生即可</p><blockquote><p>本文参考</p><p><a href="https://blog.csdn.net/csdnnews/article/details/83189938" target="_blank" rel="noopener">使用了 23 年的 Java 不再免费！</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650698992&idx=1&sn=76bd487d3f044851aaa8da9fc914351d&chksm=bea6052389d18c3523e8024545a81d673c3220c2f21b16f80581fe5bea1d9c44afc849cf8b03&scene=21#wechat_redirect" target="_blank" rel="noopener">收购 GitHub 滔天争议后，微软回应一切</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650701571&idx=1&sn=61b9cf057317fe00b7bcab4a5a00f034&chksm=bea60ed089d187c67557636b61b73f877ddcce5cf4c946cdf7f27278e8dc3c4b60221c67145c&scene=21#wechat_redirect" target="_blank" rel="noopener">GitHub 改版并放弃了 jQuery</a></p><p><a href="https://githubengineering.com/removing-jquery-from-github-frontend/" target="_blank" rel="noopener">从 GitHub.com 前端删除 jQuery–英文原文</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中npm run build报“Error in parsing SVG Unquoted attribute value”</title>
    <link href="/blog/2018/09/11/vue/Error%20in%20parsing%20SVG%20Unquoted%20attribute%20value/"/>
    <url>/blog/2018/09/11/vue/Error%20in%20parsing%20SVG%20Unquoted%20attribute%20value/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-中-npm-run-build-报“Error-in-parsing-SVG-Unquoted-attribute-value”"><a href="#Vue-中-npm-run-build-报“Error-in-parsing-SVG-Unquoted-attribute-value”" class="headerlink" title="Vue 中 npm run build 报“Error in parsing SVG: Unquoted attribute value”"></a>Vue 中 npm run build 报“Error in parsing SVG: Unquoted attribute value”</h1><p>自己做的一个 Vue 项目，在打包时老是报这个错误</p><pre><code class="js"># Error in parsing SVG: Unquoted attribute value</code></pre><p>查了查网上说的，都说报错原因是压缩和抽离 CSS 的插件中只允许 SVG 使用双引号</p><p>就是项目中外部引入的 CSS 文件里的 SVG 只能是双引号</p><p>我找了好久，这可把我坑坏了。。。</p><p>想想那段时间真是难受。。。</p><p>后来找到了，分享一下，让大家快点脱坑。。。</p><p>首先，如果你项目中使用了 mui 的话应该在这里改</p><p>找到 mui 文件下的 iconfont.css 文件</p><pre><code class="js"># mui/css/iconfont.css</code></pre><p><img src="/img/blog/old.assets/one.png" srcset="/img/loading.gif" alt="001"></p><p>不要以为完了，还有</p><p>找到 mui 文件下的 mui.css 文件</p><pre><code class="js"># mui/css/mui.css</code></pre><p><img src="/img/blog/old.assets/two.png" srcset="/img/loading.gif" alt="002"></p><p>以上两个文件修改了再次 build</p><p>如果还报 SVG 的错误，请查看你所有引入的外部 CSS 文件吧</p><p>如果你确定你引入的 CSS 文件中确实没有 SVG 或者是 SVG 确实是双引号，那就没办法了老兄。。。</p><p>最后：喜欢前端，欢迎探讨！！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue不是内部或外部命令，也不是可执行的程序或批处理文件</title>
    <link href="/blog/2018/09/09/vue/Vue%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E6%88%96%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%B9%9F%E4%B8%8D%E6%98%AF%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%88%96%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6/"/>
    <url>/blog/2018/09/09/vue/Vue%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E6%88%96%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%B9%9F%E4%B8%8D%E6%98%AF%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%88%96%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-不是内部或外部命令，也不是可执行的程序或批处理文件"><a href="#Vue-不是内部或外部命令，也不是可执行的程序或批处理文件" class="headerlink" title="Vue 不是内部或外部命令，也不是可执行的程序或批处理文件"></a>Vue 不是内部或外部命令，也不是可执行的程序或批处理文件</h1><p>平常我们搭个脚手架，可能分分钟就完事了，但是容易忽略一些细节，比如搭脚手架时 cmd 查 vue 版本号报<code>vue不是内部或外部命令，也不是可执行的程序或批处理文件</code>这种错误，明明 vue 下载了，脚手架下载完了怎么也初始化不了，你遇到过吗？</p><p>如果你确实已经在全局状态下安装了 vue 和 vue-cli，cmd<code>vue -V</code>或<code>vue init</code>还是报这个错，嗯，有必要往下看看！</p><p>解决办法：</p><p>配置 vue 的环境变量</p><ul><li>搜索 vue.cmd 文件，复制该文件地址，待用</li><li>注：如果搜索不到，请再下载一遍 vue。。</li></ul><p><img src="/img/blog/old.assets/000.png" srcset="/img/loading.gif" alt=""></p><ul><li>windows 下进入<code>控制面板\系统和安全\系统</code>点击更改设置</li></ul><p><img src="/img/blog/old.assets/001.png" srcset="/img/loading.gif" alt=""></p><ul><li>点击高级–环境变量</li></ul><p><img src="/img/blog/old.assets/002.png" srcset="/img/loading.gif" alt=""></p><ul><li>新建一个系统变量</li></ul><p><img src="/img/blog/old.assets/003.png" srcset="/img/loading.gif" alt=""></p><ul><li>输入变量名为 Path，变量值为刚复制的 vue.cmd 文件路径</li></ul><p><img src="/img/blog/old.assets/004.png" srcset="/img/loading.gif" alt=""></p><ul><li>保存重新运行 cmd 输入<code>vue -V</code>即可</li></ul><p>完美结束！！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub 免费搭建个人网站</title>
    <link href="/blog/2018/09/06/else/GitHub%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/"/>
    <url>/blog/2018/09/06/else/GitHub%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h1 id="GitHub-免费搭建个人网站"><a href="#GitHub-免费搭建个人网站" class="headerlink" title="GitHub 免费搭建个人网站"></a>GitHub 免费搭建个人网站</h1><p>学习前端的人应该知道，开始学习前端时，心里想的肯定是我一定要给自己做一个的非常棒的网站，学完之后网站做好了，但是要怎么上线呢？？？</p><p>作为一个前端，拥有有自己的个人网站，算是迈出了前端道路的第一步！</p><h4 id="本文目的"><a href="#本文目的" class="headerlink" title="本文目的"></a>本文目的</h4><p>通过<strong>GitHub Pages</strong>免费快速的搭建个人网站，文章随长，其实非常简单，写的详细是为了能够让多数人都能够看得懂</p><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><h4 id="建站常识"><a href="#建站常识" class="headerlink" title="建站常识"></a>建站常识</h4><p>首先了解常识，建站三部曲：</p><ul><li>网站项目</li><li>服务器</li><li>域名</li></ul><p>简单来说，就是我们要有一个域名，然后绑定服务器，再把网站上传到服务器上，这样就可以通过域名访问我们的网站了</p><p><strong>网站项目</strong>就是你写的网站文件，这个如果不会的话请去学习前端 <a href="http://www.w3school.com.cn/" target="_blank" rel="noopener">w3school 传送门</a></p><p><strong>服务器</strong>就是网络中为用户提供服务的专用设备。分为访问、文件、数据库、通信等不同功能的服务器。那么要怎样拥有一个服务器呢，(用钱就好了！！！)，正规途径是在网上买一个服务器，看图</p><p><img src="/img/blog/old.assets/fuwuqi1.png" srcset="/img/loading.gif" alt="图1"></p><p>刚开始玩的话买一个空间小的相对便宜的就行，当然有钱请随意！！！</p><p><strong>域名</strong>就是访问网站的网址，怎样获取域名，没错还是用钱，看图</p><p><img src="/img/blog/old.assets/yuming1.png" srcset="/img/loading.gif" alt="图2"></p><p>我的域名是在阿里云注册的，域名也是有区别的，后缀不一，长短不一，相对价钱就不一，如我的域名：</p><p><a href="https://isboyjc.top" target="_blank" rel="noopener">isboyjc.top</a></p><p>欢迎访问啊！不要问为什么是<code>.top</code>的后缀，因为<code>.top</code>的域名最贵了，我最有钱，我最任性</p><p>域名注册好之后首先要进行实名认证，然后域名解析、绑定服务器，最后把网站上传服务器，进行网站备案，静候备案成功就可以了（<strong>注</strong>：国内服务器需要备案，国外或香港服务器不用备案，但是相比国内服务器访问速度慢点，因为距离远嘛！）</p><p>这是一个网站上线的基本流程，当然以上不是本文重点，这些只是一些必备的常识，重点在下面</p><h4 id="GitHub-Pages-建站"><a href="#GitHub-Pages-建站" class="headerlink" title="GitHub Pages 建站"></a>GitHub Pages 建站</h4><p>什么是 GitHub Pages？</p><p>我就不照抄官方文档了，想了解请走传送门</p><p><a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages 传送门</a></p><p>官方文档比较高大上，简单来说 GitHub Pages 就是一个服务器，但它是免费的！免费的！免费的！重要的事说三遍！它能提供给我们 1G 空间的存储，让你放东西，然后还可以请求到</p><p>当然 GitHub Pages 还有一些其他的东西，不过我们的宗旨是建站，其他不用了解</p><p><strong>重点来了：</strong></p><p>登录<a href="https://github.com" target="_blank" rel="noopener">GitHub.com</a>官网(全英的界面，英语不好的朋友请用谷歌翻译！)</p><p><img src="/img/blog/old.assets/github.PNG" srcset="/img/loading.gif" alt=""></p><p>登录后点击右上角的加号，进入<code>new repository</code>选项新建一个储存库,看到以下界面</p><p><img src="/img/blog/old.assets/ku.PNG" srcset="/img/loading.gif" alt=""></p><p>首先输入库名，仓库名字为固定格式</p><pre><code>你的GitHub名.github.io// 例：// 我的GitHub名字为 isboyjc，所以库名为 isboyjc.github.io</code></pre><p>中间还有个储存库说明，可以不写，储存库说明下有一个自动为你选上的<code>Public</code>选项，意思是公开此储存库（就是别人可以看到并下载你库中的内容，当然可以不公开，但是要收费 7 美金/月，这个完全没有必要，因为 IT 的精华就是开源！当然土豪请随意！）</p><p>最后点击绿色按钮提交创建，提交后如下图</p><p><img src="/img/blog/old.assets/create.PNG" srcset="/img/loading.gif" alt=""></p><p>点击<code>README</code>进行初始化 README ，就是用<code>markdown</code>语法编写此储存库的具体说明或者说简单的展示，<code>markdown</code>语法十分简单，我也写了相应的<code>markdown</code>语法教程<a href="#">markdown 和 Typora–传送门</a>，有兴趣可以了解一下，当然这里不写也是可以的，直接点击下面绿色按钮提交即可</p><p><img src="/img/blog/old.assets/anniu.PNG" srcset="/img/loading.gif" alt=""></p><p>再然后是如下界面：</p><p><img src="/img/blog/old.assets/end.PNG" srcset="/img/loading.gif" alt=""></p><p>上面图片红色框中依次翻译为：创建新文件、上传文件、查找文件、克隆或下载</p><p>点击<code>Upload files</code>上传文件</p><p><img src="/img/blog/old.assets/endd.PNG" srcset="/img/loading.gif" alt=""></p><p>点击<code>choose your files</code>选择文件上传，最后绿色按钮提交(<strong>注：</strong>上传的文件为你的网站文件，默认访问<code>index.html</code>文件所以你的网站首页一定要是<code>index.html</code>，css、js、img 文件同 html 文件一同拖拽进去即可，网速慢的话上传速度较慢请耐心等待，上传失败请重新上传)</p><p>这时神奇的一幕就来了，如果你的操作没错，这时你就可以在浏览器输入<code>你的GitHub名.github.io</code>访问你的网站了（<strong>注：</strong>如果你的储存库下没有<code>index.html文件</code>，访问时会自动显示你的<code>README.md</code>文档）！！！如下：</p><p><a href="https://isboyjc.github.io" target="_blank" rel="noopener">https://isboyjc.github.io</a></p><p>这个名字有点长，我想通过自己购买的域名访问怎么办呢？</p><p>接着往下看</p><h4 id="GitHub-Pages-域名绑定"><a href="#GitHub-Pages-域名绑定" class="headerlink" title="GitHub Pages 域名绑定"></a>GitHub Pages 域名绑定</h4><p>首先是域名解析</p><p>进入你的域名控制台，我的域名是阿里云注册的，所以本文以阿里云为例，如下图</p><p><img src="/img/blog/old.assets/con1.PNG" srcset="/img/loading.gif" alt=""></p><p>点击解析进入解析添加解析，如下图</p><p><img src="/img/blog/old.assets/jiexi.PNG" srcset="/img/loading.gif" alt=""></p><p><strong>记录类型</strong></p><p>记录类型我们选择<code>CNAME</code>，别名记录，就是把一个域名完完全全设置为另外一个域名的别名</p><p><strong>主机记录</strong></p><p>主机记录就是域名前缀，常见用法有：</p><pre><code>www：解析后的域名为www.aliyun.com@：直接解析主域名 aliyun.com*：泛解析，匹配其他所有域名 *.aliyun.commail：将域名解析为mail.aliyun.com，通常用于解析邮箱服务器二级域名：如：abc.aliyun.com，填写abc手机网站：如：m.aliyun.com，填写m显性URL：不支持泛解析（泛解析：将所有子域名解析到同一地址）</code></pre><p>举个例纸，我购买的域名是<code>isboyjc.top</code>我添加了两个域名解析，一个主机记录是<code>@</code>，一个主机记录是<code>www</code>，意思是让我的网站能够分别通过<code>isboyjc.top</code>和<code>www.isboyjc.top</code>访问到</p><p><strong>解析路线</strong></p><pre><code>如果只有一个IP地址或CNAME域名，请务必选择【默认】默认：必填！未匹配到智能解析线路时，返回【默认】线路设置结果境外：向除中国大陆以外的其他国家和地区，返回设置的记录值搜索引擎：向搜索引擎爬虫的DNS，返回设置的记录值</code></pre><p><strong>记录值</strong></p><p>因为我们使用的是<code>GitHub Pages</code>服务器，所以记录值填写为之前的仓库名<code>你的GitHub名字.github.io</code>，如果是你自己购买的服务器，解析时记录值应该填写为你的服务器主机地址</p><p><strong>TTL</strong></p><p>TTL 指的是域名解析的生命周期，简单来说它表示 DNS 服务器解析域名时记录在 DNS 服务器上的缓存时间</p><p>什么意思呢，来点题外话，先说下网站的访问流程，你的网站文件存储在数据服务器上，它会有一个 IP 地址，就像门牌号一样，我们在输入域名访问网站时，数据服务器是不认识你这个域名的，它只认识 IP，你的域名会通过 DNS 服务器解析成 IP 值，通过这个门牌号(IP 值)向数据服务器查找你的网站数据并给你返回到浏览器上</p><p>访问网站时，不会每次都到 DNS 服务器域名解析，而是第一次访问时才到 DNS 服务器进行解析，然后解析的结果会缓存到当地的递归 DNS 服务器(缓存服务器)上，当地的第二个用户访问网站时，递归服务器会直接返回解析结果，而不会再向 DNS 服务器请求解析，那多久之后递归服务器才会更新这个解析结果呢？这就是 TTL 来决定的</p><p>如果增大 TTL 值，可以节约域名解析时间，给网站访问加速 ，TTL 值大多都是以秒为单位的，很多的默认值都是 3600，也就是默认缓存 1 小时，这个值有点小了，难道会有人一个小时就改一次域名记录吗</p><p>如果减小 TTL 值，可以减少更换空间时的不可访问时间 ，如果 TTL 值大了，更换新的域名记录时因为 TTL 缓存的问题，结果可能是有的人可能访问到了新服务器，有的人访问走缓存会访问到了旧的服务器</p><p>那么 TTL 值多少才好呢？</p><p>总的来说，你要访问速度，TTL 值就大一点，如果你近期想更换服务器或 IP，为了更换后能尽量解析到新的 IP 上，TTL 值就小一点，说的有点多了，好了，跳过这个话题，回到主题，本文介绍的是个人建站，一般个人网站建议设置 TTL 值为 600，也就是 10 分钟是刚好的！</p><p>上面的东西弄完之后只剩最后一步啦！！！</p><p><strong>在 GitHub 仓库页添加 CNAME 文件</strong></p><p><img src="/img/blog/old.assets/cname.PNG" srcset="/img/loading.gif" alt=""></p><p>还是上传文件的这个页面，点击<code>Create new file</code>创建一个新文件，文件名为<code>CNAME</code>，注意是大写，文件内容写你解析的域名，例：</p><pre><code>isboyjc.top</code></pre><p>如果你还解析了<code>www</code>的域名,那么你就在文件中写两个域名，例：</p><pre><code>isboyjc.topwww.isboyjc.top</code></pre><p>然后点击提交</p><p>最后，在浏览器上输入你的域名访问一下吧！！！</p><p>累死我了，终于写完了！！！</p>]]></content>
    
    
    <categories>
      
      <category>安利系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue打包后静态资源路径错误</title>
    <link href="/blog/2018/09/01/vue/Vue%E6%89%93%E5%8C%85%E5%90%8E%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E9%94%99%E8%AF%AF/"/>
    <url>/blog/2018/09/01/vue/Vue%E6%89%93%E5%8C%85%E5%90%8E%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-打包后静态资源路径错误"><a href="#Vue-打包后静态资源路径错误" class="headerlink" title="Vue 打包后静态资源路径错误"></a>Vue 打包后静态资源路径错误</h1><p>vue 项目打包完了，dist 文件也生成了，运行一下，又报错了</p><p>错误还不少，报了好多资源路径找不到的错误，大概有两种</p><ul><li>一种是 js 或 css 文件引入路径错误，找不到文件</li><li>一种是 css 中的图片路径错误，找不到图片</li></ul><p>#############################################</p><ul><li>js 或 css 文件引入路径错误解决办法如下：</li></ul><p>不知道大家发现没有，所有的路径错误都是少了个点，例如：</p><p><code>src=/static/js/app.5d7099352641a1a9dd32.js</code></p><p>知道原因了就找解决办法，手动加也行，不过为了每次打包完即用</p><p>在配置文件里改，一劳永逸</p><p>找到<code>config/index.js</code> 配置文件，找<code>build</code>打包对象里的<code>assetsPublicPath</code>属性</p><p>默认值为<code>/</code>，更改为<code>./</code>就好了</p><p><img src="/img/blog/old.assets/20190401001.png" srcset="/img/loading.gif" alt=""></p><ul><li>css 中的图片路径错误，找不到图片解决如下</li></ul><p>在 css 里引入图片路径打包的时候路径会错</p><p>打开<code>build/utils.js</code>文件，把打包 css 文件的配置加一个打包路径即可</p><p>加一行代码，如下</p><p><img src="/img/blog/old.assets/20190401002.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue打包后index.html中无引号</title>
    <link href="/blog/2018/08/26/vue/Vue%E6%89%93%E5%8C%85%E5%90%8Eindex.html%E4%B8%AD%E6%97%A0%E5%BC%95%E5%8F%B7/"/>
    <url>/blog/2018/08/26/vue/Vue%E6%89%93%E5%8C%85%E5%90%8Eindex.html%E4%B8%AD%E6%97%A0%E5%BC%95%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-打包后-index-html-中无引号"><a href="#Vue-打包后-index-html-中无引号" class="headerlink" title="Vue 打包后 index.html 中无引号"></a>Vue 打包后 index.html 中无引号</h1><p>嗯，历经了千山万水，踩过了无数个坑，终于打包成功了</p><p>点击<code>index.html</code>，报错了，打开代码一看，<code>index.html</code>中路径都不带引号，如下。。。</p><p><code>&lt;link href=/static/css/app.262f48fe370f0ecbe3bd043450d7d62e.css rel=stylesheet&gt;</code></p><p>手动加吧，可行，但是一次又一次打包都手动有点浪费时间</p><p>嗯，聪明人有办法</p><p>找打包配置吧，在<code>build</code>目录下有一个<code>webpack.prod.conf.js</code>文件</p><p>这个文件中搜索<code>minify</code>，这个对象是压缩配置</p><p>在这个对象中有一个叫<code>removeAttributeQuotes</code>的属性，就是删除属性引用的意思</p><p>它的值默认为<code>true</code>，那就直接把他改成<code>false</code>就好了</p><p>现在可以再次<code>build</code>一下试试看了</p><p>如果<code>index.html</code>中还是没有引号，就把<code>minify</code>对象都注释再<code>build</code></p><p>完美解决，perfect！！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>function与感叹号</title>
    <link href="/blog/2018/06/25/javascript/function&amp;!/"/>
    <url>/blog/2018/06/25/javascript/function&amp;!/</url>
    
    <content type="html"><![CDATA[<h1 id="function-与感叹号"><a href="#function-与感叹号" class="headerlink" title="function 与感叹号"></a>function 与感叹号</h1><p>相信大家都看到过在很多 js 代码中函数前面会有一个感叹号，这是什么意思呢？</p><pre><code class="js">!(function() {  alert(&quot;我最帅！&quot;)})() // true</code></pre><p>如上所示，这行代码在控制台输出，会执行 alert 语句，并返回 true，这是为什么呢？</p><p>这是一个匿名函数自调，但是它输出了，并且返回了 true，首先，解释下为什么返回 true，这个不难理解，匿名函数的返回值是<code>undefined</code>，感叹号是非的意思，前面加一个非变成<code>!undefined</code>，所以返回 true，不过重点不在这</p><pre><code class="js">function(){alert(&#39;无敌了&#39;)}()            // 语法错误</code></pre><p>我们都知道，如上所示的这种写法是不对的</p><p>匿名函数自调一般我们都会采用下面两种写法</p><pre><code class="js">;(function() {  alert(&quot;嗯，输出了&quot;)})();(function() {  alert(&quot;嗯，也输出了&quot;)})()</code></pre><p>那为什么上面把括号换成了感叹号的写法也可以执行匿名函数呢？</p><p>又是什么好处使多数前端攻城狮对这种叹号的方式情有独钟？ 是因为感叹号的一个字符比起括号的两个字符更节省空间吗？</p><p>节省空间显然是没有太大的说服力的，确实累死也节省不了多少内存啊，那又是为了什么呢？</p><p>首先我们来说一下为什么感叹号写法可以执行匿名函数</p><p>其实不管是括号还是感叹号的写法都是为了<strong>让 js 函数声明变成函数表达式</strong></p><p>看下面代码的解析</p><pre><code class="js">function fn(){&#39;我又来了&#39;}()        // Unexpected token</code></pre><p>上述代码报错是为什么呢</p><p>大家都知道，<code>function(){}</code>是函数声明，是一个完整的语句，js 解释器在解释完这个语句后就结束了，结束后会再解析后面的<code>()</code>，而 js 语法中<code>()</code>里面是需要有表达式语句的，这里<code>()</code>里面什么都没有，所以 js 解析就会报语法错误，完整来说，就是前面的<code>function fn(){&#39;我又来了&#39;}</code>这句函数声明语句是没有错误的，报的错是<code>()</code>的错误，不信你可以控制台把这条语句分开输入试试</p><p>结果肯定是函数语句没错，错的是<code>()</code></p><pre><code class="js">function(){&#39;没错，又是我&#39;}()        // Unexpected token</code></pre><p>那这条代码为什么错误呢？如上</p><p>注意这条代码和上面那条是不一样的，这条代码函数没有名字，众所周知，函数只有在函数表达式中才可以匿名，所以这里的错误是因为函数没有名字，之后的<code>()</code>根本就不会执行</p><pre><code class="js">var fn = function() {  alert(250)}fn()</code></pre><p>这样为什么会执行？如上</p><p>因为变量<code>fn</code>是函数表达式的引用，相当于调用了一个表达式</p><pre><code class="js">function fn() {  alert(&quot;哈哈哈&quot;)}fn()</code></pre><p>这样又是为什么可以执行呢？如上</p><p>是因为<code>fn</code>是函数名，它指向了这个函数，在当前的作用域中当然可以调用了</p><pre><code class="js">;(function() {  alert(111)})()</code></pre><p>这样为什么又可以执行呢？如上</p><p>是因为 js 语法中<code>()</code>中只能是表达式，所以上述代码强制让 js 解释器认为里面的函数是一个表达式，所以语句后面加上<code>()</code>就可以执行函数了</p><p>综上所述，想要实现调用一个函数，只需要把函数变成表达式调用就行了</p><p>那么怎样可以把函数变成表达式呢</p><p>当然，括号和文章开头的感叹号都是可以的</p><p>其实有很多种方法都可以把函数变成表达式</p><pre><code class="js">!(function() {  alert(1)})() + // true(function() {  alert(1)})() - // NAN  (function() {    alert(1)  })() // NAN~(function() {  alert(1)})() // -1new (function() {  alert(1)})() // Objectdelete (function() {  alert(1)})() // truevoid (function() {  alert(1)})()(  // undefined  function() {    alert(1)  })() // undefined</code></pre><p>如上所示，这些一元运算符和关键字都可以，括号当然也没问题，并且这些写法都是合法的，唯一不同的是返回值不同罢了，但是我们的宗旨是调用匿名函数，返回值一般情况下是不需要在意的</p><p>最后是关于性能了，这些写法中，除了<code>new</code>的方式最慢(可以理解，对象嘛！！！)，括号和加减号的方式最快，其他都差不多，所以说这几种写法都是可行的，但是为什么那么多的人用感叹号不用速度快又标准的括号呢？</p><p>个人认为 q 前端攻城狮喜欢用感叹号自调用函数的原因有四：</p><ul><li><p>one</p><p>感叹号确实比<code>()</code>简单点</p></li><li><p>two</p><p>感叹号的代码可读性较强</p></li><li><p>three</p><p>个人习惯</p></li><li><p>four</p><p>写代码不喜欢写分号的开发者在函数自调用时通常喜欢用感叹号</p><p>因为感叹号可以让我们自调用函数时不写分号也不报错，它防止了代码在合并的时候发生错误</p><p>不写分号的情况下用()的方式自调用函数会报错，虽然 js 解释器会自动补全分号</p><p>为什么<code>()</code>写法会报错呢，这个问题又牵扯到了 js 代码风格了</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
